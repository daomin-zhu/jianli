
### [**进程与线程**](http://blog.csdn.net/shanghairuoxiao/article/details/74012512)
```
(1) 进程与线程区别？

(2) 线程比进程具有哪些优势？

(3) 什么时候用多进程？什么时候用多线程？

(4) LINUX中进程和线程使用的几个函数？

(5) 线程同步？

在Windows下线程同步的方式有：互斥量，信号量，事件，关键代码段

在Linux下线程同步的方式有：互斥锁，自旋锁，读写锁，屏障(并发完成同一项任务时，屏障的作用特别好使)

知道这些锁之间的区别，使用场景？

```
互斥锁
```
```
读写锁的读锁原理
```
如果有线程想申请读锁的话，首先会判断写锁是否被持有，如果写锁被持有且当前线程并不是持有写锁的线程，那么就会返回-1，
获取锁失败，进入到等待队列等待。如果写锁未被线程所持有或者当前线程和持有写锁的线程是同一线程的话就会开始获取读锁
```

### Linux的API
- **fork与vfork区别**
fork和vfork都用于创建子进程。但是vfork创建子进程后，父进程阻塞，直到子进程调用exit()或者excle()。
对于内核中过程fork通过调用clone函数，然后clone函数调用do_fork()。do_fork()中调用copy_process()函数先复制task_struct结构体，然后复制其他关于内存，文件，寄存器等信息。fork采用写时拷贝技术，因此子进程和父进程的页表指向相同的页框。但是vfork不需要拷贝页表，因为父进程会一直阻塞，直接使用父进程页表。

- **exit()与_exit()区别**
exit()清理后进入内核，_exit()直接陷入内核。


- 孤儿进程与僵死进程
1. 孤儿进程是怎么产生的？
```
一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。
孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
```
2. 僵死进程是怎么产生的？
```
子进程先于父进程退出后，子进程的PCB需要其父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程就称为僵尸进程，僵尸进程实际上是一个已经死掉的进程
```
3. 僵死进程的危害？
```
如果有大量的僵尸进程驻在系统之中，必然消耗大量的系统资源。但是系统资源是有限的，因此当僵尸进程达到一定数目时，系统因缺乏资源而导致奔溃
```
4. 如何避免僵死进程的产生？
```
1）：一种比较暴力的做法是将其父进程杀死，那么它的子进程，即僵尸进程会变成孤儿进程，由系统来回收。但是这种做法在大多数情况下都是不可取的，如父进程是一个服务器程序，如果为了回收其子进程的资源，而杀死服务器程序，那么将导致整个服务器崩溃，得不偿失。显然这种回收进程的方式是不可取的，但其也有一定的存在意义。

2）：SIGCHLD信号处理

我们都知道wait函数是用来处理僵尸进程的，但是进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。
我们不希望有过多的僵尸进程产生，所以当父进程接收到SIGCHLD信号后就应该调用 wait 或 waitpid 函数对子进程进行善后处理，释放子进程占用的资源。
```

Linux是如何避免内存碎片的
```
1. 伙伴算法，用于管理物理内存，避免内存碎片;
2. 高速缓存Slab层用于管理内核分配内存，避免碎片。

伙伴: 大小相同、物理地址连续的两个页块称为伙伴
伙伴算法工作原理:
    首先在大小满足要求的块链表中查找是否有空闲块，若有则直接分配，
    否则在更大的块的块链表中查找；

    逆过程是块的释放，此时会把满足伙伴关系的块合并，
    组成一个更大的块，并插入到相应的块链表中
```
- **共享内存的实现原理？**

共享内存实现分为两种方式一种是采用mmap，另一种是采用XSI机制中的共享内存方法。mmap是内存文件映射，将一个文件映射到进程的地址空间，用户进程的地址空间的管理是通过vm_area_struct结构体进行管理的。mmap通过映射一个相同的文件到两个不同的进程，就能实现这两个进程的通信，采用该方法可以实现任意进程之间的通信。mmap也可以采用匿名映射，不指定映射的文件，但是只能在父子进程间通信。XSI的内存共享实际上也是通过映射文件实现，只是其映射的是一种特殊文件系统下的文件，该文件是不能通过read和write访问的。

二者区别：

> 1、 系统V共享内存中的数据，从来不写入到实际磁盘文件中去；而通过mmap()映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中。注：前面讲到，系统V共享内存机制实际是通过映射特殊文件系统shm中的文件实现的，文件系统shm的安装点在交换分区上，系统重新引导后，所有的内容都丢失。



> 2、 系统V共享内存是随内核持续的，即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在（除非显式删除共享内存），在内核重新引导之前，对该共享内存区域的任何改写操作都将一直保留。



> 3、 通过调用mmap()映射普通文件进行进程间通信时，一定要注意考虑进程何时终止对通信的影响。而通过系统V共享内存实现通信的进程则不然。注：这里没有给出shmctl的使用范例，原理与消息队列大同小异。



- 系统调用与库函数(open, close, create, lseek, write, read)

- 同步方法有哪些？

1. 互斥锁，自旋锁，信号量，读写锁，屏障

2. 互斥锁与自旋锁的区别：互斥锁得不到资源的时候阻塞，不占用cpu资源。自旋锁得不到资源的时候，不停的查询，而然占用cpu资源。

3. [死锁](http://blog.csdn.net/shanghairuoxiao/article/details/70444940)

### [**进程间通讯方式**](http://www.cnblogs.com/CheeseZH/p/5264465.html)



> **管道( pipe )**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

>

**命名管道 (FIFO) **： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

>

> **信号量**：信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据，有XSI信号量和POSIX信号量，POSIX信号量更加完善。

>

**消息队列( message queue )** ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

>

**共享内存( shared memory ) **：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。(原理一定要清楚，常考)

>

>**信号 ( sinal ) **： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，常见的信号。

>

**套接字( socket ) **： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。



- **匿名管道与命名管道的区别**：匿名管道只能在具有公共祖先的两个进程间使用。

- **共享文件映射mmap**

mmap建立进程空间到文件的映射，在建立的时候并不直接将文件拷贝到物理内存，同样采用缺页终端。mmap映射一个具体的文件可以实现任意进程间共享内存，映射一个匿名文件，可以实现父子进程间共享内存。



- **常见的信号有哪些？**：SIGINT，SIGKILL(不能被捕获)，SIGTERM(可以被捕获)，SIGSEGV，SIGCHLD，SIGALRM

### 进程调度

1. Linux进程分为两种，实时进程和非实时进程；

2. 优先级分为静态优先级和动态优先级，优先级的范围；

3. 调度策略，FIFO，LRU，时间片轮转

4. 交互进程通过平均睡眠时间而被奖励；
### 命令行
- Linux命令 在一个文件中，倒序打印第二行前100个大写字母
cat filename | head -n 2 | tail -n 1 | grep '[[:upper:]]' -o | tr -d '\n'| cut -c 1-100 | rev

- 与CPU，内存，磁盘相关的命令(top，free, df, fdisk)
- 网络相关的命令netstat，tcpdump等
- sed, awk, grep三个超强大的命名，分别用与格式化修改，统计，和正则查找
- ipcs和ipcrm命令
- 查找当前目录以及字母下以.c结尾的文件，且文件中包含"hello world"的文件的路径
- 创建定时任务


**********
### [**内存管理**](http://blog.csdn.net/shanghairuoxiao/article/details/70256247)

1. 虚拟内存的作用？

2. 虚拟内存的实现？

3. 操作系统层面对内存的管理？

4. 内存池的作用？STL里[内存池如何实现](https://github.com/oscarwin/MemoryPool)？

5. 进程空间和内核空间对内存的管理不同？

6. Linux的slab层，VAM？

7. 伙伴算法

8. 高端内存
