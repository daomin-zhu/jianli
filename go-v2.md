## 基础

### 基础数据结构

#### slice相关
---

底层实现
```
    切片是对数组一个连续片段的引用，是一个引用类型；
    本身是一个只读对象,其工作机制类似数据指针的一种封装；
    type slice sturct{
        array unsafe.Pointer //引用的数组指针
        len int //数组长度
        cap int //容量
    }
```
    
nil和空切片
```
nil切片:
    长度和容量都为0,和nil比较的结果为true
empty切片:
    长度和容量都为0,所有的空切片的数据指针都指向一个地址
    空切片和nil比较为false
区别是:
    空切片指向的地址不是nil，指向的是一个内存地址
    但是它没有分配任何内存空间，即底层元素包含0个元素
note:
    所有的空切片的数据指针指向同一个地址
```
reslice
```
定义:
    基于已有的slice创建新的slice对象
新slice和老slice共用底层数组,新老slice对底层数组的更改
都会影响到彼此
note:
    新老slice或者新slice 老数组互相影响的前提是两者共用底层数组
    如果因为执行 append 操作使得新 slice 底层数组扩容,移动到了新的位置,
    两者就不会相互影响了.所以,问题的关键在于两者是否会共用底层数组
```
扩容规则
```
1. 如果新申请的容量大于2倍的旧容量,最终容量就是新申请的容量
2. 否则，判断旧容量的长度小于1024,则最终容量就是旧容量的2倍
3. 否则，判断旧容量大于等于1024，则最终容量从旧容量开始循环增加
    原来的1/4，直至最终容量大于等于新申请的容量
    (分配之后都newcap做了内存对齐,这个和内存分配策略有关,新的slice容量
    要大于等于老slice容量的2倍或1.25倍)
4. 如果最终容量计算值溢出，则最终容量就是新申请的容量（TODO:溢出什么意思）
问题: 
    1. 扩容之后的数组一定是新的吗？
       不一定，如果数组长度满足扩容需求，会在原数组的基础上扩容
```
slice和array的区别
```
array: 
    1.数组长度固定，长度是数组类型的一部分;
    [3]int与[4]int是2种不同的类型
    2. 数组复制和传参都是值拷贝
slice: 
    1.切片非固定长度,包含长度，指针，容量三个属性
    2. 切片作为引用传递
```
为什么 nil slice 可以直接 append
```
    其实 nil slice 或者 empty slice 都是可以通过调用 append 函数来获得底层数组的扩容
    最终都是调用 mallocgc 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的nil slice 
    或 empty slice,然后摇身一变，成为“真正”的 slice 了
```
传 slice 和 slice 指针有什么区别
```
当 slice 作为函数参数时,就是一个普通的结构体
1. 若直接传 slice，在调用者看来,实参 slice 并不会被函数中的操作改变
2. 若传的是 slice 的指针，在调用者看来，是会被改变原 slice 的。
值的注意的是,不管传的是 slice 还是 slice 指针，
如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据
总结:
    当直接用切片作为函数参数时,可以改变切片的元素,不能改变切片本身;
    想要改变切片本身,可以将改变后的切片返回,函数调用者接收改变后的切片或者将切片指针作为函数参数
```

#### map相关
---
数据结构
```
// A header for a Go map.
type hmap struct {
    // 元素个数，调用 len(map) 时，直接返回此值
	count     int
	flags     uint8
	// buckets 的对数 log_2
	B         uint8
	// overflow 的 bucket 近似数
	noverflow uint16
	// 计算 key 的哈希的时候会传入哈希函数
	hash0     uint32
    // 指向 buckets 数组，大小为 2^B
    // 如果元素个数为0，就为 nil
	buckets    unsafe.Pointer
	// 扩容的时候，buckets 长度会是 oldbuckets 的两倍
	oldbuckets unsafe.Pointer
	// 指示扩容进度，小于此地址的 buckets 迁移完成
	nevacuate  uintptr
	extra *mapextra // optional fields
}
```
![map结构](https://user-images.githubusercontent.com/7698088/57576986-acd87600-749f-11e9-8710-75e423c7efdb.png)

扩容规则
```
TODO: 需要补充扩容规则
```
内存泄漏:
```
TODO:
    map扩容过程中会申请新的内存,扩容完成老的内存不会立即释放
    需要进一步了解原因
```
note:
```
    map是一个可以存储key/value对的数据结构,是一个引用类型；
    内部实现了一个hash table，因此map中存入的数据是无序的
key/value要求的类型:
    key: 必须是可以比较的类型，map,slice,function不能作为key的类型
    value: 任何类型都可以
map不是线程安全的

有序排列:
    附加slice排序key,然后根据key获取value;
map需要初始化之后才能使用:
    golang中使用new初始化struct,如果struct中包含map,new并不能初始化map;
	需要单独初始化map,可以使用构造函数初始化map
```
sync.map
```
type Map struct {
	mu Mutex //互斥量,保护read dirty
	read atomic.Value // atomic.Value的类型,可以并发的读
	dirty map[interface{}]*entry //一个非线程安全的原始map。
	misses int
}
总结:
1. sync.map是线程安全的,读取，插入，删除也都保持着常数级的时间复杂度。
2. 通过读写分离，降低锁时间来提高效率，适用于读多写少的场景。
3. Range 操作需要提供一个函数，参数是 k,v，返回值是一个布尔值：f func(key, value interface{}) bool。
4. 调用 Load 或 LoadOrStore 函数时，如果在 read 中没有找到 key，则会将 misses 值原子地增加 1，
    当 misses 增加到和 dirty 的长度相等时，会将 dirty 提升为 read。以期减少“读 miss”。
5. 新写入的 key 会保存到 dirty 中，如果这时 dirty 为 nil，就会先新创建一个 dirty，并将 read 中未被删除的元素拷贝到 dirty。
6. 当 dirty 为 nil 的时候，read 就代表 map 所有的数据；当 dirty 不为 nil 的时候，dirty 才代表 map 所有的数据
```

#### channel相关
---
channel结构
```
结构:
    type hchan struct {
    qcount   uint           // 队列中数据个数
    dataqsiz uint           // channel 大小
    buf      unsafe.Pointer // 存放数据的环形数组
    elemsize uint16         // channel 中数据类型的大小
    closed   uint32         // 表示 channel 是否关闭
    elemtype *_type // 元素数据类型
    sendx    uint   // send 的数组索引
    recvx    uint   // recv 的数组索引
    recvq    waitq  // 由 recv 行为（也就是 <-ch）阻塞在 channel 上的 goroutine 队列
    sendq    waitq  // 由 send 行为 (也就是 ch<-) 阻塞在 channel 上的 goroutine 队列
    lock mutex
}
使用:
    1. 重复关闭channel会导致panic
    2. 向关闭的channel发送数据会panic
    3. 从关闭的channel读数据不会panic
典型用法:
    1. goroutine通信 goroutine中写入，goroutine外读出
    2. select 一般配合for使用，管理多个channel的读写
    3. range channel 可以直接读取channel的值，当使用range来操作的时候，
       一旦channel关闭,channel内部数据读完之后循环自动结束。
    4. 超时控制
        select {
            case <- ch:
            case <time.After(2):        
        }
    5. 生产者消费者模型
```
channel如何实现消息通知的
```
channel应用场景:
    数据交流:
        当作并发的buffer或者queue,解决生产者消费者问题
        多个goroutine可以并发当作生产者（Producer）和消费者（Consumer）。
    数据传递:
        一个goroutine将数据交给另一个goroutine,相当于把数据的拥有权托付出去。
    信号通知:
        一个goroutine可以将信号(closing，closed，data ready等)传递给另一个或者另一组goroutine。
    任务编排:
        可以让一组goroutine按照一定的顺序并发或者串行的执行，这就是编排功能。
    锁机制:
        利用channel实现互斥机制。
channel注意事项:
    向已经关闭的channel中写入数据会发生Panic
    关闭已经关闭的channel会发生Panic
    关闭值为nil的channel会发生Panic

nil是chan的零值,是一种特殊的 chan,对值是nil的chan的发送接收调用者总是会阻塞。
```

##### interface相关

鸭子类型
```
鸭子类型是动态编程语言的一种对象推断策略,更关注对象如何被使用,而不是对象的类型本身
Go作为静态语言,通过接口的方式完美支持鸭子类型
```
方法
```
拥有接收者的函数就是方法，接收者包含值接收者和指针接收者
在调用方法的时候,值类型可以调用值接收者的方法,也可以调用指针接收者的方法
指针类型可以调用指针接收者的方法，也可以调用值接收者的方法
之所以不必严格按照值接收者和指针接收者来调用,是因为编译器在背后做了一些工作
1. 值类型调用者调用值接收者方法,方法会使用调用者的一个副本，类似于“传值”
2. 值类型调用者调用指针接收者方法,方法会使用值的引用来调用方法 T.Func()实际是(&T).Func()
3. 指针类型调用者调用值接收者方法,方法会使用指针被解引用为值,T.Func()实际是(*T).Func()
4. 指针类型调用者调用指针接收者方法,方法使用穿过来的指针,类似于指针传值
```
值接收者和指针接收者
```
总结:
    实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法;
    实现了接收者是指针类型的方法,不会自动生成对应接收者是值类型的方法
原因:
    接收者是指针类型的方法,很可能在方法中会对接收者的属性进行更改操作,从而影响接收者;
    接收者是值类型的方法,在方法中不会对接收者本身产生影响
    所以当实现了一个接收者是值类型的方法,可以自动生成一个接收者是对应指针类型的方法，
    因为两者都不会影响接收者;
    但是当一个实现接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本既往对接收者
    的改变(通过指针实现),现在无法实现
    总的来说，如果实现了接收者是值类型的方法,会隐含的实现接收者是指针类型的方法
使用场景:
    如果接收者成员都是GO内置类型,可以定义值接收者类型，因为使用它们的时候实际创建了一个header，
    header本身有利于复制；
    如果接收者包含自定义类型,应该使用指针接收者,因为struct不能安全的复制，应该只有一份实体
使用指针接收者的理由:
    1. 方法能够修改接收者指向的值
    2. 避免在每次调用方法时复制该值,在值类型为大型结构体时更高效
```
interface结构
```
interface包含2中底层结构,区别在于iface描述的接口包含方法
eface则是不包含任何方法的空接口
```
iface
```
type iface struct {
	tab  *itab //指向一个itab实体
	data unsafe.Pointer //指向接口具体的值

type itab struct {
	inter  *interfacetype//描述接口的类型
	_type  *_type//描述实体的类型,包括内存的对齐方式,大小等
	link   *itab
	hash   uint32 // copy of _type.hash. Used for type switches.
	bad    bool   // type does not implement interface
	inhash bool   // has this itab been added to hash?
	unused [2]byte
	fun    [1]uintptr //放置和接口方法对于的具体数据的方法地址;
                      //实现接口调用方法的动态分配;一般在每次给接口赋值发生转换时会更新此表
                      //或者直接拿缓存的itab
}
type interfacetype struct {
	typ     _type //描述Go语言中各种数据类型的结构体
	pkgpath name //定义了接口的包名
	mhdr    []imethod //接口所定义的函数列表
}
```
![interface](https://user-images.githubusercontent.com/7698088/56564826-82527600-65e1-11e9-956d-d98a212bc863.png)
```
type eface struct {
    _type *_type //空接口所承载的具体的实体类型
    data  unsafe.Pointer //具体的值
}
type _type struct {
    // 类型大小
	size       uintptr
    ptrdata    uintptr
    // 类型的 hash 值
    hash       uint32
    // 类型的 flag，和反射相关
    tflag      tflag
    // 内存对齐相关
    align      uint8
    fieldalign uint8
    // 类型的编号，有bool, slice, struct 等等等等
	kind       uint8
	alg        *typeAlg
	// gc 相关
	gcdata    *byte
	str       nameOff
	ptrToThis typeOff
}
```
接口的动态类型和动态值
```
定义:
    动态类型值: iface中接口表指针,指向类型信息
    动态值: data数据指针,指向具体的数据
接口值的零值实在动态类型和动态值都为nil,当且仅当两部分的值都为nil的情况下，
    接口值就才会被认为接口值==nil
```
interface比较
```
动态值和动态类型都相等,interface才相等
```
2个nil可能不相等
```
原因:
    接口等于nil,表示其类型T和值V处于unset状态
    两个值比较时会先比较T,在比较V;
例子:
func main() {
	var p *int = nil
	var i interface{} = p
	fmt.Println(i == p) // true
	fmt.Println(p == nil) // true
	fmt.Println(i == nil) // false
}
上面这个例子中,将一个 nil 非接口值 p 赋值给接口 i;
i的内部字段为(T=*int, V=nil)，
i 与 p 作比较时，将 p 转换为接口后再比较，因此 i == p，
p 与 nil 比较，直接比较值，所以 p == nil。
但是当 i 与 nil 比较时，会将 nil 转换为接口 (T=nil, V=nil)，与i (T=*int, V=nil) 不相等，
因此 i != nil。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。
```
如何打印出接口的动态类型和动态值
```
代码里直接定义了一个 iface 结构体,用两个指针来描述 itab 和 data;
之后将 a, b, c 在内存中的内容强制解释成我们自定义的 iface
最后就可以打印出动态类型和动态值的地址。
------------------------------------------------------------
例子:
type iface struct {
	itab, data uintptr
}

func main() {
	var a interface{} = nil
	var b interface{} = (*int)(nil)
	x := 5
	var c interface{} = (*int)(&x)
	ia := *(*iface)(unsafe.Pointer(&a))
	ib := *(*iface)(unsafe.Pointer(&b))
	ic := *(*iface)(unsafe.Pointer(&c))
	fmt.Println(ia, ib, ic)
	fmt.Println(*(*int)(unsafe.Pointer(ic.data)))
}
```
编译器自动检测类型是否实现接口
```
var _ io.Writer = (*myWriter)(nil)
var _ io.Writer = myWriter{}

原理:
    上述赋值语句会发生隐式地类型转换,在转换的过程中,
    编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数
```
类型转换和断言的区别
```
    空接口interface{}没有定义任何函数,因此Go中所有类型都实现了空接口;
    当一个函数的形参是interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。
断言的语法:
    <目标类型的值>,<布尔参数> := <表达式>.(目标类型) //安全断言
    <目标类型的值> := <表达式>.(目标类型) //非安全类型断言
引申1:
    fmt.Println函数的参数是interface;对于内置类型,函数内部会用穷举法,得出它的真实类型,
    然后转换为字符串打印;
    而对于自定义类型,首先确定该类型是否实现了String()方法,如果实现了,则直接打印输出String()方法的结果；
    否则，会通过反射来遍历对象的成员进行打印。
```
接口转换的原理
```
当判定一种类型是否满足某个接口时,Go 使用类型的方法集和接口所需要的方法集进行匹配,
如果类型的方法集完全包含接口的方法集,则可认为该类型实现了该接口。
接口函数进行了排序,提高了比较效率
---------------------------------------------------------------------------
1. 具体类型转空接口时,_type 字段直接复制源类型的 _type;
    调用 mallocgc 获得一块新内存,把值复制进去,data 再指向这块新内存。
2. 具体类型转非空接口时,入参 tab 是编译器在编译阶段预先生成好的,
    新接口 tab 字段直接指向入参 tab 指向的 itab;
    调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。
3. 而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。
```
interface实现多态
```
多态特点:
1. 一种类型具有多种类型的能力
2. 允许不同的对象对同一消息做出灵活的反应
3. 以一种通用的方式对待使用的对象
4. 非动态语言必须通过继承和接口的方式来实现
多态例子:

func main() {
	qcrao := Student{age: 18}
	whatJob(&qcrao)

	growUp(&qcrao)
	fmt.Println(qcrao)

	stefno := Programmer{age: 100}
	whatJob(stefno)

	growUp(stefno)
	fmt.Println(stefno)
}

func whatJob(p Person) {
	p.job()
}

func growUp(p Person) {
	p.growUp()
}

type Person interface {
	job()
	growUp()
}

type Student struct {
	age int
}

func (p Student) job() {
	fmt.Println("I am a student.")
	return
}

func (p *Student) growUp() {
	p.age += 1
	return
}

type Programmer struct {
	age int
}

func (p Programmer) job() {
	fmt.Println("I am a programmer.")
	return
}

func (p Programmer) growUp() {
	// 程序员老得太快 ^_^
	p.age += 10
	return
}
```
Go接口与C++接口的异同
```
侵入式:
    实现类需要明确生命自己实现了某个接口
非侵入式:
    一个类只需要实现了接口要求的所有函数,就实现了该接口
C++定义接口的方式是侵入式，Go采用的是非侵入式
note:
    C++ 和 Go 在定义接口方式上的不同,也导致了底层实现上的不同.
    C++ 通过虚函数表来实现基类调用派生类的函数,而Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数;
    C++ 中的虚函数表是在编译期生成的,而 Go 的itab中的 fun 字段是在运行期间动态生成的
    原因在于,Go 中实体类型可能会无意中实现 N 多接口,很多接口并不是本来需要的,所以不能为类型实现的所有接口都生成一个 itab;
    这也是“非侵入式”带来的影响l
    这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。
```


##### 函数相关

定义
```
函数是唯一一种基于特定输入、实现特定任务并可反馈认为执行结果的代码块
本质上Go程序就是一组函数的集合
一等函数:
    一等函数允许将函数分配给变量(将函数通过变量进行传递),作为参数传递给其他函数
    并从其他函数返回
匿名函数:   
    没有定义函数名字的函数
高阶函数:
    满足至少一项的函数:
    1. 以一个或者多个函数作为参数
    2. 返回一个函数作为其结果
闭包:
    闭包是由函数及其相关引用环境组合而成的实体
    或者说能访问函数主题之外的变量的函数就是闭包
    在Golang中,所有的匿名函数都是闭包
```
#### 反射相关
---
定义
```
在运行时更新变量和检查它们的值、调用它们的方法,但是在编译时并不知道这些变量的具体类型
```
使用场景
```
1. 未知的参数类型,需要使用反射判断类型
2. 需要在运行期间根据函数和函数的参数类型动态的执行函数

```

### 高级

#### GO内存管理相关

内存逃逸
```
逃逸定义:
    程序中每个函数都会分配一个栈帧用来存放自己的局部变量、返回地址,函数运行结束后栈帧销毁；
    但是有些变量在结束后仍会使用,那么就需要将这个变量分配在堆上；
    这种从栈上逃逸到堆上的现象就称为内存逃逸    
由编译器决定:
    编译器通过逃逸分析确定变量是在栈上还是堆上
    当发现变量的作用域没有超出函数范围,就可以在栈上,反之则必须分配在堆上
内存逃逸的五种情况:
    1 发送指针的指针或值包含了指针到channel中,由于在编译阶段无法确定其作用域与传递的路径,所以一般都会逃逸到堆上分配。
    2 slices中的值是指针的指针或包含指针字段。
    3 slice由于append操作超出其容量,因此会导致slice重新分配。
    4 在interface类型上调用方法
        在interface类型上调用方法都是动态调度的;方法的真正实现只能在运行时知道.
	    想象一个io.reader类型变量r,调用r.read(b)会使得r的值和切片b的背后存储都逃逸掉,所以会在堆上分配.
    5 返回局部变量的引用,生命周期大于栈,导致内存逃逸
避免内存逃逸的办法:
    对于小型的数据,使用传值而不是传指针,避免内存逃逸。
    避免使用长度不固定的slice切片,在编译期无法确定切片长度,只能将切片使用堆分配。
    interface调用方法会发生内存逃逸，在热点代码片段，谨慎使用。
逃逸分析:
	go build -gcflags=-m main.go
```
函数返回局部变量的指针是否安全
```
Go中是安全的,Go 编译器将会对每个局部变量进行逃逸分析。
如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上
```
##### 垃圾回收的工作原理
```
golang通过三色标记法加写屏障技术实现垃圾回收

标记清除法:
    定义:
        标记清除收集器是跟踪式垃圾收集器,其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：
        标记阶段:
            从根对象出发查找并标记堆中所有存活的对象；
        清除阶段:
            遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。
        问题:
            是在标记期间,需要暂停程序（Stop the world，STW)
            标记结束之后,用户程序才可以继续执行

    三色标记法:
        将程序中的对象分成白色、黑色和灰色三类:
            白色: 不确定对象
            灰色: 存活对象,子对象待处理
            黑色: 存活对象
        执行流程:
            1 标记开始时所有对象加入白色集合(需要STW).
            2 将根对象标记为灰色,并加入灰色集合
            3 垃圾收集器取出一个灰色对象,并将其标记为黑色,将其指向的对象标记为灰色,加入灰色集合
            4 重复3的过程,直到灰色集合为空,标记阶段结束; 那么白色对象就是需要清理的对象;
              而黑色对象均是根可达的对象,不能清理
        总结:
            从根遍历所有对象,不可达的对象即认为可清理的对象
            因为多了一个白色的状态存放不确定的对象,后续的标记阶段可以并发执行
            并发过程中可能会有遗漏,因为最开始的黑色对象有可能在标记过程中
            就已经不可达了
        问题:
            在 GC 过程中,对象指针会发生了改变,导致不该回收的对象回收了
            使用写屏障技术解决这个问题
            例子:
            A (黑) -> B (灰) -> C (白) -> D (白)
            正常情况下，D 对象最终会被标记为黑色，不应被回收。
            但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，
            而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。
            A (黑) -> B (灰) -> C (白) 
            ↓
            D (白)
    写屏障技术:
            当对象新增或更新时,会将其着色为灰色
            这样即使与用户程序并发执行,对象的引用发生改变时,垃圾收集器也能正确处理了
GC四个阶段：
    1 标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)
    2 使用三色标记法标记（Marking, 并发）
    3 标记结束(Mark Termination，需 STW)，关闭写屏障。
    4 清理(Sweeping, 并发)
```

屏障机制
```
强-弱三色不变式
    强三色不变式: 不存在黑色对象引用到白色对象的指针
    弱三色不变式: 所有被黑色对象引用的白色对象都处于灰色保护状态
插入屏障:
    具体操作: 在A对象引用B对象的时候,B对象被标记为灰色
    满足: 强三色不变式
    缺点: 结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活
删除屏障:
    具体操作: 被删除的对象,如果自身为灰色和白色,那么被标记为灰色
    满足: 弱三色不变式(保护灰色对象到白色对象的路径不会断)
    缺点:
        回收精度低，GC开始时STW扫描堆栈来记录初始快照
        这个过程会保护开始时刻的所有存活对象
不执行STW的话下面2种情况会丢失
条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)
条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)

```

Golang的内存模型中为什么小对象多了会造成GC压力
```
通常小对象过多会导致GC三色法消耗过多的CPU.
优化思路时减少对象分配.
```

golang栈空间管理
```
go 1.3之前:
    使用分段栈, 当栈空间不足的时候,会申请一段新的空间,并通过指针与原本的栈链接
    分段栈的好处:
        可以按需增长，空间利用率比较高
    分段栈的坏处:
        当一个段即将用尽，这时使用for循环执行一个比较耗空间的函数，会导致函数执行时goroutine进行段的分配，
        而执行完成返回时，进行段的销毁，这样就会导致在循环中出现多次栈的扩容和收缩，造成很大的性能损失，
        这种情况被称作栈分裂
1.3及之后:
    使用连续栈
    当栈空间不够时，直接new一个2倍大的栈空间，并将原先栈空间中的数据拷贝到新的栈空间中，而后销毁旧栈
总结:
    相比于分段栈，连续栈避免了某些场景下栈空间的的频繁伸缩。
    有一点需要注意的是，连续栈的收缩也是需要重新申请一段空间（原先的1/2大小），并进行栈拷贝操作的
```

Go的对象在内存中是怎样分配的
```
Go的内存分配原则:
    Go在程序启动的时候,会先向操作系统申请一块内存(注意这时还只是一段虚拟的地址空间,并不会真正地分配内存),切成小块后自己进行管理。
    申请到的内存块被分配了三个区域,在X64上分别是512MB，16GB，512GB大小。
    TODO 待补充
```
栈的内存是怎么分配的
```
栈和堆区别：
    栈在高地址,从高地址向低地址增长。
    堆在低地址,从低地址向高地址增长。
栈和堆相比优势:
    栈的内存管理简单,分配比堆上快。
    栈的内存不需要回收,而堆需要,无论是主动free,还是被动的垃圾回收,这都需要花费额外的CPU。
    栈上的内存有更好的局部性,堆上内存访问就不那么友好了
```
堆内存管理怎么分配的
```
    把使用的内存块从链表中取出来,然后标记为未使用,当分配内存块的时候
    可以从未使用内存块中有先查找大小相近的内存块,如果找不到,再从未分配的内存中分配内存。
想要深入了解可以看下这个文章,《Writing a Memory Allocator》.
    TODO: 待补充
```
在Go函数中为什么会发生内存泄露
```
内存泄漏:
    能够预期的能很快被释放的内存由于附着在了长期存活的内存上或生命期意外地被延长
    导致预计能够立即回收的内存而长时间得不到回收
内存泄露的形式:
    1 预期能被快速释放的内存因被根对象引用而没有得到迅速释放.
    2 当有一个全局对象时,可能不经意间将某个变量附着在其上,且忽略的将其进行释放,
      则该内存永远不会得到释放。
```
GC的触发条件
```
主动触发:
    通过调用runtime.GC来触发GC,此调用阻塞式的等待当前GC运行完毕
被动触发:
    使用监控系统,超过2分钟没有产生任何GC时,强制触发GC
    使用步调算法,核心思想就是控制内存的增长的比例,当前内存分配达到一定比例则触发
toDO: 什么时步调算法
```

golang中堆和栈的区别
```
如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销
```

#### GO调度相关

goroutine泄漏
```
定义:
    Goroutine作为一种逻辑上理解的轻量级线程,需要维护执行用户代码的上下文信息
    在运行过程中也需要消耗一定的内存来保存这类信息,而这些内存在目前版本的Go中是不会被释放的。
    如果一个程序持续不断地产生新的 goroutine且不结束已经创建的goroutine并复用这部分内存
    就会造成内存泄漏的现象.
```

G0的作用
```
g0作为一个特殊的goroutine,为scheduler执行调度循环提供了场地(栈)
对于一个线程来说,g0总是它第一个创建的goroutine
之后,它会不断地寻找其他普通的goroutine来执行,直到进程退出。
当需要执行一些任务,且不想扩栈时,就可以用到 g0了,因为 g0 的栈比较大。
g0 其他的一些“职责”有:
    创建 goroutine
    deferproc 函数里新建 _defer
    垃圾回收相关的工作（例如 stw、扫描 goroutine 的执行栈、一些标识清扫的工作、栈增长）等等。
```
GO的GMP如何调度
```
G: goroutine协程
M:  thread线程
P: processor处理器,包含了运行goroutine的资源及可运行的G队列
全局队列: 
    存放等待运行的G
P的本地队列: 
    同全局队列类似,存放的也是等待运行的G,不超过256个
P列表:
    所有的P都在程序启动时创建,并保存在数组中,最多有GOMAXPROCS个
M: 线程想运行任务就要获得P,从P的本地队列获取G,P队列为空时,M也会
   尝试从全局队列拿一批G放到P的本地队列,或者从其他P的本地队列偷一半
   放到自己的P的本地队列,M运行G,G执行后,M从P获取下一个G,不断重复
数量问题:
    P 的数量由环境变量GOMAXPROCS或者runtime的方法GOMAXPROCS()决定
    M 的数量:
     go程序启动时设置最大数量,默认1000,但是内核很难支持这么多,可以忽略
     runtime/debug中的SetMaxThreads函数,设置M的最大数量
     一个M阻塞了,会创建新的M
何时创建:
    P: 在确定了P的最大数量n后,运行时系统会根据这个数量创建n个P
    M: 没有足够的M来关联P并运行其中的可运行的G
调度器的设计策略:
    复用线程: 避免频繁创建 销毁线程,而是对线程的复用
        work stealing机制: 当本线程无可运行的G时,尝试从其他线程绑定的P偷取G,而不是销毁线程
        hand off机制: 当本线程因为G进行系统调用阻塞时,线程释放绑定的P,把P转移给其他的空闲线程执行
    利用并行:
          充分利用CPU核数
    全局G队列:
        当M无法从其他P偷取G时,可以从全局队列获取G
调度流程:
    1 通过go func创建一个goroutine
    2 G 会先保存在P的本地队列,如果P的本地队列满了,会保存在全局队列
    3 判断空闲的M是否存在,不存在创建; M会从绑定的P获取G来执行,如果
      P的本地队列为空,就会从其他MP组合偷取G;如果偷取不到,会从全局队列
      获取G
    4 一个M调度G执行的过程是一个循环机制
    5 当M执行某一个G阻塞时,runtime会把这个M从P摘除,创建一个新的线程或者复用
      空闲线程服务P
M0:
    启动程序后编号为0的主线程,对于全局变量runtime.m0,不需要再heap上分配;
    负责执行初始化操作核启动第一个G,在之后M0就和其他的M一样了
G0:
    每次启动一个M都会第一个创建的goroutine,Go仅负责调度,不执行函数;
    每个M都有自己的G0
可视化GMP编程:
    go tool bin bin.out
```

#### GO并发相关

#### goroutine相关

#### 协程泄漏问题
```
协程泄露是指协程创建后,长时间得不到释放,并且还在不断地创建新的协程,最终导致内存耗尽,程序崩溃。
原因:
    1 缺少接收器，导致发送阻塞
    2 死锁
    3 无限死循环
造成的后果:
    1 CPU 使用率浮动上涨
    2 内存占用不断上涨
    3 主进程崩溃
```
死锁的理解
```
```
限制goroutine数量的手段
```
1. 通过channel限制
    设置带缓存的channel,缓存满了的时候阻塞主goroutine
    同时在子goroutine执行完成时释放channel缓存
2. 使用sync同步机制
    使用sync.group设置goroutine数量,子goroutine执行完成后是否数量
    单纯的使用sync.group无法限制,因为创建goroutine的速度大于释放
    goroutine的速度,依然会导致goroutine泄漏
3.  channel和sync一起使用
4.  利用无缓冲的channel与认为发送/执行分离模式
    实际就是主goroutine使用sync同步,使用channel作为消息队列进行同步
总结:
    总的来说还是使用channel来限制goroutine的创建,避免goroutine无限创建
```
goroutine退出
```
1. 正常goroutine执行完成就会退出
2. 阻塞的goroutine会一直不退出,可以解除阻塞使其退出
   如关闭channel，信号量通知等
3. 可以设置定时器,超时即退出
4. context也可以超时退出
```

select相关
```
执行原理:
    1. 每一个case对应的channel都会被封装到一个结构体中
    2. 首次执行select时,会锁住channel,打乱case结构体的顺序
    3. 监听信号,就绪时执行对应的case,之后跳出select
    4. 没有就绪的代码段,但是有default时,执行default代码段,之后跳出select
    5. 没有default,将当前goroutine加入所有channel对应等待队列
    6. 当某个等待队列就绪时,再次锁住所有channel
```
Context相关
```
Context 使用原则:
    1 不要把Context放在结构体中,要以参数的方式传递。
    2 以Context作为参数的函数方法,应该把Context作为第一个参数,放在第一位。
    3 给一个函数方法传递Context的时候,不要传递nil,默认使用context.TODO。
    4 Context的Value相关方法应该传递必须的数据,不要什么数据都使用这个传递。
    5 Context是线程安全的，可以放心的在多个goroutine中传递。
note:
    Context中的方法是协程安全的,所以在父routine中创建的context
    可以传递给任意数量的routine并让他们同时访问。
Context中的方法:
    Done:
        会返回一个channel,当该context被取消的时候,该channel会被关闭,
        同时对应的使用该context的routine也应该结束并返回
    Deadline:
        会返回一个超时时间,routine获得了超时时间后,可以对某些io操作设定超时时间。
```
sync.WaitGroup相关
```
WaitGroup用来等待一组操作完成的,WaitGroup内部实现了一个计数器,用来记录未完成的操作个数.
它提供了三个方法:
    Add()用来添加计数,Done()用来在操作结束时调用使计数减一
    Wait()用来等待所有的操作结束即计数变为0,该函数会在计数不为0时等待
    在计数为0时立即返回。
```
CAS相关
```
CAS算法(Compare And Swap),是原子操作的一种,CAS算法是一种有名的无锁算法
无锁编程:
    即不使用锁的情况下实现多线程之间的变量同步,也叫非阻塞同步(Non-blocking Synchronization)。
    可用于在多线程编程中实现不被打断的数据交换操作,从而避免多线程同时改写某一数据时由于
    执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。
    该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。
Go中的CAS操作:
    借用CPU提供的原子性指令来实现
    CAS操作修改共享变量时候不需要对共享变量加锁,
    而是通过类似乐观锁的方式进行检查,
    本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）。
```

#### GO优化
##### pprof

### 其他面试题




##### 相关
rune类型
```
    unicode在golang中的类型,是int32类型的别名,包含世界上书写系统总存在
    的所有字符的标准编号
    GO语言中,字符串底层表示是byte(8 bit)序列,而非rune(32 bit)序列
```
make和new的区别
```
1. make 只用于slice,map,channel，返回的是初始化之后的T类型的值，
    这个值是经过初始化之后的T的引用，作为函数传参之后在函数内部修改
    将影响函数外部的值;
2. new返回的T的指针*T并指向T的零值
```
defer,recover和panic
```
defer:
    1. 在defer表达式确定的时候,defer修饰的函数（defered函数）的参数也就确定了
    2. 函数内可以有多个defered函数,但是这些defered函数在返回时遵守先进后厨的原则
    3. 函数命名的返回值跟deferd函数一起使用
    note:
    1. 函数renturn前,会按照先进后出的顺序执行
    2. defer函数定义时,对外部变量的引用有2种方式,分别时函数参数和作为闭包引用
       函数参数时,则在defer定义时就把值传递给defer,并缓存起来
        因此如果时“值”,那么和定义的时候一致,如果是引用,那么就可能和定义的时候不一致
       闭包引用时,则会在defer函数真正调用时根据整个上下文确定当前的值
       
panic:
    panic其实就是c++中的throw exception
    panic是内建函数,会中断函数f的正常执行流程,从函数f中跳出来,跳回到函数f的使用者
    对于调用者来说,f看起来就是一个panic,所以调用者会继续向上跳出，知道当前goroutine返回
    在跳出的过程中,进程会保持这个函数栈，当goroutine退出时，程序会crash
recover:
    recover就是c++中的catch
    1. recover如果想起作用的话，就必须在defered函数中使用
    2. 在正常函数执行过程中,调用revocer没有任何作用
    3. 如果当前的goroutine panic了，那么recover将会捕获这个panic的值
        并让程序正常执行下去,不会让程序crash。
TODO: recover需要练习下
```

进程,线程,协程的异同
```
进程: 
    分配资源的最小单位,可执行程序运行中形成的一个独立的内存体

线程:
    系统调度的最小单位,每个线程拥有各自的栈空间,其他的与内存空间一起共享
协程:
    用户态的轻量级线程,调度完全由用户控制.
    协程拥有自己的寄存器上下文和栈

协程切换成本：
    保存当前cpu寄存器的状态,加载需要切换的协程的CPU寄存器状态,完全在用户态进行
    一般来说一次协程上下文切换最多就是几十ns这个量级。
线程切换成本：
   1. 需要从用户态切换到内核态才能进行线程切换
   2. 除了CPU上下文,还需要保存切换线程私有的栈和寄存器

协程切换比线程切换快主要有两点：
 1 协程切换完全在用户空间进行;线程切换涉及特权模式切换，需要在内核空间完成；
 2 协程切换相比线程切换做的事情更少;线程需要有内核和用户态的切换,系统调用过程。
```
Goroutine和线程的区别
```
1 从调度上看,goroutine的调度开销远远小于线程调度开销。
    OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。
    这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，
    再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：
    即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。
    某种意义上，这种操作还是很慢的。
    Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，
    m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，
    而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。
2 从栈空间上，goroutine的栈空间更加动态灵活。
    每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。
    这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB,
    在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000=200MB）。
    而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB。
3 goroutine没有一个特定的标识。
    在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，
    本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰。
    goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，
    即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。
```

变量的重声明
```
定义:
 已经声明的变量再次被声明赋值
前提:
    1、 变量再次声明时必须与其原本的类型相同,否则会产生编译错误
    2、 变量的重声明只能发生在某一个代码块中。
    3、 变量的重声明只有在使用短变量声明时才会发生,否则无法通过编译
    4、 被"声明并赋值"的变量必须时多个,且至少有一个是新变量，
        这时我们才可以说对其中的旧变量进行了重声明
```
类型转换
```
整数类型转换:
    小范围向大范围的数值可以正常转换;
    大范围向小范围的数值转换时,
    只需要在补码形式下截掉一定数量的高位二进制数即可
浮点型转整型:
    当把一个浮点型转为整型时,前者的小数部分会被全部截掉
整数转string类型:
    被转换的整数值应该可以代表一个有效的 Unicode 代码点，
    否则转换的结果将会是"�"（仅由高亮的问号组成的字符串值）
```
高效的拼接字符串
```
    Go语言中,字符串是只读的,也意味着每次修改操作都会创建一个新的字符串,
    如果需要拼接多次,应使用strings.Builder，最小化内存拷贝次数
```

GO支持默认参数或者可选参数吗
```
可选参数:
    参数可以是非必须的,可以指定传递非必须的参数
Go语言不支持可选参数,也不支持方法重载
```
go语言tag的用处
```
    tag是struct的一部分,主要用于反射场景; 
    反射包中拥有tag的处理方式
```
字符串切片相等判断
```
    1 使用reflect.DeepEqual(a,b)判断  影响性能(需要进行反射判断)
    2 使用遍历的方式比较
```
空strct{}的用途
```
1 空结构体也是结构体,只是 size 为0的类型而已；
2 所有的空结构体都有一个共同的地址：zerobase 的地址；
3 空结构体可以作为 receiver,receiver是空结构体作为值的时候，
  编译器其实直接忽略了第一个参数的传递，编译器在编译期间就能确认生成对应的代码；
4 map 和 struct{} 结合使用常常用来节省一点点内存，使用的场景一般用来判断 key 存在于 map；
5 chan 和 struct{} 结合使用是一般用于信号同步的场景，用意并不是节省内存，而是我们真的并不关心 chan 元素的值；
6 slice 和 struct{} 结合好像真的没啥用
总结: struct{}就是一个标志
```
go程序运行顺序
```
1 初始化导入的包,按照依赖顺序初始化,优先初始化没有依赖的包
2 初始化常量
3 初始化变量
4 init函数 
  不同文件中的 init方法的执行按照文件名先后执行各个文件中的 init 方法
  同一个文件中的多个init方法,按照在代码中编写的顺序依次执行不同的 init 方法
5 main函数
一句话总结: import->const->var->init()->main()
```
golang使用类型推断有什么好处
```
go语言的类型推断可以明显提升程序的灵活性,使得代码重构变得更加容易,
同时又不会给代码维护带来额外负担，也不会损失程序运行的效率
note: 类型推断可以单独修改定义的部分，其他由编译器推断，不用每个地方都修改
```

字符串转成byte数组，会发生内存拷贝吗？
```
字符串转成切片会发生拷贝;严格的说,只要发生类型的强转都会发生内存拷贝;
有什么办法可以不拷贝吗?
1. unsafe.Pointer(&a) 方法可以得到变量a的地址。
2. (*reflect.StringHeader)(unsafe.Pointer(&a)) 可以把字符串a转成底层结构的形式。
3. (*[]byte)(unsafe.Pointer(&ssh)) 可以把ssh底层结构体转成byte的切⽚的指针。
4. 再通过  * 转为指针指向的实际内容。
```
struct能不能比较
```
因为是强类型语言，所以不同类型的结构不能作比较，
但是同一类型的实例值是可以比较的，实例不可以比较，因为是指针类型
```


明白channel是通过注册相关goroutine id实现消息通知的。


为什么Go Scheduler需要实现M:N的方案
```
    1 创建线程开销大,需要提高效率减少线程的创建
    2 减少GO垃圾回收的复杂度
```
GMP调度模型
```
    在Go中,线程是运行goroutine的实体,调度器的功能是把可运行的的goroutine分配到工作线程上
定义:
    全局队列: 
        存放等待运行的G
    P的本地队列:
        存放等待运行的G,存的数量有限,不超过 256 个
        新建 G’时,G’优先加入到 P 的本地队列,如果队列满了,则会把本地队列中一半的G移动到全局队列 
    P:
        调度器的核心处理器,通常表示执行上下文,用于匹配M和G.
        P的数量不能超过GOMAXPROCS配置数量;通常一个P可以与多个M对应,
        但是同一刻P只能与一个M发生绑定关系;M创建后需要自行在P的free list找到P进行绑定;
        没有绑定P的M会进入阻塞态
    M: 
        就是OS线程本身,数量可配置
    G:
        Goroutine,go的用户线程,即协程,真正携带代码执行逻辑的部分;由go func(){...}直接生成
    G0: 比较特殊的G,主要用于调度G
        有1/61的机会从全局队列获取G,其他时间从其他本地队列回去G

    本地队列:
        本地时相对P而言的本地,每个P维护一个本地队列
        生成的G一般会放到P的本地队列,只有本地队列满了的时候,
        才会截取本地队列的一半放入全局队列
    全局队列:
        承载本地队列溢出的G,为了保证调度的公平性,schedule过程中有1/61的几率优先检查全局队列
        否则本地队列一直满载的情况下,全局队列中的G将永远无法被调度到
    窃取(stealing):
        随机从其他P的本地队列窃取一半的G
    线程自旋:
        线程自旋是相对于线程阻塞而言的;一直循环获取G,避免了M的上下文切换
        自旋的线程不会超过GOMAXPROCS,因为一个P在同一时刻只能绑定一个M,
        P的数量不好超过GOMAXPROCS
调度流程:
    1 1/61的几率在全局队列中找G,60/61的几率在本地队列找G;
    2 如果在全局队列找不到G,从P的本地队列找G
    3 如果找不到,从其他P的本地队列中窃取G
    4 如果找不到,则从全局队列中拿取一部分G到本地队列,数量需要满足公式:
        n = min(len(GQ)/GOMAXPROCS+1,len(GQ/2))
    5 如果找不到,从网络中poll G 
    6 只要找到G,就会立马丢给M执行
go func调用:
    1 通过go func()创建一个goroutine
    2 新建的G优先保存在P的本地队列,如果本地队列满了,就保存在全局的队列中
    3 M会从P的本地队列获取一个可执行状态的G执行,如果本地为空,1/61的概率从
        全局队列获取,其他情况从其他MP获取
    4 M循环调度G
    5 如果M发生syscall或其余阻塞操作,M会阻塞;
        如果还有G执行,runtime会把这个线程M从P中摘除,然后创建一个新的操作系统的线程
        来服务这个P
    6  M调用结束,G会尝试获取一个空闲的P执行,并放入这个P的本地队列;
        如果获取不到,M会变成休眠状态,加入到空闲线程中,然后这个G被放入全局队列
------------------------------------------------------------------------------------------------------------
 Goroutine调度器和OS调度器是通过M结合起来的,每个M都代表了1个内核线程,OS 调度器负责把内核线程分配到 CPU 的核上执行 
 
 P和M的数量问题:
    P的数量由GOMAXPROCS或者runtime调用GOMAXPROCS()决定
    M的数量默认1000,但是一般达不到; 可以通过runtime/debug中的SetMaxThreads函数设置最大数量;
        一个M阻塞了会创建新的M
P和M何时被创建:
    确定了P的最大数量后系统就会根据P的数量创建
    没有足够的M来关联P并运行其中的可运行的G的时候创建
调度器设计策略:
    线程复用: 避免频繁的创建销毁线程
        1 work Stealing机制: 本线程无G可用时,尝试从其他线程绑定的P偷取线程
        2 hand off机制 本线程因为G进行系统调用阻塞时,线程释放绑定的P,把P转移给其他空闲的线程执行
    利用并行: 可用使用GoMAXPROCS设置P的数量
    抢占: 
        一个goroution最多占用CPU10ms,防止其他goroutuin被饿死
        协调式是指goroutine执行完才能被其他使用
    全局G队列: 只有在M从其他P偷不到G的时候才会从全局获取G
M0和G0:
    M0是启动程序后的编号为0的主线程,这个M对应的实例会在全局变量 runtime.m0 中,不需要在 heap 上分配,M0 负责执行初始化操作和启动第一个 G,
    在之后 M0 就和其他的 M 一样了
    G0是每次启动一个M都会第一个创建的goroutine,G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，
    每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0
GMP场景:
    场景一:
        P创建G后优先加入本地队列(局部性原理)
    场景二:
        G1完成后,M运行的goroutine切换为G0,G0负责调度协程的切换;
        从本地队列获取G2,从G0切换到G2并执行,实现M的复用
    场景三:
        本地队列满了后本地队列的一半转移到全局队列,并且新创建的G转移到全局队列
    场景四:
        创建G时,运行的G会尝试唤醒其他空闲的P和M组合执行
    场景五:
        本地没有G的话,从全局队列取一批G放到本地队列
        取的数量是n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))
        至少取一个,从全局队列到P本地队列的负载均衡
    场景六:
        本地和全局队列都没有G,从其他有G的P偷一半过来
    场景七:
        本地队列为空,全局队列为空,M陷入自旋状态
    
```

抢占式goroutine
```
 协作式调度依靠被调度方主动弃权
 抢占式调度则依靠调度器强制将被调度方被动中断
```
golang的内存模型
```
内存一致模型:
    或称内存模型,是一份语言用户与语言自身,语言自身与所在的操作系统平台,所在操作系统平台与硬件平台之间的契约;
    它定义了并行状态下拥有确定读取和写入的时序的条件.并回答了一个共享变量是否具有足够的同步机制来保障
    一个线程的写入能否发生在另一个线程的读取之前这个问题
Go语言的内存模型规定了一个goroutine可以看到另外一个goroutine修改同一个变量的值的条件
为了保证多goroutine下读取共享数据的正确性，go中引入happens before原则，即在go程序中定义了多个内存操作执行的一种偏序关系。如果操作e1先于e2发生，我们说e2 happens after e1,如果e1操作既不先于e2发生又不晚于e2发生，我们说e1操作与e2操作并发发生

```
并发就是可同时发起执行的程序，指程序的逻辑结构；并行就是可以在支持并行的硬件上执行的并发程序，指程序的运⾏状态

并发级别
阻塞：阻塞是指一个线程进入临界区后，其它线程就必须在临界区外等待，待进去的线程执行完任务离开临界区后，其它线程才能再进去。

无饥饿：线程排队先来后到，不管优先级大小，先来先执行，就不会产生饥饿等待资源，也即公平锁；相反非公平锁则是根据优先级来执行，有可能排在前面的低优先级线程被后面的高优先级线程插队，就形成饥饿

无障碍：共享资源不加锁，每个线程都可以自有读写，单监测到被其他线程修改过则回滚操作，重试直到单独操作成功；风险就是如果多个线程发现彼此修改了，所有线程都需要回滚，就会导致死循环的回滚中，造成死锁

无锁：无锁是无障碍的加强版，无锁级别保证至少有一个线程在有限操作步骤内成功退出，不管是否修改成功，这样保证了多个线程回滚不至于导致死循环

无等待：无等待是无锁的升级版，并发编程的最高境界，无锁只保证有线程能成功退出，但存在低级别的线程一直处于饥饿状态，无等待则要求所有线程必须在有限步骤内完成退出，让低级别的线程有机会执行，从而保证所有线程都能运行，提高并发度。


make new的区别
```
new(T) 返回 T 的指针 *T 并指向 T 的零值。
make(T) 返回的初始化的 T，只能用于 slice，map，channel。
```

golang面试题：字符串转成byte数组，会发生内存拷贝吗？
```
只要是发生类型强转都会发生内存拷贝
```


golang面试题：翻转含有中文、数字、英文字母的字符串
```
rune关键字，从golang源码中看出，它是int32的别名（-2^31 ~ 2^31-1），比起byte（-128～127），可表示更多的字符。
由于rune可表示的范围更大，所以能处理一切字符，当然也包括中文字符。在平时计算中文字符，可用rune。
因此将字符串转为rune的切片，再进行翻转，完美解决
```

golang面试题：拷贝大切片一定比小切片代价大吗？
```
并不是，所有切片的大小相同；三个字段（一个 uintptr，两个int）。切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以 拷贝大切片跟小切片的代价应该是一样的。
```
map不初始化使用会怎么样
```
读返回空,写崩溃
```
map不初始化长度和初始化长度的区别
```

```
字符串不能改，那转成数组能改吗，怎么改
```
Go 语言的字符串是不可变的。
修改字符串时，可以将字符串转换为 []byte 进行修改。
[]byte 和 string 可以通过强制类型转换互转。
```
普通map如何不用锁解决协程安全问题
```
使用sync.map
```

slice深拷贝和浅拷贝
```
浅拷贝#
目的切片和源切片指向同一个底层数组，任何一个数组元素改变，都会同时影响两个数组。
深拷贝
目的切片和源切片指向不同的底层数组，任何一个数组元素改变都不影响另外一个。

主要看是否重新分配内存
```

内存碎片化问题
chan相关的goroutine泄露的问题
string相关的goroutine泄露的问题
你一定会遇到的内存回收策略导致的疑似内存泄漏的问题
sync.Pool的适用场景
go1.13sync.Pool对比go1.12版本优化点
并发编程
sync.map 的优缺点和使用场景
sync.Map的优化点
golang面试题：能说说uintptr和unsafe.Pointer的区别吗？
golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？
协程和线程的差别
什么是写屏障、混合写屏障，如何实现？
开多个线程和开多个协程会有什么区别
两个interface{} 能不能比较
必须要手动对齐内存的情况
go栈扩容和栈缩容，连续栈的缺点
golang怎么做代码优化
golang隐藏技能:怎么访问私有成员
3. 说说go语言中，数组与切片的区别？
(1). 数组 数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列。 数组的长度是数组类型的一部分，所以[3]int 和 [4]int 是两种不同的数组类型。

协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。
  昨天那个在for循环里append元素的同事，今天还在么？
golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？ 答案
连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。 答案
golang面试题：字符串转成byte数组，会发生内存拷贝吗？答案
golang面试题：翻转含有中文、数字、英文字母的字符串。答案
golang面试题：拷贝大切片一定比小切片代价大吗？ 答案
对未初始化的的chan进行读写，会怎么样？为什么？答案
map不初始化使用会怎么样 答案
map不初始化长度和初始化长度的区别
map承载多大，大了怎么办
map的iterator是否安全？能不能一边delete一边遍历？
字符串不能改，那转成数组能改吗，怎么改  答案
怎么判断一个数组是否已经排序  答案
普通map如何不用锁解决协程安全问题
array和slice的区别
golang面试题：json包变量不加tag会怎么样？答案
零切片、空切片、nil切片是什么
slice深拷贝和浅拷贝 答案
map触发扩容的时机，满足什么条件时扩容？
map扩容策略是什么
自定义类型切片转字节切片和字节切片转回自动以类型切片
make和new什么区别 答案
slice ，map，chanel创建的时候的几个参数什么含义
线程安全的map怎么实现
1、在进行项目开发时，遇到的关于golang的问题有哪些？
可简单描述工作中用到的东西，协程，通道，框架、加密等等，说一些关键的技术点

2、golang中关于grpc和rest都使用过吗？grpc相对于rest的优势是什么？为什么选择groc？
两种API架构概述

grpc：gRPC是RPC框架中的一种，RPC(remote procedure call 远程过程调用)框架目标就是让远程服务调用更加简单、透明。RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。RPC是一种设计理念，而gRPC是基于此种设计理念设计的真实框架。
rest：描述的是在网络中client和server的一种交互形式；一个架构样式的网络系统，指的是一组架构约束条件和原则。
grpc相对于rest的优势

gRPC 对接口有严格的约束条件，安全性更高，对于高并发的场景更适用

为什么选择grpc

grpc有明确的接口规范和对于流的支持；
RPC 效率更高。RPC使用自定义的 TCP 协议，可以让请求报文体积更小，或者使用 HTTP2 协议，也可以很好的减少报文的体积，提高传输效率。
3、golang里面常用到的技术栈有哪些？
协程、通道、web框架、密码学等

4、gin框架的好处是什么？
快速：基于Radix树的路由,性能非常强大。
支持中间件：内置许多中间件，如Logger,Gzip,Authorization等。
崩溃恢复：可以捕捉panic引发的程序崩溃，使Web服务可以一直运行。
JSON验证：可以验证请求中JSON数据格式。
多种数据渲染方式：支持HTML、JSON、YAML、XML等数据格式的响应。
扩展性：非常简单扩展中间件。
5、无缓冲通道和缓冲通道的区别是什么？
无缓冲通道，在通道满了之后就会阻塞所在的goroutine。（需要在其他goroutine中取出该通道中的元素，才能解除它所在通道的阻塞，不然就会一直阻塞下去。）
缓冲通道，存完了东西可以不取出来，不会阻塞;
缓冲通道相较于无缓冲区的通道在用法上是要灵活一些的，不会出现一次写入，一次读完就会堵塞。
6 、select的用处是什么？
过select可以监听channel上的数据流动。
select的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。

示例代码如下:

select {
    case <-chan1:
        // 如果chan1成功读到数据，则进行该case处理语句
    case chan2 <- 1:
        // 如果成功向chan2写入数据，则进行该case处理语句
    default:
        // 如果上面都没有成功，则进入default处理流程
}
7、defer的用途和使用场景是什么？
defer作用：可用于捕获程序异常，在某个方法中，出现异常时，defer可捕获此异常并进行打印，使用关键字defer向函数声明退出调用，即主函数退出时，defer后的函数才被调用。defer语句的作用是不管程序是否出现异常，均在函数退出时自动执行相关代码。
8、defer的执行顺序是什么？
defer语句并不会马上执行，而是会进入一个栈，函数return前，会按先进后出的顺序执行。也说是说最先被定义的defer语句最后执行。
注：先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有

9、defer函数遇到return以后是怎么执行的？
先defer再return，函数执行之后，return返回之前，按照先进后出的顺序执行

10、对于进程，线程，协程的理解是什么？
线程可以理解为轻量级的进程 协程可以理解为轻量级的线程
协程最大的优势就是可以轻松的创建上百万个，而不会导致系统资源衰减
详解请参考： 进程、线程、协程

11、有时候会遇到一些空的结构体，这个目的是什么？
空结构体不占任何内存，使用空结构体，可以帮咱们节省内存空间，提升性能golang

12、map怎么顺序读取？
map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把key变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。


14、如果用range修改切片元素的值，会发生什么？
我们经常会使用到range来帮助我们遍历一些数据，通常情况下都是查看操作多一些，但是当我们需要对其原地址上的内容进行变更时，通常都是使用 ==for i:=0; i<len(); i++== 来修改值。在使用range的时候，通常会将该数据结构进行拷贝，来遍历这一份拷贝后的副本，使用的是一个值传递，如果我们进行修改，修改的就只是副本，对原地址上的值不会产生任何影响。

15、了解空指针吗？
当一个指针被定义后没有分配到任何变量时，它的值为 nil。
nil 指针也称为空指针。
nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。
16、怎么用go去实现一个set
Go中是不提供Set类型的，Set是一个集合，其本质就是一个List，只是List里的元素不能重复。
Go提供了map类型，可是咱们知道，map类型的key是不能重复的，所以，咱们能够利用这一点，来实现一个set
构造一个Set的方法
构造一个set，首先定义set的类型svg

//set类型
type Set struct {
    m map[int]Empty
}
为一个结构体类型，内部一个成员为一个map，这也是主要咱们存储值的容器函数产生set的工厂性能

//返回一19et
func SetFactory() *Set{
    return &Set{
        m:map[int]Empty{},#### 。所谓并发编程是指在一台处理器上“同时”处理多个任务。
}
}
17、一般怎么比较两个结构体，怎么判断他们是否相等？
一般没有效率太高的方法：

if判断比较：使用if一个个比较两个结构体中元素的值：if(p1->age==p2->age)，如果有一个元素不等，即是两个实例不相等。
指针直接比较：如果保存的是同一个实例地址，则(p1==p2)为真。
18、make和new的区别是什么？
make 只用于 chan，map，slice 的初始化；
new 用于给类型分配内存空间，并且置零；
make 返回类型本身，new 返回指向类型的指针。
19、说一下你对并发编程的理解？
所谓并发编程是指在一台处理器上“同时”处理多个任务。
宏观的并发是指在一段时间内，有多个程序在同时运行。
并发在微观上，是指在同一时刻只能有一条指令执行，但多个程序指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个程序快速交替的执行。
20、碰到过分布式锁的问题吗？分布式锁的原理你清楚吗？
golang中的分布式锁可使用etcd进行实现，实现原理如下：

在ectd系统里创建一个key
如果创建失败，key存在，则监听该key的变化事件，直到该key被删除，回到1
如果创建成功，则认为我获得了锁

https://go-interview.iswbm.com/
https://learnku.com/articles/30718


待验证:
map的value本身是不可寻址的，因为map中的值会在内存中移动，并且旧的指针地址在
map改变时会变得⽆效。故如果需要修改map值，可以将 map 中的⾮指针类型
value ，修改为指针类型，⽐如使⽤ map[string]*Student .

golang 的  for ... range 语法中， stu 变量会被复⽤，每次循环会将集合中的值复制
给这个变量，因此，会导致最后 m 中的 map 中储存的都是 stus 最后⼀个 student
golang 语⾔中没有继承概念，只有组合，也没有虚⽅
法，更没有重载。
defer 在定义的时候会计算好调⽤函数的参数

如果理解struct实现interface?

对已经关闭的的 chan 进⾏读写，会怎么样？为什么？
```
读已关闭的chan能一直读到东西,但是读到的内容根据通道内关闭前是否有内容而不同
	如果chan关闭前,buff内有元素还未读,会正确读到chan内的值,且返回的第二个值(是否读成功)为true
	如果chan关闭前,buff内所有元素已经呗读完,chan内无值,接下来所有的接收的值都会非阻塞直接成功,返回channel元素的零值,
	但是第二个bool值一直为false
写已经关闭的chan会panic,因为包里面会校验,不允许写已经关闭的chan
```
知道golang的内存逃逸吗？什么情况下会发内存逃逸？
```
内存逃逸:
	golang程序变量会携带有一组校验数据，来证明它的整个⽣命周期是否在运行时完全可知。
	如果变量通过了这些校验，它就可以在栈上分配。否则就说它逃逸 了，必须在堆上分配。
引起内存逃逸的情况:
	1 在方法内把局部变量指针返回;局部变量原本应该在栈中分配,在栈中回收.但是由于返回是被外部引用,因此其
	生命周期大于栈,则溢出
	2 发送指针或带有指针的值到channel中. 在编译时,是没有办法知道变量什么时候才会被释放.
	3 在一个切片上存储指针或带指针的值.  一个典型的例子就是[]*string. 这会导致切片的内容逃逸.
	  尽管其后面的数组可能是在栈上分配的,但其引用的值一定是在堆上
	4 slice 的背后数组被重新分配了. 因为append时可能会超出其容量(cap). slice初始化的地方在编译时是可以知道的,
	  它最开始会在栈上分配.如果切片背后的存储要基于运行时的数据进行扩充,就会在堆上分配.
	5 在interface类型上调用方法. 在interface类型上调用方法都是动态调度的;方法的真正实现只能在运行时知道.
	  想象一个io.reader类型变量r,调用r.read(b)会使得r的值和切片b的背后存储都逃逸掉,所以会在堆上分配.
逃逸分析:
	go build -gcflags=-m main.go
```
golang中堆和栈的区别
```
如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销
```
字符串转成byte数组，会发生内存拷贝吗？
```
字符串转成切片会发生拷贝;严格的说,只要发生类型的强转都会发生内存拷贝;
有什么办法可以不拷贝吗?
1. unsafe.Pointer(&a) 方法可以得到变量a的地址。
2. (*reflect.StringHeader)(unsafe.Pointer(&a)) 可以把字符串a转成底层结构的形式。
3. (*[]byte)(unsafe.Pointer(&ssh)) 可以把ssh底层结构体转成byte的切⽚的指针。
4. 再通过  * 转为指针指向的实际内容。
```
Golang面试问题汇总:

1. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？
Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。

2. 无缓冲 Chan 的发送和接收是否同步?
channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。
channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。
4. Golang 中常用的并发模型？
Golang 中常用的并发模型有三种:

通过channel通知实现并发控制
无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。

从上面无缓冲的通道定义来看，发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同步通道。

当主 goroutine 运行到 <-ch 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制

通过sync包中的WaitGroup实现并发控制
Goroutine是异步执行的，有的时候为了防止在结束mian函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成。在WaitGroup里主要有三个方法:

Add, 可以添加或减少 goroutine的数量.
Done, 相当于Add(-1).
Wait, 执行后会堵塞主线程，直到WaitGroup 里的值减至0.
在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。 在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回返回。

在Golang官网中对于WaitGroup介绍是A WaitGroup must not be copied after first use,在 WaitGroup 第一次使用后，不能被拷贝

应用示例:

运行:

它提示所有的 goroutine 都已经睡眠了，出现了死锁。这是因为 wg 给拷贝传递到了 goroutine 中，导致只有 Add 操作，其实 Done操作是在 wg 的副本执行的。

因此 Wait 就死锁了。

这个第一个修改方式:将匿名函数中 wg 的传入类型改为 *sync.WaitGrou,这样就能引用到正确的WaitGroup了。 这个第二个修改方式:将匿名函数中的 wg 的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面的 wg 变量

在Go 1.7 以后引进的强大的Context上下文，实现并发控制
通常,在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下 channel 和 WaitGroup 显得有些力不从心了。 比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和RPC服务。 所以我们需要一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的 Context，称之为上下文非常贴切，它就是goroutine 的上下文。 它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。

context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。

context 包的核心是 struct Context，接口声明如下：

Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号

Err() 在Done() 之后，返回context 取消的原因。

Deadline() 设置该context cancel的时间点

Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。

Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。

一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。 其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。 典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。

5. JSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？　
首先JSON 标准库对 nil slice 和 空 slice 的处理是不一致.

通常错误的用法，会报数组越界的错误，因为只是声明了slice，却没有给实例化的对象。

此时slice的值是nil，这种情况可以用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值。

empty slice 是指slice不为nil，但是slice没有值，slice的底层的空间是空的，此时的定义如下：

当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值。

总之，nil slice 和 empty slice是不同的东西,需要我们加以区分的.

6. 协程，线程，进程的区别。
进程
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

线程
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

协程
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

8. Golang的内存模型，为什么小对象多了会造成gc压力。
通常小对象过多会导致GC三色法消耗过多的GPU。优化思路是，减少对象分配.

9. Data Race问题怎么解决？能不能不加锁解决这个问题？
同步访问共享数据是处理数据竞争的一种有效的方法.golang在1.1之后引入了竞争检测机制，可以使用 go run -race 或者 go build -race来进行静态检测。 其在内部的实现是,开启多个协程执行同一个命令， 并且记录下每个变量的状态.

竞争检测器基于C/C++的ThreadSanitizer 运行时库，该库在Google内部代码基地和Chromium找到许多错误。这个技术在2012年九月集成到Go中，从那时开始，它已经在标准库中检测到42个竞争条件。现在，它已经是我们持续构建过程的一部分，当竞争条件出现时，它会继续捕捉到这些错误。

竞争检测器已经完全集成到Go工具链中，仅仅添加-race标志到命令行就使用了检测器。

要想解决数据竞争的问题可以使用互斥锁sync.Mutex,解决数据竞争(Data race),也可以使用管道解决,使用管道的效率要比互斥锁高.

10. 什么是channel，为什么它可以做到线程安全？
Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication),Channel也可以理解是一个先进先出的队列，通过管道进行通信。

Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据 都是 原子性的。而且Go的设计思想就是:不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的。
