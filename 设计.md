### 如何设置一个延迟队列

定义: 
    与普通队列相比,延迟队列的元素入队时会指定一个延时时间,表示其希望能够在经过该指定时间后处理。从某种意义上来讲,延迟队列的结构并不像一个队列,
    更像一个以时间为权重的有序堆结构
应用场景:
    包含不同延迟时间的任务,如下列情况:
```
    新建的订单，如果用户在 15 分钟内未支付，则自动取消。
    公司的会议预定系统，在会议预定成功后，会在会议开始前半小时通知所有预定该会议的用户。
    安全工单超过 24 小时未处理，则自动拉企业微信群提醒相关责任人。
    用户下单外卖以后，距离超时时间还有 10 分钟时提醒外卖小哥即将超时。
``` 
实现方案：
    使用redis的zset数据结构,zset每个元素都有一个对应score，zset总所有元素是按照其score进行排序的
----------------------------------------------------------------------------------------------
    rabbitMQ:
        RabbitMQ 本身并不直接提供对延迟队列的支持，我们依靠 RabbitMQ 的TTL以及死信队列功能，来实现延迟队列的效果
    ```
    死信队列: 消息被拒绝,TTL过期了，消息队列达到最大长度 这样的消息被称为死信, 消息一变为死信,就会被转发到对应的死信队列上，监听该队列可以重新被消费
    ```
    设置消息TTL为延时时间,一直不去消费，延时时间过后,该消息就会投递到死信队列中,同时使用消费者进程实时的消费死信队列；
-------------------------------------------------------------------------------------------------
   TimeWheel:
        时间轮算法, 有一个数组来表示时间，每个数组对应一个双向链表；
-------------------------------------------------------------------------------------------------

#### 设计一个C++HashMap类

```
hash_map基于hash table（哈希表）
哈希表最大的优点: 
    就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；
    而代价仅仅是消耗比较多的内存。
    然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。
    编码比较容易也是它的特点之一
基本原理:
    使用一个下标范围比较大的数组来存储元素。
    可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，
    于是用这个数组单元来存储这个元素；也可以简单的理解为，
    按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。 
    “直接定址”与“解决冲突”是哈希表的两大特点
    
```

#### bitmap原理
    bitmap 就是使用一个bit位来标记某个元素,而数据下标是该元素，该元素是否存在是使用bit的0,1表示。

