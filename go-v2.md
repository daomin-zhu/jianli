#### 基础

slice 相关
```
底层实现:
    切片是对数组一个连续片段的引用，是一个引用类型；
    本身是一个只读对象,其工作机制类似数据指针的一种封装；
    type slice sturct{
        array unsafe.Pointer //引用的数组指针
        len int //数组长度
        cap int //容量
    }
nil和空切片:
    nil切片用于描述一个不存在的切片
    空切片用于描述长度为0的切片
    区别是空切片指向的地址不是nil，指向的是一个内存地址
    但是它没有分配任何内存空间，即底层元素包含0个元素
扩容规则:
1. 如果新申请的容量大于2倍的旧容量,最终容量就是新申请的容量
2. 否则，判断旧容量的长度小于1024,则最终容量就是旧容量的2倍
3. 否则，判断旧容量大于等于1024，则最终容量从旧容量开始循环增加
    原来的1/4，直至最终容量大于等于新申请的容量
4. 如果最终容量计算值溢出，则最终容量就是新申请的容量（TODO:溢出什么意思）
问题: 
    1. 扩容之后的数组一定是新的吗？
       不一定，如果数组长度满足扩容需求，会在原数组的基础上扩容
```
map 相关
```
底层实现:
有序排列:
```
slice和array的区别
```
array: 
    1.数组长度固定，长度是数组类型的一部分;
    [3]int与[4]int是2种不同的类型
    2. 数组复制和传参都是值拷贝
slice: 
    1.切片非固定长度,包含长度，指针，容量三个属性
    2. 切片作为引用传递
```
make和new的区别
```
1. make 只用于slice,map,channel，返回的是初始化之后的T类型的值，
    这个值是经过初始化之后的T的引用，作为函数传参之后在函数内部修改
    将影响函数外部的值;
2. new返回的T的指针*T并指向T的零值
```
channel 相关
```
结构:
    type hchan struct {
    qcount   uint           // 队列中数据个数
    dataqsiz uint           // channel 大小
    buf      unsafe.Pointer // 存放数据的环形数组
    elemsize uint16         // channel 中数据类型的大小
    closed   uint32         // 表示 channel 是否关闭
    elemtype *_type // 元素数据类型
    sendx    uint   // send 的数组索引
    recvx    uint   // recv 的数组索引
    recvq    waitq  // 由 recv 行为（也就是 <-ch）阻塞在 channel 上的 goroutine 队列
    sendq    waitq  // 由 send 行为 (也就是 ch<-) 阻塞在 channel 上的 goroutine 队列
    lock mutex
}
使用:
    1. 重复关闭channel会导致panic
    2. 向关闭的channel发送数据会panic
    3. 从关闭的channel读数据不会panic
典型用法:
    1. goroutine通信 goroutine中写入，goroutine外读出
    2. select 一般配合for使用，管理多个channel的读写
    3. range channel 可以直接读取channel的值，当使用range来操作的时候，
       一旦channel关闭,channel内部数据读完之后循环自动结束。
    4. 超时控制
        select {
            case <- ch:
            case <time.After(2):        
        }
    5. 生产者消费者模型
```

进程,线程,协程的异同
```
进程: 
    分配资源的最小单位,可执行程序运行中形成的一个独立的内存体

线程:
    系统调度的最小单位,每个线程拥有各自的栈空间,其他的与内存空间一起共享
协程:
    用户态的轻量级线程,调度完全由用户控制.
    协程拥有自己的寄存器上下文和栈

协程切换成本：
    保存当前cpu寄存器的状态,加载需要切换的协程的CPU寄存器状态,完全在用户态进行
    一般来说一次协程上下文切换最多就是几十ns这个量级。
线程切换成本：
   1. 需要从用户态切换到内核态才能进行线程切换
   2. 除了CPU上下文,还需要保存切换线程私有的栈和寄存器

协程切换比线程切换快主要有两点：
 1 协程切换完全在用户空间进行;线程切换涉及特权模式切换，需要在内核空间完成；
 2 协程切换相比线程切换做的事情更少;线程需要有内核和用户态的切换,系统调用过程。
```

变量的重声明
```
定义:
 已经声明的变量再次被声明赋值
前提:
    1、 变量再次声明时必须与其原本的类型相同,否则会产生编译错误
    2、 变量的重声明只能发生在某一个代码块中。
    3、 变量的重声明只有在使用短变量声明时才会发生,否则无法通过编译
    4、 被"声明并赋值"的变量必须时多个,且至少有一个是新变量，
        这时我们才可以说对其中的旧变量进行了重声明
```
类型转换
```
整数类型转换:
    小范围向大范围的数值可以正常转换;
    大范围向小范围的数值转换时,
    只需要在补码形式下截掉一定数量的高位二进制数即可
浮点型转整型:
    当把一个浮点型转为整型时,前者的小数部分会被全部截掉
整数转string类型:
    被转换的整数值应该可以代表一个有效的 Unicode 代码点，
    否则转换的结果将会是"�"（仅由高亮的问号组成的字符串值）
```
高效的拼接字符串
```
    Go语言中,字符串是只读的,也意味着每次修改操作都会创建一个新的字符串,
    如果需要拼接多次,应使用strings.Builder，最小化内存拷贝次数
```
rune类型
```
    unicode在golang中的类型,是int32类型的别名,包含世界上书写系统总存在
    的所有字符的标准编号
    GO语言中,字符串底层表示是byte(8 bit)序列,而非rune(32 bit)序列
```
GO支持默认参数或者可选参数吗
```
可选参数:
    参数可以是非必须的,可以指定传递非必须的参数
Go语言不支持可选参数,也不支持方法重载
```
defer执行顺序
```
    TODO:
    计算式，变量，等多种情况
```
go语言tag的用处
```
    tag是struct的一部分,主要用于反射场景; 
    反射包中拥有tag的处理方式
```

字符串切片相等判断
```
    1 使用reflect.DeepEqual(a,b)判断  影响性能(需要进行反射判断)
    2 使用遍历的方式比较
```
空strct{}的用途
```
1 空结构体也是结构体,只是 size 为0的类型而已；
2 所有的空结构体都有一个共同的地址：zerobase 的地址；
3 空结构体可以作为 receiver,receiver是空结构体作为值的时候，
  编译器其实直接忽略了第一个参数的传递，编译器在编译期间就能确认生成对应的代码；
4 map 和 struct{} 结合使用常常用来节省一点点内存，使用的场景一般用来判断 key 存在于 map；
5 chan 和 struct{} 结合使用是一般用于信号同步的场景，用意并不是节省内存，而是我们真的并不关心 chan 元素的值；
6 slice 和 struct{} 结合好像真的没啥用
总结: struct{}就是一个标志
```
go程序运行顺序
```
1 初始化导入的包,按照依赖顺序初始化,优先初始化没有依赖的包
2 初始化常量
3 初始化变量
4 init函数 
  不同文件中的 init方法的执行按照文件名先后执行各个文件中的 init 方法
  同一个文件中的多个init方法,按照在代码中编写的顺序依次执行不同的 init 方法
5 main函数
一句话总结: import->const->var->init()->main()
```
内存逃逸
```
逃逸定义:
    程序中每个函数都会分配一个栈帧用来存放自己的局部变量、返回地址,函数运行结束后栈帧销毁；
    但是有些变量在结束后仍会使用,那么就需要将这个变量分配在堆上；
    这种从栈上逃逸到堆上的现象就称为内存逃逸    
由编译器决定:
    编译器通过逃逸分析确定变量是在栈上还是堆上
    当发现变量的作用域没有超出函数范围,就可以在栈上,反之则必须分配在堆上
内存逃逸的五种情况:
    1 发送指针的指针或值包含了指针到channel中,由于在编译阶段无法确定其作用域与传递的路径,所以一般都会逃逸到堆上分配。
    2 slices中的值是指针的指针或包含指针字段。
    3 slice由于append操作超出其容量,因此会导致slice重新分配。
    4 在interface类型上调用方法
        在interface类型上调用方法都是动态调度的;方法的真正实现只能在运行时知道.
	    想象一个io.reader类型变量r,调用r.read(b)会使得r的值和切片b的背后存储都逃逸掉,所以会在堆上分配.
    5 返回局部变量的引用,生命周期大于栈,导致内存逃逸
避免内存逃逸的办法:
    对于小型的数据,使用传值而不是传指针,避免内存逃逸。
    避免使用长度不固定的slice切片,在编译期无法确定切片长度,只能将切片使用堆分配。
    interface调用方法会发生内存逃逸，在热点代码片段，谨慎使用。
逃逸分析:
	go build -gcflags=-m main.go
```

2个interface可以比较吗
```
可以
原因:
    interface的内部实现包含了2个字段,类型T和值V
    interface可以使用==或!=比较 todo:验证
相等的情况:
    1、两个Interface均等于nil
    2、类型相同其对应的V值等
```
2个nil可能不相等吗
```
可能
原因:
    接口等于nil,表示其类型T和值V处于unset状态
    两个值比较时会先比较T,在比较V;
重点理解interface  todo
------------------------
接口是对非接口值的封装,内部实现包含2个字段,类型T和值V
一个接口等于nil,当且仅档T和V处于unset状态:
两个值比较时,会先比较T在比较V
接口值和非接口值比较时,会先将接口值尝试转换为接口值,在比较。
func main() {
	var p *int = nil
	var i interface{} = p
	fmt.Println(i == p) // true
	fmt.Println(p == nil) // true
	fmt.Println(i == nil) // false
}
上面这个例子中，将一个 nil 非接口值 p 赋值给接口 i，此时，i 的内部字段为(T=*int, V=nil)，
i 与 p 作比较时，将 p 转换为接口后再比较，因此 i == p，
p 与 nil 比较，直接比较值，所以 p == nil。
但是当 i 与 nil 比较时，会将 nil 转换为接口 (T=nil, V=nil)，与i (T=*int, V=nil) 不相等，
因此 i != nil。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。
----------------------
```
垃圾回收的工作原理
```
golang通过三色标记法加写屏障技术实现垃圾回收

标记清除法:
    定义:
        标记清除收集器是跟踪式垃圾收集器,其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：
        标记阶段:
            从根对象出发查找并标记堆中所有存活的对象；
        清除阶段:
            遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。
        问题:
            是在标记期间,需要暂停程序（Stop the world，STW)
            标记结束之后,用户程序才可以继续执行

    三色标记法:
        将程序中的对象分成白色、黑色和灰色三类:
            白色: 不确定对象
            灰色: 存活对象,子对象待处理
            黑色: 存活对象
        执行流程:
            1 标记开始时所有对象加入白色集合(需要STW).
            2 将根对象标记为灰色,并加入灰色集合
            3 垃圾收集器取出一个灰色对象,并将其标记为黑色,将其指向的对象标记为灰色,加入灰色集合
            4 重复3的过程,直到灰色集合为空,标记阶段结束; 那么白色对象就是需要清理的对象;
              而黑色对象均是根可达的对象,不能清理
        总结:
            从根遍历所有对象,不可达的对象即认为可清理的对象
            因为多了一个白色的状态存放不确定的对象,后续的标记阶段可以并发执行
            并发过程中可能会有遗漏,因为最开始的黑色对象有可能在标记过程中
            就已经不可达了
        问题:
            在 GC 过程中,对象指针会发生了改变,导致不该回收的对象回收了
            使用写屏障技术解决这个问题
            例子:
            A (黑) -> B (灰) -> C (白) -> D (白)
            正常情况下，D 对象最终会被标记为黑色，不应被回收。
            但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，
            而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。
            A (黑) -> B (灰) -> C (白) 
            ↓
            D (白)
    写屏障技术:
            当对象新增或更新时,会将其着色为灰色
            这样即使与用户程序并发执行,对象的引用发生改变时,垃圾收集器也能正确处理了
GC四个阶段：
    1 标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)
    2 使用三色标记法标记（Marking, 并发）
    3 标记结束(Mark Termination，需 STW)，关闭写屏障。
    4 清理(Sweeping, 并发)
```
函数返回局部变量的指针是否安全
```
Go中是安全的,Go 编译器将会对每个局部变量进行逃逸分析。
如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上
```
非接口非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？
```
一个T类型的值可以调用为*T类型声明的方法:
    但是仅当此T的值是可寻址(addressable) 的情况下。
    编译器在调用指针属主方法前，会自动取此T值的地址。
    因为不是任何T值都是可寻址的，所以并非任何T值都能够调用为类型*T声明的方法。
一个*T类型的值可以调用为类型T声明的方法:
    因为解引用指针总是合法的。事实上，你可以认为对于每一个为类型 T 声明的方法，
    编译器都会为类型*T自动隐式声明一个同名和同签名的方法。
------------------------------------------------------------------------
不可寻址的值:
    字符串中的字节
    map对象中的元素（slice对象中的元素是可寻址的，slice的底层是数组）；
    常量；
    包级别的函数等。
举一个例子，定义类型 T，并为类型 *T 声明一个方法 hello()，变量 t1 可以调用该方法，但是常量 t2 调用该方法时，会产生编译错误。
type T string

func (t *T) hello() {
	fmt.Println("hello")
}

func main() {
	var t1 T = "ABC"
	t1.hello() // hello
	const t2 T = "ABC"
	t2.hello() // error: cannot call pointer method on t
}
```
无缓冲的 channel 和 有缓冲的 channel 的区别？
```
对于无缓冲的 channel:
    发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。

对于有缓存的 channel:
    发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。
无缓冲的channel由于没有缓冲,发送和接受需要同步
有缓冲channel不要求发送和接收操作同步
```
什么是协程泄露(Goroutine Leak)？
```
定义:
    协程泄露是指协程创建后,长时间得不到释放,并且还在不断地创建新的协程,最终导致内存耗尽,程序崩溃。
泄露情形：
    1 缺少接收器，导致发送阻塞
        例子:
            func query() int {
            ch := make(chan int)
            for i := 0; i < 1000; i++ {
                go func() { ch <- 0 }()
            }
            return <-ch
        }

        func main() {
            for i := 0; i < 4; i++ {
                query()
                fmt.Printf("goroutines: %d\n", runtime.NumGoroutine())
            }
        }
    2 缺少发送器，导致接收阻塞
```
golang安全读写共享变量
```
mutex channel 和原子性   todo: 需要实践
```
golang并发模型
```
通过channel通知实现并发控制:
    利用channel缓冲区满了之后阻塞的原理进行控制
通过sync包中的WaitGroup实现并发控制
    利用WaitGroup的Add Done Wait函数实现
Go1.7 版本以后引入Context上下文实现并发控制:
    多用于网络请求中的控制
----------------------------------------------
TODO:每种实现一下
```
Go中nil的slice与空的slice处理是否一致
```
不一致
    nil 表示只声明类型,slice尚未分配内存,不能够存储数据;
    空  表示slice已经分配了内存,只是没有存储值;
=------------------------------
TODO: 验证,并确认slice扩容规则
扩容规则:
在原容量扩大两倍还要小于扩容后的容量时，预估容量就是扩容后的
当大于扩容后的时，如果小于1024时，预估容量是扩容前容量的2倍
当大于扩容后的时，如果大于1024时，预估容量是扩容前容量的1.25倍，即以0.25增加
与内存大小也有一定关联
两倍的旧容量小于预估计的容量，所以预估计容量成了62， 62 * 8 = 496，在内存规格中选择到了512，所以512 / 8 = 64，即cap(a) = 64
```
进程,线程及协程
```
进程:
    具有一定独立功能的程序关于某个数据集合上的一次运行活动
    是系统进行资源分配和调度的一个独立单位;
线程:
    是进程的一个实体,线程是内核态,而且是CPU调度和分派的基本单位,
    是比进程更小的能独立运行的基本单位.
    线程基本上不拥有系统资源,只拥有一点运行必不可少的资源(如程序计数器\寄存器和栈)
    但是可以与同一个进程的其他线程共享进程拥有的全部资源
协程:
    是一种用户态的轻量级线程,协程的调度完全由用户控制.
    拥有自己的寄存器上下文和栈,协程调度切换时,将寄存器上下文和栈保存到其他地方,
    在切换回来的时候,恢复先去保存的寄存器上下文和栈,直接操作栈则基本没有内核切换的开销
    可以不加锁的访问全局变量,所以上下文切换非常快.
----------------------------------------------------------------------------------
```
Goroutine和线程的区别
```
1 从调度上看,goroutine的调度开销远远小于线程调度开销。
    OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。
    这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，
    再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：
    即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。
    某种意义上，这种操作还是很慢的。
    Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，
    m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，
    而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。
2 从栈空间上，goroutine的栈空间更加动态灵活。
    每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。
    这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB,
    在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000=200MB）。
    而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB。
3 goroutine没有一个特定的标识。
    在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，
    本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰。
    goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，
    即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。
```
Golang的内存模型中为什么小对象多了会造成GC压力
```
通常小对象过多会导致GC三色法消耗过多的CPU.
优化思路时减少对象分配.
```
Go中数据竞争问题怎么解决
```
解决问题:
    1 互斥锁 sync.Mutex
    2 CAS无锁并发
    解决数据竞争问题可以使用互斥锁,也可以使用管道,使用管道效率要高点;
    TODO: 写个例子
---------------------------------------------
golang1.1之后引入了竞争检测机制:
        go run -race 或者 go build -race 进行静态检测
        go test -race mypkg //测试包
        go run -race mysrc.go // 编译和运行程序
        go build -race mycmd // 构建程序
        go install -race mypkg //安装程序

```
channel
```
定义:
    Go中的核心类型,可以看作一个管道,也可以理解成一个先进先出的队列
为什么它可以做到线程安全:    
    发送一个数据到channel和从channel接收一个数据都是原子性的
```
屏障机制
```
强-弱三色不变式
    强三色不变式: 不存在黑色对象引用到白色对象的指针
    弱三色不变式: 所有被黑色对象引用的白色对象都处于灰色保护状态
插入屏障:
    具体操作: 在A对象引用B对象的时候,B对象被标记为灰色
    满足: 强三色不变式
    缺点: 结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活
删除屏障:
    具体操作: 被删除的对象,如果自身为灰色和白色,那么被标记为灰色
    满足: 弱三色不变式(保护灰色对象到白色对象的路径不会断)
    缺点:
        回收精度低，GC开始时STW扫描堆栈来记录初始快照
        这个过程会保护开始时刻的所有存活对象
不执行STW的话下面2种情况会丢失
条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)
条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)

```
GC的触发条件
```
主动触发:
    通过调用runtime.GC来触发GC,此调用阻塞式的等待当前GC运行完毕
被动触发:
    使用监控系统,超过2分钟没有产生任何GC时,强制触发GC
    使用步调算法,核心思想就是控制内存的增长的比例,当前内存分配达到一定比例则触发
toDO: 什么时步调算法
```
GO的GMP如何调度
```
G: goroutine协程
M:  thread线程
P: processor处理器,包含了运行goroutine的资源及可运行的G队列
全局队列: 
    存放等待运行的G
P的本地队列: 
    同全局队列类似,存放的也是等待运行的G,不超过256个
P列表:
    所有的P都在程序启动时创建,并保存在数组中,最多有GOMAXPROCS个
M: 线程想运行任务就要获得P,从P的本地队列获取G,P队列为空时,M也会
   尝试从全局队列拿一批G放到P的本地队列,或者从其他P的本地队列偷一半
   放到自己的P的本地队列,M运行G,G执行后,M从P获取下一个G,不断重复
数量问题:
    P 的数量由环境变量GOMAXPROCS或者runtime的方法GOMAXPROCS()决定
    M 的数量:
     go程序启动时设置最大数量,默认1000,但是内核很难支持这么多,可以忽略
     runtime/debug中的SetMaxThreads函数,设置M的最大数量
     一个M阻塞了,会创建新的M
何时创建:
    P: 在确定了P的最大数量n后,运行时系统会根据这个数量创建n个P
    M: 没有足够的M来关联P并运行其中的可运行的G
调度器的设计策略:
    复用线程: 避免频繁创建 销毁线程,而是对线程的复用
        work stealing机制: 当本线程无可运行的G时,尝试从其他线程绑定的P偷取G,而不是销毁线程
        hand off机制: 当本线程因为G进行系统调用阻塞时,线程释放绑定的P,把P转移给其他的空闲线程执行
    利用并行:
          充分利用CPU核数
    全局G队列:
        当M无法从其他P偷取G时,可以从全局队列获取G
调度流程:
    1 通过go func创建一个goroutine
    2 G 会先保存在P的本地队列,如果P的本地队列满了,会保存在全局队列
    3 判断空闲的M是否存在,不存在创建; M会从绑定的P获取G来执行,如果
      P的本地队列为空,就会从其他MP组合偷取G;如果偷取不到,会从全局队列
      获取G
    4 一个M调度G执行的过程是一个循环机制
    5 当M执行某一个G阻塞时,runtime会把这个M从P摘除,创建一个新的线程或者复用
      空闲线程服务P
M0:
    启动程序后编号为0的主线程,对于全局变量runtime.m0,不需要再heap上分配;
    负责执行初始化操作核启动第一个G,在之后M0就和其他的M一样了
G0:
    每次启动一个M都会第一个创建的goroutine,Go仅负责调度,不执行函数;
    每个M都有自己的G0
可视化GMP编程:
    go tool bin bin.out
```
golang栈空间管理
```
go 1.3之前:
    使用分段栈, 当栈空间不足的时候,会申请一段新的空间,并通过指针与原本的栈链接
    分段栈的好处:
        可以按需增长，空间利用率比较高
    分段栈的坏处:
        当一个段即将用尽，这时使用for循环执行一个比较耗空间的函数，会导致函数执行时goroutine进行段的分配，
        而执行完成返回时，进行段的销毁，这样就会导致在循环中出现多次栈的扩容和收缩，造成很大的性能损失，
        这种情况被称作栈分裂
1.3及之后:
    使用连续栈
    当栈空间不够时，直接new一个2倍大的栈空间，并将原先栈空间中的数据拷贝到新的栈空间中，而后销毁旧栈
总结:
    相比于分段栈，连续栈避免了某些场景下栈空间的的频繁伸缩。有一点需要注意的是，连续栈的收缩也是需要重新申请一段空间（原先的1/2大小），并进行栈拷贝操作的
```
怎么查看Goroutine的数量
```
GOMAXPROCS可以查看Goroutine的数量
```
怎么限制goroutine的数量
```
使用channel限定数量,超了就阻塞
```
golang的锁
```
互斥锁
读写锁
sync.map的安全锁
todo: 使用
```
Channel是同步的还是异步的
```
Channel是异步进行的
channel存在3种状态：
    nil，未初始化的状态，只进行了声明，或者手动赋值为nil
    active，正常的channel，可读或者可写
    closed，已关闭，千万不要误认为关闭channel后，channel的值是nil
````
| 操作 | 一个零值nil通道 | 一个非零值但已关闭的通道 | 一个非零值且尚未关闭的通道 |
| - | - | - | - |
| 关闭 | 产生恐慌 | 产生恐慌 | 成功关闭 |
| 发送数据 | 永久阻塞 | 产生恐慌 | 阻塞或者成功发送 |
| 接收数据 | 永久阻塞 | 永不阻塞 | 阻塞或者成功接收 |
------------------------------------------------------------------
Go的defer原理
```
goroutine的控制结构中，有一张表记录defer，
调用 runtime.deferproc时会将需要defer的表达式记录在表中，
而在调用 runtime.deferreturn的时候，则会依次从defer表中出栈并执行
```
go中的select
```
Golang的select机制:
    监听多个channel,每一个case是一个事件,
    可以是读事件也可以是写事件,
    随机选择一个执行,可以设置default,
    它的作用是：当监听的多个事件都阻塞住会执行default的逻辑
```
goroutine退出方式
```
使用for-range退出:
    range能够感知channel的关闭，当channel被发送数据的协程关闭时，
    range就会结束，接着退出for循环。
    go func(in <-chan int) {
        for x := range in {
            fmt.Printf("Process %d\n", x)
        }
    }(in)

使用select case,ok退出:
问题:
    1 继续读已关闭的通道,会读到该数据类型对应的零值,
      如果时指针,读到nil,继续处理还是会产生nil
        解决:
            如果某个通道关闭后，需要退出协程，直接return即可
            go func() {
                for {
                    select {
                    case x, ok := <-in:
                        if !ok {
                            return
                        }
                        fmt.Printf("Process %d\n", x)
                        processedCnt++
                    case <-t.C:
                        fmt.Printf("Working, processedCnt = %d\n", processedCnt)
                    }
                }
            }()
            如果某个通道关闭了,需要继续处理其他case,退出是等待所有的可读通道关闭.
            把只读通道设置为nil即可解决.(select不会在nil的通道上进行等待)
            go func() {
                for {
                    select {
                    case x, ok := <-in1:
                        if !ok {
                            in1 = nil
                        }
                    case y, ok := <-in2:
                        if !ok {
                            in2 = nil
                        }
                    case <-t.C:
                        fmt.Printf("Working, processedCnt = %d\n", processedCnt)
                    }

                    if in1 == nil && in2 == nil {
                        return
                    }
                }
            }()
    2 继续写已关闭的通道,将会panic
        解决:
            把接收方的通道入参声明为只读，如果接收协程关闭只读协程，编译时就会报错
-----------------------------------------------------------------------------

```
Context包的用途
```
Context中的方法是协程安全的,所以在父routine中创建的context
可以传递给任意数量的routine并让他们同时访问。
------------------------------------------------------------------------------------
Context中的方法:
    Done:
        会返回一个channel,当该context被取消的时候,该channel会被关闭,
        同时对应的使用该context的routine也应该结束并返回
    Deadline:
        会返回一个超时时间,routine获得了超时时间后,可以对某些io操作设定超时时间。
Context 使用原则:
    1 不要把Context放在结构体中,要以参数的方式传递。
    2 以Context作为参数的函数方法,应该把Context作为第一个参数,放在第一位。
    3 给一个函数方法传递Context的时候,不要传递nil,
        如果不知道传递什么,就使用context.TODO。
    4 Context的Value相关方法应该传递必须的数据,不要什么数据都使用这个传递。
    5 Context是线程安全的，可以放心的在多个goroutine中传递。
```
Go主协程如何等其余协程完再操作
```
WaitGroup用来等待一组操作完成的
    WaitGroup内部实现了一个计数器,用来记录未完成的操作个数.
    它提供了三个方法:
        Add()用来添加计数,Done()用来在操作结束时调用使计数减一
        Wait()用来等待所有的操作结束即计数变为0,该函数会在计数不为0时等待
        在计数为0时立即返回。
```
slice扩容规则
```
（1）如果扩容前的容量翻倍之后还是小于所需最小容量，那么预估容量就等于所需最小容量。

（2）如果不满足第一条，而且扩容前容量小于1024，那就直接翻倍没商量。

（3）如果不满足第一条，而且扩容前容量大于等于1024，那就循环扩容四分之一，直到大于等于所需最小容量。
其扩容时的大小增长规则是：
    如果切片的容量小于1024个元素,那么扩容的时候slice的cap就翻番;
    一旦元素个数超过1024个元素,增长因子就变成1.25,即每次增加原来容量的四分之一
    如果扩容之后,还没有触及原数组的容量,那么,切片中的指针指向的位置,就还是原数组
    如果扩容之后,超过了原数组的容量,那么,Go就会开辟一块新的内存,把原来的值拷贝过来,
    这种情况丝毫不会影响到原数组。
    第一步：

扩容前容量是3，添加一个元素，最少要扩容到4。

原容量翻倍为6，大于4；

且原容量和1024比，小于1024，所以直接翻倍，预估容量为6。



第二步：

预估容量乘以元素大小（6*16=96），等于96字节。



第三步：

96字节匹配到内存规格也是96字节。

所以，最终扩容后容量为6。
g1.18和256比较
```
Go中的map如何实现顺序读取
```
    Go中map如果要实现顺序读取的话,可以先把map中的key,通过sort包排序.
    通过sort中的排序包进行对map中的key进行排序.
```
Go中CAS是怎么回事
```
CAS算法(Compare And Swap),是原子操作的一种,CAS算法是一种有名的无锁算法
无锁编程:
    即不使用锁的情况下实现多线程之间的变量同步,也叫非阻塞同步(Non-blocking Synchronization)。
    可用于在多线程编程中实现不被打断的数据交换操作,
    从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。
    该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。
Go中的CAS操作:
    借用CPU提供的原子性指令来实现
    CAS操作修改共享变量时候不需要对共享变量加锁,
    而是通过类似乐观锁的方式进行检查,
    本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）。
```

Go值接收者和指针接收者的区别
```
值类型既可以调用值接收者的方法,也可以调用指针接收者的方法;
指针类型既可以调用指针接收者的方法,也可以调用值接收者的方法

使用指针作为方法的接收者的理由：
    1 使用指针方法能够修改接收者指向的值
    2 可以避免在每次调用方法时复制该值,在值的类型为大型结构体时，这样做会更加高效。
```
| 函数和方法 | 值接收者 | 指针接收者 |
| - | - | - |
| 值类型调用者|方法会使用调用者的一个副本,类似于"传值" | 使用值的引用来调用方法上例中，p1.GetAge() 实际上是 (&p1).GetAge(). |
| 指针类型调用者 | 指针被解引用为值,上例中，p2.GetAge()实际上是 (*p1).GetAge() | 实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针 |

-----------------------------------------------------------
Go的对象在内存中是怎样分配的
```
Go的内存分配原则:
    Go在程序启动的时候,会先向操作系统申请一块内存(注意这时还只是一段虚拟的地址空间,并不会真正地分配内存),切成小块后自己进行管理。
    申请到的内存块被分配了三个区域,在X64上分别是512MB，16GB，512GB大小。
    TODO 待补充
```
栈的内存是怎么分配的
```
栈和堆区别：
    栈在高地址,从高地址向低地址增长。
    堆在低地址,从低地址向高地址增长。
栈和堆相比优势:
    栈的内存管理简单,分配比堆上快。
    栈的内存不需要回收,而堆需要,无论是主动free,还是被动的垃圾回收,这都需要花费额外的CPU。
    栈上的内存有更好的局部性,堆上内存访问就不那么友好了
```
堆内存管理怎么分配的
```
    把使用的内存块从链表中取出来,然后标记为未使用,当分配内存块的时候
    可以从未使用内存块中有先查找大小相近的内存块,如果找不到,再从未分配的内存中分配内存。
想要深入了解可以看下这个文章,《Writing a Memory Allocator》.
    TODO: 待补充
```
在Go函数中为什么会发生内存泄露
```
内存泄漏:
    能够预期的能很快被释放的内存由于附着在了长期存活的内存上或生命期意外地被延长
    导致预计能够立即回收的内存而长时间得不到回收
内存泄露的形式:
    1 预期能被快速释放的内存因被根对象引用而没有得到迅速释放.
    2 当有一个全局对象时,可能不经意间将某个变量附着在其上,且忽略的将其进行释放,
      则该内存永远不会得到释放。
```
goroutine泄漏
```
定义:
    Goroutine作为一种逻辑上理解的轻量级线程,需要维护执行用户代码的上下文信息
    在运行过程中也需要消耗一定的内存来保存这类信息,而这些内存在目前版本的Go中是不会被释放的。
    如果一个程序持续不断地产生新的 goroutine且不结束已经创建的goroutine并复用这部分内存
    就会造成内存泄漏的现象.
```
Go中new和make的区别
```
new该方法的参数要求传入一个类型,而不是一个值,它会申请一个该类型大小的内存空间,并会初始化为对应的零值,返回指向该内存空间的一个指针。
make也是用于内存分配,但是和new不同.只用来引用对象slice、map和channel的内存创建,它返回的类型就是类型本身,而不是它们的指针类型。
```
G0的作用
```
g0作为一个特殊的goroutine,为scheduler执行调度循环提供了场地(栈)
对于一个线程来说,g0总是它第一个创建的goroutine
之后,它会不断地寻找其他普通的goroutine来执行,直到进程退出。
当需要执行一些任务,且不想扩栈时,就可以用到 g0了,因为 g0 的栈比较大。
g0 其他的一些“职责”有:
    创建 goroutine
    deferproc 函数里新建 _defer
    垃圾回收相关的工作（例如 stw、扫描 goroutine 的执行栈、一些标识清扫的工作、栈增长）等等。
```
golang使用类型推断有什么好处
```
go语言的类型推断可以明显提升程序的灵活性,使得代码重构变得更加容易,
同时又不会给代码维护带来额外负担，也不会损失程序运行的效率
note: 类型推断可以单独修改定义的部分，其他由编译器推断，不用每个地方都修改
```
变量的重声明是什么意思
```
定义:
 已经声明的变量再次被声明赋值
前提:
    1、 变量再次声明时必须与其原本的类型相同,否则会产生编译错误
    2、 变量的重声明只能发生在某一个代码块中。
    3、 变量的重声明只有在使用短变量声明时才会发生,否则无法通过编译
    4、 被"声明并赋值"的变量必须时多个,且至少有一个是新变量，
        这时我们才可以说对其中的旧变量进行了重声明
```
类型转换
```
整数类型转换:
    小范围向大范围的数值可以正常转换;
    大范围向小范围的数值转换时,
    只需要在补码形式下截掉一定数量的高位二进制数即可
浮点型转整型:
    当把一个浮点型转为整型时,前者的小数部分会被全部截掉
整数转string类型:
    被转换的整数值应该可以代表一个有效的 Unicode 代码点，
    否则转换的结果将会是"�"（仅由高亮的问号组成的字符串值）
```

golang中 使用new初始化struct,如果struct中包含map,new并不能初始化map;
	需要单独初始化map,可以使用构造函数初始化map
	
待验证:
map的value本身是不可寻址的，因为map中的值会在内存中移动，并且旧的指针地址在
map改变时会变得⽆效。故如果需要修改map值，可以将 map 中的⾮指针类型
value ，修改为指针类型，⽐如使⽤ map[string]*Student .

golang 的  for ... range 语法中， stu 变量会被复⽤，每次循环会将集合中的值复制
给这个变量，因此，会导致最后 m 中的 map 中储存的都是 stus 最后⼀个 student
golang 语⾔中没有继承概念，只有组合，也没有虚⽅
法，更没有重载。
defer 在定义的时候会计算好调⽤函数的参数

如果理解struct实现interface?

对已经关闭的的 chan 进⾏读写，会怎么样？为什么？
```
读已关闭的chan能一直读到东西,但是读到的内容根据通道内关闭前是否有内容而不同
	如果chan关闭前,buff内有元素还未读,会正确读到chan内的值,且返回的第二个值(是否读成功)为true
	如果chan关闭前,buff内所有元素已经呗读完,chan内无值,接下来所有的接收的值都会非阻塞直接成功,返回channel元素的零值,
	但是第二个bool值一直为false
写已经关闭的chan会panic,因为包里面会校验,不允许写已经关闭的chan
```

golang中堆和栈的区别
```
如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销
```
字符串转成byte数组，会发生内存拷贝吗？
```
字符串转成切片会发生拷贝;严格的说,只要发生类型的强转都会发生内存拷贝;
有什么办法可以不拷贝吗?
1. unsafe.Pointer(&a) 方法可以得到变量a的地址。
2. (*reflect.StringHeader)(unsafe.Pointer(&a)) 可以把字符串a转成底层结构的形式。
3. (*[]byte)(unsafe.Pointer(&ssh)) 可以把ssh底层结构体转成byte的切⽚的指针。
4. 再通过  * 转为指针指向的实际内容。
```
interface 与 struct的关系
```
```
struct能不能比较
```
因为是强类型语言，所以不同类型的结构不能作比较，
但是同一类型的实例值是可以比较的，实例不可以比较，因为是指针类型
```
select可以用于什么，常用语gorotine的完美退出
```
golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作
每个case语句里必须是一个IO操作，确切的说，应该是一个面向channel的IO操作
```
context包的用途
```
Context通常被译作上下文，它是一个比较抽象的概念，其本质，是【上下上下】存在上下层的传递，
上会把内容传递给下。在Go语言中，程序单元也就指的是Goroutine
```
slice，len，cap，共享，扩容
```
    append函数，因为slice底层数据结构是，由数组、len、cap组成，所以，在使用append扩容时，
    会查看数组后面有没有连续内存快，有就在后面添加，没有就重新生成一个大的素组
```
map如何顺序读取
```
map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，
把key变为有序,所以可以把key放入切片,对切片进行排序，遍历切片，通过key取值。
```
明白channel是通过注册相关goroutine id实现消息通知的。

channel如何实现消息通知的
```
channel应用场景:
    数据交流:
        当作并发的buffer或者queue,解决生产者消费者问题
        多个goroutine可以并发当作生产者（Producer）和消费者（Consumer）。
    数据传递:
        一个goroutine将数据交给另一个goroutine,相当于把数据的拥有权托付出去。
    信号通知:
        一个goroutine可以将信号(closing，closed，data ready等)传递给另一个或者另一组goroutine。
    任务编排:
        可以让一组goroutine按照一定的顺序并发或者串行的执行，这就是编排功能。
    锁机制:
        利用channel实现互斥机制。
channel注意事项:
    向已经关闭的channel中写入数据会发生Panic
    关闭已经关闭的channel会发生Panic
    关闭值为nil的channel会发生Panic

nil是chan的零值,是一种特殊的 chan,对值是nil的chan的发送接收调用者总是会阻塞。
```
为什么Go Scheduler需要实现M:N的方案
```
    1 创建线程开销大,需要提高效率减少线程的创建
    2 减少GO垃圾回收的复杂度
```
GMP调度模型
```
    在Go中,线程是运行goroutine的实体,调度器的功能是把可运行的的goroutine分配到工作线程上
定义:
    全局队列: 
        存放等待运行的G
    P的本地队列:
        存放等待运行的G,存的数量有限,不超过 256 个
        新建 G’时,G’优先加入到 P 的本地队列,如果队列满了,则会把本地队列中一半的G移动到全局队列 
    P:
        调度器的核心处理器,通常表示执行上下文,用于匹配M和G.
        P的数量不能超过GOMAXPROCS配置数量;通常一个P可以与多个M对应,
        但是同一刻P只能与一个M发生绑定关系;M创建后需要自行在P的free list找到P进行绑定;
        没有绑定P的M会进入阻塞态
    M: 
        就是OS线程本身,数量可配置
    G:
        Goroutine,go的用户线程,即协程,真正携带代码执行逻辑的部分;由go func(){...}直接生成
    G0: 比较特殊的G,主要用于调度G
        有1/61的机会从全局队列获取G,其他时间从其他本地队列回去G

    本地队列:
        本地时相对P而言的本地,每个P维护一个本地队列
        生成的G一般会放到P的本地队列,只有本地队列满了的时候,
        才会截取本地队列的一半放入全局队列
    全局队列:
        承载本地队列溢出的G,为了保证调度的公平性,schedule过程中有1/61的几率优先检查全局队列
        否则本地队列一直满载的情况下,全局队列中的G将永远无法被调度到
    窃取(stealing):
        随机从其他P的本地队列窃取一半的G
    线程自旋:
        线程自旋是相对于线程阻塞而言的;一直循环获取G,避免了M的上下文切换
        自旋的线程不会超过GOMAXPROCS,因为一个P在同一时刻只能绑定一个M,
        P的数量不好超过GOMAXPROCS
调度流程:
    1 1/61的几率在全局队列中找G,60/61的几率在本地队列找G;
    2 如果在全局队列找不到G,从P的本地队列找G
    3 如果找不到,从其他P的本地队列中窃取G
    4 如果找不到,则从全局队列中拿取一部分G到本地队列,数量需要满足公式:
        n = min(len(GQ)/GOMAXPROCS+1,len(GQ/2))
    5 如果找不到,从网络中poll G 
    6 只要找到G,就会立马丢给M执行
go func调用:
    1 通过go func()创建一个goroutine
    2 新建的G优先保存在P的本地队列,如果本地队列满了,就保存在全局的队列中
    3 M会从P的本地队列获取一个可执行状态的G执行,如果本地为空,1/61的概率从
        全局队列获取,其他情况从其他MP获取
    4 M循环调度G
    5 如果M发生syscall或其余阻塞操作,M会阻塞;
        如果还有G执行,runtime会把这个线程M从P中摘除,然后创建一个新的操作系统的线程
        来服务这个P
    6  M调用结束,G会尝试获取一个空闲的P执行,并放入这个P的本地队列;
        如果获取不到,M会变成休眠状态,加入到空闲线程中,然后这个G被放入全局队列
------------------------------------------------------------------------------------------------------------
 Goroutine调度器和OS调度器是通过M结合起来的,每个M都代表了1个内核线程,OS 调度器负责把内核线程分配到 CPU 的核上执行 
 
 P和M的数量问题:
    P的数量由GOMAXPROCS或者runtime调用GOMAXPROCS()决定
    M的数量默认1000,但是一般达不到; 可以通过runtime/debug中的SetMaxThreads函数设置最大数量;
        一个M阻塞了会创建新的M
P和M何时被创建:
    确定了P的最大数量后系统就会根据P的数量创建
    没有足够的M来关联P并运行其中的可运行的G的时候创建
调度器设计策略:
    线程复用: 避免频繁的创建销毁线程
        1 work Stealing机制: 本线程无G可用时,尝试从其他线程绑定的P偷取线程
        2 hand off机制 本线程因为G进行系统调用阻塞时,线程释放绑定的P,把P转移给其他空闲的线程执行
    利用并行: 可用使用GoMAXPROCS设置P的数量
    抢占: 
        一个goroution最多占用CPU10ms,防止其他goroutuin被饿死
        协调式是指goroutine执行完才能被其他使用
    全局G队列: 只有在M从其他P偷不到G的时候才会从全局获取G
M0和G0:
    M0是启动程序后的编号为0的主线程,这个M对应的实例会在全局变量 runtime.m0 中,不需要在 heap 上分配,M0 负责执行初始化操作和启动第一个 G,
    在之后 M0 就和其他的 M 一样了
    G0是每次启动一个M都会第一个创建的goroutine,G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，
    每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0
GMP场景:
    场景一:
        P创建G后优先加入本地队列(局部性原理)
    场景二:
        G1完成后,M运行的goroutine切换为G0,G0负责调度协程的切换;
        从本地队列获取G2,从G0切换到G2并执行,实现M的复用
    场景三:
        本地队列满了后本地队列的一半转移到全局队列,并且新创建的G转移到全局队列
    场景四:
        创建G时,运行的G会尝试唤醒其他空闲的P和M组合执行
    场景五:
        本地没有G的话,从全局队列取一批G放到本地队列
        取的数量是n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))
        至少取一个,从全局队列到P本地队列的负载均衡
    场景六:
        本地和全局队列都没有G,从其他有G的P偷一半过来
    场景七:
        本地队列为空,全局队列为空,M陷入自旋状态
    
```

抢占式goroutine
```
 协作式调度依靠被调度方主动弃权
 抢占式调度则依靠调度器强制将被调度方被动中断
```
golang的内存模型
```
内存一致模型:
    或称内存模型,是一份语言用户与语言自身,语言自身与所在的操作系统平台,所在操作系统平台与硬件平台之间的契约;
    它定义了并行状态下拥有确定读取和写入的时序的条件.并回答了一个共享变量是否具有足够的同步机制来保障
    一个线程的写入能否发生在另一个线程的读取之前这个问题
Go语言的内存模型规定了一个goroutine可以看到另外一个goroutine修改同一个变量的值的条件
为了保证多goroutine下读取共享数据的正确性，go中引入happens before原则，即在go程序中定义了多个内存操作执行的一种偏序关系。如果操作e1先于e2发生，我们说e2 happens after e1,如果e1操作既不先于e2发生又不晚于e2发生，我们说e1操作与e2操作并发发生

```
并发就是可同时发起执行的程序，指程序的逻辑结构；并行就是可以在支持并行的硬件上执行的并发程序，指程序的运⾏状态

并发级别
阻塞：阻塞是指一个线程进入临界区后，其它线程就必须在临界区外等待，待进去的线程执行完任务离开临界区后，其它线程才能再进去。

无饥饿：线程排队先来后到，不管优先级大小，先来先执行，就不会产生饥饿等待资源，也即公平锁；相反非公平锁则是根据优先级来执行，有可能排在前面的低优先级线程被后面的高优先级线程插队，就形成饥饿

无障碍：共享资源不加锁，每个线程都可以自有读写，单监测到被其他线程修改过则回滚操作，重试直到单独操作成功；风险就是如果多个线程发现彼此修改了，所有线程都需要回滚，就会导致死循环的回滚中，造成死锁

无锁：无锁是无障碍的加强版，无锁级别保证至少有一个线程在有限操作步骤内成功退出，不管是否修改成功，这样保证了多个线程回滚不至于导致死循环

无等待：无等待是无锁的升级版，并发编程的最高境界，无锁只保证有线程能成功退出，但存在低级别的线程一直处于饥饿状态，无等待则要求所有线程必须在有限步骤内完成退出，让低级别的线程有机会执行，从而保证所有线程都能运行，提高并发度。


make new的区别
```
new(T) 返回 T 的指针 *T 并指向 T 的零值。
make(T) 返回的初始化的 T，只能用于 slice，map，channel。
```

golang面试题：字符串转成byte数组，会发生内存拷贝吗？
```
只要是发生类型强转都会发生内存拷贝
```


golang面试题：翻转含有中文、数字、英文字母的字符串
```
rune关键字，从golang源码中看出，它是int32的别名（-2^31 ~ 2^31-1），比起byte（-128～127），可表示更多的字符。
由于rune可表示的范围更大，所以能处理一切字符，当然也包括中文字符。在平时计算中文字符，可用rune。
因此将字符串转为rune的切片，再进行翻转，完美解决
```

golang面试题：拷贝大切片一定比小切片代价大吗？
```
并不是，所有切片的大小相同；三个字段（一个 uintptr，两个int）。切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以 拷贝大切片跟小切片的代价应该是一样的。
```
map不初始化使用会怎么样
```
读返回空,写崩溃
```
map不初始化长度和初始化长度的区别
```

```
字符串不能改，那转成数组能改吗，怎么改
```
Go 语言的字符串是不可变的。
修改字符串时，可以将字符串转换为 []byte 进行修改。
[]byte 和 string 可以通过强制类型转换互转。
```
普通map如何不用锁解决协程安全问题
```
使用sync.map
```

slice深拷贝和浅拷贝
```
浅拷贝#
目的切片和源切片指向同一个底层数组，任何一个数组元素改变，都会同时影响两个数组。
深拷贝
目的切片和源切片指向不同的底层数组，任何一个数组元素改变都不影响另外一个。

主要看是否重新分配内存
```

内存碎片化问题
chan相关的goroutine泄露的问题
string相关的goroutine泄露的问题
你一定会遇到的内存回收策略导致的疑似内存泄漏的问题
sync.Pool的适用场景
go1.13sync.Pool对比go1.12版本优化点
并发编程
sync.map 的优缺点和使用场景
sync.Map的优化点
golang面试题：能说说uintptr和unsafe.Pointer的区别吗？
golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？
协程和线程的差别
什么是写屏障、混合写屏障，如何实现？
开多个线程和开多个协程会有什么区别
两个interface{} 能不能比较
必须要手动对齐内存的情况
go栈扩容和栈缩容，连续栈的缺点
golang怎么做代码优化
golang隐藏技能:怎么访问私有成员
3. 说说go语言中，数组与切片的区别？
(1). 数组 数组是具有固定长度且拥有零个或者多个相同数据类型元素的序列。 数组的长度是数组类型的一部分，所以[3]int 和 [4]int 是两种不同的数组类型。

数组需要指定大小，不指定也会根据初始化的自动推算出大小，不可改变 ;

数组是值传递;

数组是内置(build-in)类型,是一组同类型数据的集合，它是值类型，通过从0开始的下标索引访问元素值。在初始化后长度是固定的，无法修改其长度。当作为方法的参数传入时将复制一份数组而不是引用同一指针。数组的长度也是其类型的一部分，通过内置函数len(array)获取其长度。

数组定义：

var array [10]int
var array = [5]int{1,2,3,4,5}
(2). 切片 切片表示一个拥有相同类型元素的可变长度的序列。 切片是一种轻量级的数据结构，它有三个属性：指针、长度和容量。

切片不需要指定大小;

切片是地址传递;

切片可以通过数组来初始化，也可以通过内置函数make()初始化 .初始化时len=cap,在追加元素时如果容量cap不足时将按len的2倍扩容；

切片定义：

var slice []type = make([]type, len)

19. 说说进程、线程、协程之间的区别？
进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元；

同一个进程中可以包括多个线程；

进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束；

线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程；

进程的创建调用fork或者vfork，而线程的创建调用pthread_create；

线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源；

进程是资源分配的单位

线程是操作系统调度的单位

进程切换需要的资源很最大，效率很低 线程切换需要的资源一般，效率一般 协程切换任务资源很小，效率高 多进程、多线程根据cpu核数不一样可能是并行的 也可能是并发的。协程的本质就是使用当前进程在不同的函数代码中切换执行，可以理解为并行。 协程是一个用户层面的概念，不同协程的模型实现可能是单线程，也可能是多线程。

进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。（全局变量保存在堆中，局部变量及函数保存在栈中）

线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是这样的)。

协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。

一个应用程序一般对应一个进程，一个进程一般有一个主线程，还有若干个辅助线程，线程之间是平行运行的，在线程里面可以开启协程，让程序在特定的时间内运行。

协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。
  昨天那个在for循环里append元素的同事，今天还在么？
golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？ 答案
连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。 答案
golang面试题：字符串转成byte数组，会发生内存拷贝吗？答案
golang面试题：翻转含有中文、数字、英文字母的字符串。答案
golang面试题：拷贝大切片一定比小切片代价大吗？ 答案
对未初始化的的chan进行读写，会怎么样？为什么？答案
map不初始化使用会怎么样 答案
map不初始化长度和初始化长度的区别
map承载多大，大了怎么办
map的iterator是否安全？能不能一边delete一边遍历？
字符串不能改，那转成数组能改吗，怎么改  答案
怎么判断一个数组是否已经排序  答案
普通map如何不用锁解决协程安全问题
array和slice的区别
golang面试题：json包变量不加tag会怎么样？答案
零切片、空切片、nil切片是什么
slice深拷贝和浅拷贝 答案
map触发扩容的时机，满足什么条件时扩容？
map扩容策略是什么
自定义类型切片转字节切片和字节切片转回自动以类型切片
make和new什么区别 答案
slice ，map，chanel创建的时候的几个参数什么含义
线程安全的map怎么实现
1、在进行项目开发时，遇到的关于golang的问题有哪些？
可简单描述工作中用到的东西，协程，通道，框架、加密等等，说一些关键的技术点

2、golang中关于grpc和rest都使用过吗？grpc相对于rest的优势是什么？为什么选择groc？
两种API架构概述

grpc：gRPC是RPC框架中的一种，RPC(remote procedure call 远程过程调用)框架目标就是让远程服务调用更加简单、透明。RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。RPC是一种设计理念，而gRPC是基于此种设计理念设计的真实框架。
rest：描述的是在网络中client和server的一种交互形式；一个架构样式的网络系统，指的是一组架构约束条件和原则。
grpc相对于rest的优势

gRPC 对接口有严格的约束条件，安全性更高，对于高并发的场景更适用

为什么选择grpc

grpc有明确的接口规范和对于流的支持；
RPC 效率更高。RPC使用自定义的 TCP 协议，可以让请求报文体积更小，或者使用 HTTP2 协议，也可以很好的减少报文的体积，提高传输效率。
3、golang里面常用到的技术栈有哪些？
协程、通道、web框架、密码学等

4、gin框架的好处是什么？
快速：基于Radix树的路由,性能非常强大。
支持中间件：内置许多中间件，如Logger,Gzip,Authorization等。
崩溃恢复：可以捕捉panic引发的程序崩溃，使Web服务可以一直运行。
JSON验证：可以验证请求中JSON数据格式。
多种数据渲染方式：支持HTML、JSON、YAML、XML等数据格式的响应。
扩展性：非常简单扩展中间件。
5、无缓冲通道和缓冲通道的区别是什么？
无缓冲通道，在通道满了之后就会阻塞所在的goroutine。（需要在其他goroutine中取出该通道中的元素，才能解除它所在通道的阻塞，不然就会一直阻塞下去。）
缓冲通道，存完了东西可以不取出来，不会阻塞;
缓冲通道相较于无缓冲区的通道在用法上是要灵活一些的，不会出现一次写入，一次读完就会堵塞。
6 、select的用处是什么？
过select可以监听channel上的数据流动。
select的用法与switch语言非常类似，由select开始一个新的选择块，每个选择条件由case语句来描述。

示例代码如下:

select {
    case <-chan1:
        // 如果chan1成功读到数据，则进行该case处理语句
    case chan2 <- 1:
        // 如果成功向chan2写入数据，则进行该case处理语句
    default:
        // 如果上面都没有成功，则进入default处理流程
}
7、defer的用途和使用场景是什么？
defer作用：可用于捕获程序异常，在某个方法中，出现异常时，defer可捕获此异常并进行打印，使用关键字defer向函数声明退出调用，即主函数退出时，defer后的函数才被调用。defer语句的作用是不管程序是否出现异常，均在函数退出时自动执行相关代码。
8、defer的执行顺序是什么？
defer语句并不会马上执行，而是会进入一个栈，函数return前，会按先进后出的顺序执行。也说是说最先被定义的defer语句最后执行。
注：先进后出的原因是后面定义的函数可能会依赖前面的资源，自然要先执行；否则，如果前面先执行，那后面函数的依赖就没有

9、defer函数遇到return以后是怎么执行的？
先defer再return，函数执行之后，return返回之前，按照先进后出的顺序执行

10、对于进程，线程，协程的理解是什么？
线程可以理解为轻量级的进程 协程可以理解为轻量级的线程
协程最大的优势就是可以轻松的创建上百万个，而不会导致系统资源衰减
详解请参考： 进程、线程、协程

11、有时候会遇到一些空的结构体，这个目的是什么？
空结构体不占任何内存，使用空结构体，可以帮咱们节省内存空间，提升性能golang

12、map怎么顺序读取？
map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，把key变为有序，所以可以把key放入切片，对切片进行排序，遍历切片，通过key取值。


14、如果用range修改切片元素的值，会发生什么？
我们经常会使用到range来帮助我们遍历一些数据，通常情况下都是查看操作多一些，但是当我们需要对其原地址上的内容进行变更时，通常都是使用 ==for i:=0; i<len(); i++== 来修改值。在使用range的时候，通常会将该数据结构进行拷贝，来遍历这一份拷贝后的副本，使用的是一个值传递，如果我们进行修改，修改的就只是副本，对原地址上的值不会产生任何影响。

15、了解空指针吗？
当一个指针被定义后没有分配到任何变量时，它的值为 nil。
nil 指针也称为空指针。
nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。
16、怎么用go去实现一个set
Go中是不提供Set类型的，Set是一个集合，其本质就是一个List，只是List里的元素不能重复。
Go提供了map类型，可是咱们知道，map类型的key是不能重复的，所以，咱们能够利用这一点，来实现一个set
构造一个Set的方法
构造一个set，首先定义set的类型svg

//set类型
type Set struct {
    m map[int]Empty
}
为一个结构体类型，内部一个成员为一个map，这也是主要咱们存储值的容器函数产生set的工厂性能

//返回一19et
func SetFactory() *Set{
    return &Set{
        m:map[int]Empty{},#### 。所谓并发编程是指在一台处理器上“同时”处理多个任务。
}
}
17、一般怎么比较两个结构体，怎么判断他们是否相等？
一般没有效率太高的方法：

if判断比较：使用if一个个比较两个结构体中元素的值：if(p1->age==p2->age)，如果有一个元素不等，即是两个实例不相等。
指针直接比较：如果保存的是同一个实例地址，则(p1==p2)为真。
18、make和new的区别是什么？
make 只用于 chan，map，slice 的初始化；
new 用于给类型分配内存空间，并且置零；
make 返回类型本身，new 返回指向类型的指针。
19、说一下你对并发编程的理解？
所谓并发编程是指在一台处理器上“同时”处理多个任务。
宏观的并发是指在一段时间内，有多个程序在同时运行。
并发在微观上，是指在同一时刻只能有一条指令执行，但多个程序指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个程序快速交替的执行。
20、碰到过分布式锁的问题吗？分布式锁的原理你清楚吗？
golang中的分布式锁可使用etcd进行实现，实现原理如下：

在ectd系统里创建一个key
如果创建失败，key存在，则监听该key的变化事件，直到该key被删除，回到1
如果创建成功，则认为我获得了锁

https://go-interview.iswbm.com/
https://learnku.com/articles/30718


待验证:
map的value本身是不可寻址的，因为map中的值会在内存中移动，并且旧的指针地址在
map改变时会变得⽆效。故如果需要修改map值，可以将 map 中的⾮指针类型
value ，修改为指针类型，⽐如使⽤ map[string]*Student .

golang 的  for ... range 语法中， stu 变量会被复⽤，每次循环会将集合中的值复制
给这个变量，因此，会导致最后 m 中的 map 中储存的都是 stus 最后⼀个 student
golang 语⾔中没有继承概念，只有组合，也没有虚⽅
法，更没有重载。
defer 在定义的时候会计算好调⽤函数的参数

如果理解struct实现interface?

对已经关闭的的 chan 进⾏读写，会怎么样？为什么？
```
读已关闭的chan能一直读到东西,但是读到的内容根据通道内关闭前是否有内容而不同
	如果chan关闭前,buff内有元素还未读,会正确读到chan内的值,且返回的第二个值(是否读成功)为true
	如果chan关闭前,buff内所有元素已经呗读完,chan内无值,接下来所有的接收的值都会非阻塞直接成功,返回channel元素的零值,
	但是第二个bool值一直为false
写已经关闭的chan会panic,因为包里面会校验,不允许写已经关闭的chan
```
知道golang的内存逃逸吗？什么情况下会发内存逃逸？
```
内存逃逸:
	golang程序变量会携带有一组校验数据，来证明它的整个⽣命周期是否在运行时完全可知。
	如果变量通过了这些校验，它就可以在栈上分配。否则就说它逃逸 了，必须在堆上分配。
引起内存逃逸的情况:
	1 在方法内把局部变量指针返回;局部变量原本应该在栈中分配,在栈中回收.但是由于返回是被外部引用,因此其
	生命周期大于栈,则溢出
	2 发送指针或带有指针的值到channel中. 在编译时,是没有办法知道变量什么时候才会被释放.
	3 在一个切片上存储指针或带指针的值.  一个典型的例子就是[]*string. 这会导致切片的内容逃逸.
	  尽管其后面的数组可能是在栈上分配的,但其引用的值一定是在堆上
	4 slice 的背后数组被重新分配了. 因为append时可能会超出其容量(cap). slice初始化的地方在编译时是可以知道的,
	  它最开始会在栈上分配.如果切片背后的存储要基于运行时的数据进行扩充,就会在堆上分配.
	5 在interface类型上调用方法. 在interface类型上调用方法都是动态调度的;方法的真正实现只能在运行时知道.
	  想象一个io.reader类型变量r,调用r.read(b)会使得r的值和切片b的背后存储都逃逸掉,所以会在堆上分配.
逃逸分析:
	go build -gcflags=-m main.go
```
golang中堆和栈的区别
```
如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销
```
字符串转成byte数组，会发生内存拷贝吗？
```
字符串转成切片会发生拷贝;严格的说,只要发生类型的强转都会发生内存拷贝;
有什么办法可以不拷贝吗?
1. unsafe.Pointer(&a) 方法可以得到变量a的地址。
2. (*reflect.StringHeader)(unsafe.Pointer(&a)) 可以把字符串a转成底层结构的形式。
3. (*[]byte)(unsafe.Pointer(&ssh)) 可以把ssh底层结构体转成byte的切⽚的指针。
4. 再通过  * 转为指针指向的实际内容。
```
Golang面试问题汇总:

1. Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量？
Golang中Goroutine 可以通过 Channel 进行安全读写共享变量。

2. 无缓冲 Chan 的发送和接收是否同步?
channel无缓冲时，发送阻塞直到数据被接收，接收阻塞直到读到数据。
channel有缓冲时，当缓冲满时发送阻塞，当缓冲空时接收阻塞。
4. Golang 中常用的并发模型？
Golang 中常用的并发模型有三种:

通过channel通知实现并发控制
无缓冲的通道指的是通道的大小为0，也就是说，这种类型的通道在接收前没有能力保存任何值，它要求发送 goroutine 和接收 goroutine 同时准备好，才可以完成发送和接收操作。

从上面无缓冲的通道定义来看，发送 goroutine 和接收 gouroutine 必须是同步的，同时准备后，如果没有同时准备好的话，先执行的操作就会阻塞等待，直到另一个相对应的操作准备好为止。这种无缓冲的通道我们也称之为同步通道。

当主 goroutine 运行到 <-ch 接受 channel 的值的时候，如果该 channel 中没有数据，就会一直阻塞等待，直到有值。 这样就可以简单实现并发控制

通过sync包中的WaitGroup实现并发控制
Goroutine是异步执行的，有的时候为了防止在结束mian函数的时候结束掉Goroutine，所以需要同步等待，这个时候就需要用 WaitGroup了，在 sync 包中，提供了 WaitGroup ，它会等待它收集的所有 goroutine 任务全部完成。在WaitGroup里主要有三个方法:

Add, 可以添加或减少 goroutine的数量.
Done, 相当于Add(-1).
Wait, 执行后会堵塞主线程，直到WaitGroup 里的值减至0.
在主 goroutine 中 Add(delta int) 索要等待goroutine 的数量。 在每一个 goroutine 完成后 Done() 表示这一个goroutine 已经完成，当所有的 goroutine 都完成后，在主 goroutine 中 WaitGroup 返回返回。

在Golang官网中对于WaitGroup介绍是A WaitGroup must not be copied after first use,在 WaitGroup 第一次使用后，不能被拷贝

应用示例:

运行:

它提示所有的 goroutine 都已经睡眠了，出现了死锁。这是因为 wg 给拷贝传递到了 goroutine 中，导致只有 Add 操作，其实 Done操作是在 wg 的副本执行的。

因此 Wait 就死锁了。

这个第一个修改方式:将匿名函数中 wg 的传入类型改为 *sync.WaitGrou,这样就能引用到正确的WaitGroup了。 这个第二个修改方式:将匿名函数中的 wg 的传入参数去掉，因为Go支持闭包类型，在匿名函数中可以直接使用外面的 wg 变量

在Go 1.7 以后引进的强大的Context上下文，实现并发控制
通常,在一些简单场景下使用 channel 和 WaitGroup 已经足够了，但是当面临一些复杂多变的网络并发场景下 channel 和 WaitGroup 显得有些力不从心了。 比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine，比如数据库和RPC服务。 所以我们需要一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是Go语言为我们提供的 Context，称之为上下文非常贴切，它就是goroutine 的上下文。 它是包括一个程序的运行环境、现场和快照等。每个程序要运行时，都需要知道当前程序的运行状态，通常Go 将这些封装在一个 Context 里，再将它传给要执行的 goroutine 。

context 包主要是用来处理多个 goroutine 之间共享数据，及多个 goroutine 的管理。

context 包的核心是 struct Context，接口声明如下：

Done() 返回一个只能接受数据的channel类型，当该context关闭或者超时时间到了的时候，该channel就会有一个取消信号

Err() 在Done() 之后，返回context 取消的原因。

Deadline() 设置该context cancel的时间点

Value() 方法允许 Context 对象携带request作用域的数据，该数据必须是线程安全的。

Context 对象是线程安全的，你可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。

一个 Context 不能拥有 Cancel 方法，同时我们也只能 Done channel 接收数据。 其中的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。 典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。

5. JSON 标准库对 nil slice 和 空 slice 的处理是一致的吗？　
首先JSON 标准库对 nil slice 和 空 slice 的处理是不一致.

通常错误的用法，会报数组越界的错误，因为只是声明了slice，却没有给实例化的对象。

此时slice的值是nil，这种情况可以用于需要返回slice的函数，当函数出现异常的时候，保证函数依然会有nil的返回值。

empty slice 是指slice不为nil，但是slice没有值，slice的底层的空间是空的，此时的定义如下：

当我们查询或者处理一个空的列表的时候，这非常有用，它会告诉我们返回的是一个列表，但是列表内没有任何值。

总之，nil slice 和 empty slice是不同的东西,需要我们加以区分的.

6. 协程，线程，进程的区别。
进程
进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。

线程
线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。

协程
协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

8. Golang的内存模型，为什么小对象多了会造成gc压力。
通常小对象过多会导致GC三色法消耗过多的GPU。优化思路是，减少对象分配.

9. Data Race问题怎么解决？能不能不加锁解决这个问题？
同步访问共享数据是处理数据竞争的一种有效的方法.golang在1.1之后引入了竞争检测机制，可以使用 go run -race 或者 go build -race来进行静态检测。 其在内部的实现是,开启多个协程执行同一个命令， 并且记录下每个变量的状态.

竞争检测器基于C/C++的ThreadSanitizer 运行时库，该库在Google内部代码基地和Chromium找到许多错误。这个技术在2012年九月集成到Go中，从那时开始，它已经在标准库中检测到42个竞争条件。现在，它已经是我们持续构建过程的一部分，当竞争条件出现时，它会继续捕捉到这些错误。

竞争检测器已经完全集成到Go工具链中，仅仅添加-race标志到命令行就使用了检测器。

要想解决数据竞争的问题可以使用互斥锁sync.Mutex,解决数据竞争(Data race),也可以使用管道解决,使用管道的效率要比互斥锁高.

10. 什么是channel，为什么它可以做到线程安全？
Channel是Go中的一个核心类型，可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication),Channel也可以理解是一个先进先出的队列，通过管道进行通信。

Golang的Channel,发送一个数据到Channel 和 从Channel接收一个数据 都是 原子性的。而且Go的设计思想就是:不要通过共享内存来通信，而是通过通信来共享内存，前者就是传统的加锁，后者就是Channel。也就是说，设计Channel的主要目的就是在多任务间传递数据的，这当然是安全的。
