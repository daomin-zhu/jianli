### C++基础

extern 关键字的作用
```
    extern声明变量在外部的定义？
        1、 全局变量如果不在文件开始定义,则其作用域有效区域为定义部分到文件结尾,之前的部分如果需要使用全局变量,需要使用extern声明
        2、 如果多个文件公用一个全局变量,在非定义文件中需要使用extern声明
    extern 修饰函数？
        与修饰变量作用类似,如果在一个文件中定义了函数func1，在另一个文件中可以使用extern声明这个函数，然后直接调用;
        不需要包含头文件；一般使用在较小的文件中，较大的文件通过头文件来使用；
    extern C的作用
        为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后,会指示编译器这部分代码按C语言的方式进行编译。
        由于C++支持函数重载,因此编译器编译函数的过程中会将函数的参数类型加到编译后的代码中,而不仅仅是函数名;
        而C语言不支持函数重载,因此编译C语言代码不会带上函数的参数类型,一般只包含函数名；
```

为什么要使用字节对齐
```
字节对齐是C/C++编译器的一种技术手段，主要是在可接受空间浪费的前提下，尽可能地提高对相同元素过程的快速处理。
（比如32位系统，4字节对齐能使CPU访问速度提高）
-------------------------------------------------------------------------------------------------
需要字节对齐的根本原因在于CPU访问数据的效率问题:
    因为现代计算机都使用了Cache。Cache可以看成一些可以用非常快的速度进行访问的临时内存。
    但是Cache的容量不大，CPU访问内存非常慢，
    所以硬件会将平时经常使用的内容存放到Cache里面。Cache是通过一些Cache Line来组织的，
    每一条Cache Line一般包含16个字节，32个字节或64个字节等。 
    比如某个计算机一级Cache的Cache Line长度是32个字节，那么每段Cache Line总是会包含32个字节对齐的一段内存。
    现在有一个4字节的整数，如果它的地址不是4字节对齐的，那么就有可能访问它的时候，需要使用两条Cache Line,
    这增加了总线通讯量，而且增加了对Cache的使用量，
    而且使用的数据没有在Cache里面（这时需要将数据从内存调入Cache,会非常慢）的机会会增加，这些都降低了程序的速度。
-------------------------------------------------------------------------------------------------
字节对齐的原则:
    从0位置开始存储；
    变量存储的起始位置是该变量大小的整数倍；
    结构体总的大小是其最大元素的整数倍，不足的后面要补齐；
    结构体中包含结构体，从结构体中最大元素的整数倍开始存；
    如果加入pragma pack(n) ，取n和变量自身大小较小的一个。
```
引用和指针的区别？
```
1) 指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。
2) 引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）
3) 有多级指针，但是没有多级引用，只能有一级引用。
4) 指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）
5) sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。
6) 引用访问一个变量是直接访问，而指针访问一个变量是间接访问。
7) 使用指针前最好做类型检查，防止野指针的出现；
8) 引用底层是通过指针实现的；
9) 作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。
```
指针与数组千丝万缕的联系
```
    一个一维int数组的数组名实际上是一个int* const 类型；
    一个二维int数组的数组名实际上是一个int (*const p)[n];
    数组名做参数会退化为指针，除了sizeof
```
指针和const的用法
```
1) 当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。
2) int const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过p2读写这个变量的值。
    顶层指针表示指针本身是一个常量
3) int const *p1或者const int p1两种情况中const修饰p1，所以理解为p1的值不可以改变，即不可以给p1赋值改变p1指向变量的值，
    但可以通过给p赋值不同的地址改变这个指针指向。底层指针表示指针所指向的变量是一个常量。
4) int const *const p;
```
静态变量什么时候初始化
```
1) 初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。
2) 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，
    但在C和C++中静态局部变量的初始化节点又有点不太一样。
---------------------------------------------------------------------------------------------
    在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，
    所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，
    变量所处的全局内存会被全部回收。
    在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，
    要进行初始化必须执行相应构造函数和析构函数，
    在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。
    所以C++标准定为全局或静态对象是有首次用到时才会进行构造，
    并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。
    所以在C++中是可以使用变量对静态局部变量进行初始化的。
```
static的用法和作用？
```
共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，
static可以控制变量的可见范围，说到底static还是用来隐藏的。
---------------------------------------------------
1.隐藏。
    （static函数，static变量均可）当同时编译多个文件时，
     所有未加static前缀的全局变量和函数都具有全局可见性。
2.保持变量内容的持久。
    （static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚
        开始运行时就完成初始化，也是唯一的一次初始化。
3.默认初始化为0（static变量）其实全局变量也具备这一属性，
    因为全局变量也存储在静态数据区。
    在静态数据区，内存中所有的字节默认值都是0x00，
    某些时候这一特点可以减少程序员的工作量。
4.static的第四个作用：
C++中的类成员声明static
  函数体内static变量的作用范围为该函数体，不同于auto变量，
        该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值； 
  在模块内的static全局变量可以被模块内所用函数访问，
        但不能被模块外其它函数访问；  
  在模块内的static函数只可被这一模块内的其它函数调用，
        这个函数的使用范围被限制在声明它的模块内；  
  在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；  
  在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，
        因而只能访问类的static成员变量。类内：
  static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，
        所以static修饰的变量要在类外初始化；
  由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的
        this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问
        非static的类成员，只能访问 static修饰的类成员；
  static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；
        静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，
        而vptr是通过this指针调用的，所以不能为virtual；
        虚函数的调用关系，this->vptr->ctable->virtual function
```
static 修饰变量
```
    static 修饰全局变量
        限定变量使用范围只能在本文件中使用,即使使用extern外部声明也不可以在其他文件内使用；
    static 修饰普通函数
        限定使用范围,这个函数只能在本文件内使用,不能被其他文件调用.
    static 修饰成员变量
        static成员变量属于类,不属于某个具体的对象,即使创建多个对象,所有对象使用的都是这份内存中的数据,当某个对象修改这个变量,其他对象也会影响其他对象
        static成员变量必须在类声明的外部初始化,具体形式为:  type class::name = value
        静态成员变量初始化时不能再加static 但必须要有数据类型
        static成员变量的内存既不是在声明类时分配,也不是在创建对象时分配,而是在初始化时分配；
        static既可以通过类直接访问 Class::static 也可以通过Object.static访问,也可以Point->static访问
        这三种方式等效
        static成员变量不占用对象的内存,而是在所有对象之外开辟内存,即使不创建对象也可以访问
```
static 修饰成员函数
```
static成员函数不包含this指针，所以static成员函数不能访问非static类成员,只能访问static修饰的类成员

static成员函数不能定义为const的，static函数不能访问非静态成员变量(备注:编译错误 static member function  cannot have cv-qualifier)   
```

static总结
```
1、在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，
    直到程序运行结束以后才释放。
2、static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，
    即便是 extern 外部声明也不可以。
3、static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。
4、static 修饰的变量存放在全局数据区的静态变量区，
    包括全局静态变量和局部静态变量，都在全局数据区分配内存。
    初始化的时候自动初始化为 0。不想被释放的时候，可以使用static修饰。
    比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。
6、考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。
```
静态变量与普通变量不同
```
1、静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量;
2、未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，
    除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；
 3、静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。
    优点：静态全局变量不能被其它文件所用；其它文件中可以定义相同名字的变量，不会发生冲突。
```
volatile的作用是什么
```
1、访问寄存器要比访问内存快,因此CPU会优先访问该数据在寄存器中的存储效果,
    但是内存中的数据可能已经发生改变,而寄存器中还保留着原来的结果.
    为了避免这种情况的发生,将该变量声明为volatile,告诉cpu每次都从内存去读取数据.
2、一个参数可以即是const又是volatile的吗？ 可以
```    
const的作用: 
```
1、const 修饰全局变量
2、const 修饰局部变量
3、const 修饰指针const int *;
4、const 修饰指针指向的对象 int * const
5、const 修饰成员变量,必须在构造函数列表中初始化
6、const 修饰成员函数,说明该函数不应该修改非静态成员,
    但是这并不十分可靠,指针所指的非静态成员可能会被改变
 ```   
new与malloc的区别: 验证下 operator new delete 与 delete new的效果
```
1、new分配内存按照数据类型进行分配,malloc分配内存按照大下分配；
2、new不仅分配一段内存,而且会调用构造函数,但是malloc不会；

3、new返回的是指定对象的指针,而malloc返回的是void*
4、new是一个操作符可以重载,malloc是一个库函数
5、new分配的内存要用delete销毁,malloc要用free来销毁;delete销毁的时候会调用对象的析构函数,而free不会
6、malloc分配的内不够的时候,可以用realloc扩容(扩容的原理？) new没有这样的操作
7、new如果分配失败了会抛出bad_malloc的异常,而malloc失败了会返回NULL。
    因此对于new，正确的字试是采用try...catch语法,而malloc则应该判断指针的返回值,
    为了兼容很多c语言程序员的习惯,c++也可以采用new nothrow的方法禁止抛出异常返回NULL;
8、new和new[] 的区别,new[]一次分配所有内存,多次调用构造函数;分别搭配使用delete和delete[].
9、谈谈new和malloc的实现,空闲链表,分配方法(首次适配原则,最佳视频原则,最差适配原则,快速适配原则)。delete和
```
free实现原理；free为什么知道销毁多大的空间;
```
分配的内存首地址记录了分配了多大的内存，free的时候根据这个获取销毁的大小
```
new delete 实现原理
```
new实现的原理:  
    调用operator new 函数申请空间
    在申请的空间上执行构造函数,完成对象的构造
delete的原理:
    在空间上执行析构函数,完成对象中资源的清理工作在空间上执行析构函数,完成对象中资源的清理工作
new T[N]的原理:
    调用operator new[]函数,在operator new[]中实际调用operator new函数完成N个对象的申请
    在申请的空间上执行N次构造函数
delete[]的原理;
    在是否的对象空间上执行N次析构函数,完成N个对象中的资源的清理
    调用operator delete[]释放空间,实际在operator delete[]中调用operator delete来释放空间
```
malloc的实现方案：
```
1、malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。
2、调用 malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。
    然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。
    接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。
3、调用 free 函数时，它将用户释放的内存块连接到空闲链表上。
4、到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 
    那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，
    并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。
```
brk和mmap：
```
brk是将数据段(.data)的最高地址指针_edata往高地址推；
mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。
这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，
操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。
```


提供了malloc/free函数分配释放内存申请后系统的响应:
```
    栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
    堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，
        会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲 结点链表中删除，
        并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小
        这样，代码中的delete语句才能正确的释放本内存空间。
        另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
```        
申请大小的限制及生长方向
```
栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域
    即栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，
    栈的大小是2M，如果申请的空间超过栈的剩余空间时，将提示overflow。
    因此，能从栈获得的空间较小 。
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，
    自然是不连续的，而链表的遍历方向是由低地址向高地址。
    堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
```
申请效率的比较：
```
    栈由系统自动分配，速度较快。但程序员是无法控制的。
    堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
```
堆和栈中的存储内容
```
栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，
    然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。
    注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，
    最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
```
sizeof和strlen的区别
```
1、 sizeof是运算符，而strlen是函数；
2、 sizeof的用法是sizeof(参数)，这个参数可以是数组，指针，类型，对象，甚至是函数，
    其值在编译的时候就计算好了，
    strlen的参数必须是字符型指针（char*）,其值必须在函数运行的时候才能计算出来；
3、 sizeof的功能是获得保证能容纳实现的建立的最大对象的字节的大小，
    strlen的功能是返回字符串的长度，切记这里的字符串的长度是包括结束符的；
4、 当数组作为参数传递给函数的时候，传的是指针，而不是数组，传递数组的首地址；
```
C++中的指针参数传递和引用参数传递区别
```
指针参数传递特点:
    本质上是值传递，它所传递的是一个地址值。
    值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，
    会在栈中开辟内存空间以存放由主调函数传递进来的实参值，
    从而形成了实参的一个副本。
值传递的特点:
    被调函数对形式参数的任何操作都是作为局部变量进行的，
    不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。
-----------------------------------------------------------------
引用参数传递过程:
    被调函数的形式参数也作为局部变量在栈中开辟了内存空间，
    但是这时存放的是由主调函数放进来的实参变量的地址。
    被调函数对形参（本体）的任何操作都被处理成间接寻址，
    即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。
    因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。
------------------------------------------------------------------------------------
引用传递和指针传递异同点:
相同点:
    他们都是在被调函数栈空间上的一个局部变量，
不同点:    
    对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。
    对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。
    如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。
--------------------------------------------------------------------------------------
从编译的角度来讲:
    程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。
    指针变量在符号表上对应的地址值为指针变量的地址值，
    而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。
    符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），
    而引用对象则不能修改。
```
形参与实参的区别
```
1、 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。
    因此，形参只有在函数内部有效。 
    函数调用结束返回主调函数后则不能再使用该形参变量。
2、 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，
    它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，
    会产生一个临时变量。
3、 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。
4、 函数调用中发生的数据传送是单向的。
    因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
5、 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，
    他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，
    而实参内容不会改变
```
值传递与指针传递
```
值传递:
    有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象或是大的结构体对象，
    将耗费一定的时间和空间
指针传递：
    同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）
引用传递:
    同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）
总结:
    效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。
```
C++多态性
```
多态分为静态多态和动态多态
    静态多态是通过重载和模板技术实现,在编译的时候确定。
    动态多态通过虚函数和继承关系实现,执行动态绑定,在运行的时候确定。
```
动态多态实现有几个条件
```
1、虚函数
2、一个基类的指针或引用指向派生类的对象
```
虚函数表
```
存放位置:
    虚函数表的地址在每个对象的首地址
实现多态原理:
    每个对象的首地址都保存有该对象的虚函数表的指针,当基类指针调用虚函数时,能获取这个对象的虚函数表指针,
    根据该虚函数表指针即可查找出对应虚函数表中的虚函数；
    派生类重写虚函数时会覆盖基类虚函数表中的函数指针,当基类指针指向不同派生类时,同一个虚函数获取的不同
    派生类对象的虚函数表中的虚函数指针不同,所以会出现相同的基类指针调用虚函数表现不一致，这就是多态；
```
抽象类
```
包含纯虚函数的基类称为抽象类
抽象类为什么不能实例化？
纯虚函数相当于在虚函数表中插入一个位置,但是并没有插入对应的函数指针;
生成对象的时候，因为这个位置没办法赋值,所以没办法生成对象
```

虚函数可以声明为inline吗?
```
不能,原因如下:
虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。而内联函数用于提高效率。
内联函数的原理:
    在编译期间，对调用内联函数的地方的代码替换成函数代码。
    内联函数对于程序中需要频繁使用和调用的小函数非常有用。
虚函数:
    在运行时进行类型确定
一个在编译期确定一个在运行时确定,所以不行
```
析构函数能抛出异常
```
答案肯定是不能。 
C++标准指明析构函数不能、也不应该抛出异常
原因:
1、 如果析构函数抛出异常，则异常点之后的程序不会执行，
    如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，
    则这些动作不会执行，会造成诸如资源泄漏的问题。
2、 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，
    此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。
--------------------------------------------------------------------------------------
C++异常处理模型最大的特点和优势就是对C++中的面向对象提供了最强大的无缝支持。
那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所
导致的已经失效了的对象(也即对象超出了它原来的作用域)，并释放对象原来所分配的资源， 
这就是调用这些对象的析构函数来完成释放资源的任务，所以从这个意义上说，
析构函数已经变成了异常处理的一部分。
```
类成员初始化方式？
```
赋值初始化:
    通过在函数体内进行赋值初始化；
列表初始化:
    在冒号后使用初始化列表进行初始化。
这两种方式的主要区别在于：
    对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。
    列表初始化是给数据成员分配内存空间时就进行初始化,
    就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式
    (此表达式必须是括号赋值表达式),
    那么分配了内存空间后在进入函数体之前给数据成员赋值，
    就是说初始化这个数据成员此时函数体还未执行。 
```
为什么用成员初始化列表会快一些
```
方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。
 C++的赋值操作是会产生临时对象的。
 临时对象的出现会降低程序的效率。
```
成员列表初始化
```
必须使用成员初始化的四种情况
    当初始化一个引用成员时；
    当初始化一个常量成员时；
    当调用一个基类的构造函数，而它拥有一组参数时；
    当调用一个成员类的构造函数，而它拥有一组参数时；
成员初始化列表做了什么:
    编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，
    并且在任何显示用户代码之前；
    list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；
```
必须在构造函数初始化式里进行初始化的数据成员有哪些
```
常量成员:
    因为常量只能初始化不能赋值，所以必须放在初始化列表里面
引用类型:
    引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
没有默认构造函数的类类型:
    使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化
```
构造函数的执行顺序
```
一个派生类构造函数的执行顺序如下：
    ① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。
    ② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。
    ③ 类类型的成员对象的构造函数（按照初始化顺序）
    ④ 派生类自己的构造函数。
```

构造函数为什么不能为虚函数？
```
从存储空间角度:
    虚函数相应一个指向vtable虚函数表的指针，这个指向vtable的指针是存储在对象的内存空间的
    (对象首地址)。假设构造函数是虚的，就须要通过 vtable来调用，此时对象还没有实例化，内存没分配;
    是找不到虚函数表的，所以构造函数不能是虚函数。 
从使用角度:
    虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。
    构造函数是主动调用来初始化实例的,能够明确的知道应该调用什么构造函数，
    所以构造函数没有必要是虚函数。
从实现上看:
    vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数
从实际含义上看:
    构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。 
```
析构函数为什么要虚函数？
```
直接的讲: 
    C++中基类采用virtual虚析构函数是为了防止内存泄漏。
具体地说:
    如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
    假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，
    只会调用基类的析构函数，不会调用派生类的析构函数;
    在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏;
结论:
    为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。
```
构造函数的作用
```
构造函数只是起初始化值的作用，实例化一个对象的时候，可以通过实例去传递参数，
从主函数传递到其他的函数里面，这样就使其他的函数里面有值了
```

析构函数的作用，如何起作用？
 ```
析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；
特点：
    析构函数与构造函数同名，但该函数前面加~。 
    析构函数没有参数，也没有返回值，而且不能重载，
    在一个类中只能有一个析构函数。 
当撤销对象时，编译器也会自动调用析构函数。 
每一个类必须有一个析构函数，用户可以自定义析构函数，
也可以是编译器自动生成默认的析构函数。
一般析构函数定义为类的公有成员。(?)
 ```

构造函数和析构函数可以调用虚函数
```
可以,但不提倡
原因:
1、 构造函数和析构函数调用虚函数时都不使用动态联编，
    如果在构造函数或析构函数中调用虚函数，
    则运行的是为构造函数或析构函数自身类型定义的版本；
2、 因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，
    因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；
3、 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，
    然后再调用基类的析构函数。所以在调用基类的析构函数时，
    派生类对象的数据成员已经销毁，再调用子类的虚函数没有任何意义。
Effective 的解释是：
    派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。
    同样，进入基类析构函数时，对象也是基类类型。
    所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，
    所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。
```
构造函数的执行顺序？
```
1、 基类构造函数
    如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，
    而不是它们在成员初始化表中的顺序。
2、成员类对象构造函数
    如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，
    而不是它们出现在成员初始化表中的顺序。
3、 派生类构造函数。
```
析构函数的执行顺序？
```
1、 调用派生类的析构函数；
2、 调用成员类对象的析构函数；
3、 调用基类的析构函数。
```
构造函数内部干了啥？
拷贝构造干了啥？

什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？
```
虚表:
    函数的地址表,按照虚函数声明的顺序存储,如果子类覆盖父类函数,虚函数表中同样会覆盖;
虚表的第一项:
    基类虚函数的地址
```

深拷贝与浅拷贝？
```
浅复制:
    只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用
    即浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，
    那么浅复制出来的对象也会相应改变。
深复制:
    在计算机中开辟了一块新的内存地址用于存放复制的对象
```
C++模板是什么，底层怎么实现的？
```
编译器并不是把函数模板处理成能够处理任意类的函数；
编译器从函数模板通过具体类型产生不同的函数；
编译器会对函数模板进行两次编译：
    在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。
```
C语言struct和C++struct区别
```
C语言中：
    struct是用户自定义数据类型（UDT）
    struct是没有权限的设置的，且struct中只能是一些变量的集合体，
    可以封装数据却不可以隐藏数据，而且成员不可以是函数
    C中必须在结构标记前加上struct，才能做结构类型名
C++中:
    struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）。
    struct的成员默认访问说明符为public（为了与C兼容），class中的默认访问限定符为private，
    struct增加了访问权限，且可以和类一样有成员函数。
```
类如何实现只能静态分配(???)
```
静态分配:
    由编译器为对象在栈空间中分配内存
操作:
    把new、delete运算符重载为private属性
原因:
    只有使用new运算符，对象才会被建立在堆上，
    因此只要限制new运算符就可以实现类对象只能建立在栈上
```
类如何实现只能动态分配(???)
```
动态分配:
    使用new运算符为对象在堆空间中分配内存
操作:
    构造、析构函数设为protected属性，再用子类来动态创建
原因:过程分为两步:
    执行operator new()函数，在堆中搜索一块内存并进行分配;
    调用类构造函数构造对象

```

如果想将某个类用作基类，为什么该类必须定义而非声明？
```
派生类中包含并且可以使用它从基类继承而来的成员，
为了使用这些成员，派生类必须知道他们是什么。
```
什么情况会自动生成默认构造函数？
```
1、带有默认构造函数的类成员对象
    如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，
    那么编译器就为该类合成出一个默认构造函数。
2、 带有默认构造函数的基类，
    如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，
    那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；
3、 带有一个虚函数的类
4、 带有一个虚基类的类
5、 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。
    所有其他的非静态数据成员都不会被初始化。
```

抽象类
```
定义:
    称带有纯虚函数的类为抽象类
作用:
    作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，
    派生类将具体实现在其基类中作为接口的操作
注意:
    抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出
```

类什么时候会析构？
```
1、 对象生命周期结束，被销毁时；
2、 delete指向对象的指针时，或delete指向对象的基类类型指针，
    而其基类虚构函数是虚函数时；
3、 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。
```
为什么友元函数必须在类内部声明？
```
编译器必须知道谁能够访问类的私有部分
```
继承机制中对象之间如何转换？
```
指针和引用之间如何转换？
向上类型转换:
    将派生类指针或引用转换为基类的指针或引用被称为向上类型转换
    向上类型转换会自动进行，而且向上类型转换是安全的。
2向下类型转换:
    将基类指针或引用转换为派生类指针或引用被称为向下类型转换
    向下类型转换不会自动进行，因为一个基类对应几个派生类，
    所以向下类型转换时不知道对应哪个派生类，
    所以在向下类型转换时必须加动态类型识别技术。
    RTTI技术，用dynamic_cast进行向下类型转换。
```
组合与继承优缺点？
```
继承的缺点有以下几点：
1、 父类的内部细节对子类是可见的。
2、 子类从父类继承的方法在编译时就确定下来了，
    所以无法在运行期间改变从父类继承的方法的行为。
3、 高耦合,违背了面向对象的思想
    如果对父类的方法做了修改的话，则子类的方法必须做出相应的修改。  
组合的优点：
1、 当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。
2、 当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。
3、 当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。
组合的缺点：
1、 容易产生过多的对象。
2、 为了能组合多个对象，必须仔细对接口进行定义。
```
 C++四种类型转换
```
const_cast:
    用于将const变量转为非const
static_cast:
    对于各种隐式转换，非const转const，void*转指针等, static_cast能用于多态想上转化
    如果向下转能成功但是不安全，结果未知；
dynamic_cast:
    用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。
    只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，
    对于引用抛异常。
reinterpret_cast:
    是特意用于底层的强制转型，导致实现依赖（implementation-dependent）
    （就是说，不可移植）的结果，
    例如，将一个指针转型为一个整数。这样的强制转型在底层代码以外应该极为罕见
为什么不使用C的强制转换:
    C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。
```
内联函数有什么优点？内联函数与宏定义的区别？
```
宏定义:
    在预编译的时候就会进行宏替换；
内联函数:
    在编译阶段，在调用内联函数的地方进行替换，
    减少了函数的调用过程，但是使得编译文件变大。
内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译。
对比:
    内联函数相比宏定义更安全，内联函数可以检查参数，
    而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。
    使用宏定义函数要特别注意给所有单元都加上括号，
    #define MUL(a, b) a b，这很危险，正确写法：#define MUL(a, b) ((a) (b))
```
 C++内存管理
```
在c++中内存主要分为5个存储区：
栈:
    局部变量，函数参数等存储在该区
栈特点:
    由编译器自动分配和释放.栈属于计算机系统的数据结构，
    进栈出栈有相应的计算机指令支持，
    而且分配专门的寄存器存储栈的地址，效率分高，
    内存空间是连续的，但栈的内存空间有限。
堆:
    需要程序员手动分配和释放（new,delete），属于动态分配方式。
    内存空间几乎没有限制，内存空间不连续，因此会产生内存碎片。
如何分配:
    操作系统有一个记录空间内存的链表，当收到内存申请时遍历链表，
    找到第一个空间大于申请空间的堆节点，将该节点分配给程序，
    并将该节点从链表中删除。一般，系统会在该内存空间的首地址处记录本次分配的内存大小，
    用于delete释放该内存空间。
全局/静态存储区:
    全局变量，静态变量分配到该区，到程序结束时自动释放，
    包括DATA段（全局初始化区）与BSS段（全局未初始化段）。
    其中，初始化的全局变量和静态变量存放在DATA段，未初始化的全局变量和静态变量存放在BSS段。
    BSS段特点：
    在程序执行前BSS段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0.
文字常量区：
    存放常量，而且不允许修改。程序结束后由系统释放。
程序代码区：
    存放程序的二进制代码

学会迁移，可以说到malloc，从malloc说到操作系统的内存管理???
    说道内核态和用户态，然后就什么高端内存，slab层，伙伴算法，VMA可以巴拉巴拉了，接着可以迁移到fork()。???
```
定位内存泄露
```
1、 在windows平台下通过CRT中的库函数进行检测；
2、 在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置
3、 Linux下通过工具valgrind检测
```
C++11有哪些新特性
```
1、 关键字及新语法：auto、nullptr、for
2、 STL容器：std::array、std::forward_list、std::unordered_map、std::unordered_set
3、 多线程：std::thread、std::atomic、std::condition_variable
4、 智能指针内存管理：std::shared_ptr、std::weak_ptr
4、 其他：std::function、std::bind和lamda表达式
```
左值右值
```
左值:
    可以取地址的、有名字的就是左值
右值:
    不能取地址的、没有名字的就是右值（将亡值或纯右值）
右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）
纯右值:
    等同于我们在C++98标准中右值的概念，
    指的是临时变量和不跟对象关联的字面量值；
将亡值:
    C++11新增的跟右值引用相关的表达式
    通常是将要被移动的对象
    将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。
    在确保其他变量不再被使用、或即将被销毁时，
    通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。
左值引用:
    对一个左值进行引用的类型。
右值引用:
    对一个右值进行引用的类型
右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，
    通常需要std::move()将左值强制转换为右值
```
移动构造函数
```
移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，
    移动构造函数的初值是一个右值引用。意味着，
    移动构造函数的参数是一个右值或者将亡值的引用。
```

智能指针
```
实现原理:
    构造函数中计数初始化为1；
    拷贝构造函数中计数值加1；
    赋值运算符中，左边的对象引用计数减一，
    右边的对象引用计数加一；
    析构函数中引用计数减一；
    在赋值运算符和析构函数中，如果减一后为0，
    则调用delete释放对象
```
share_prt<T>与weak_ptr<T>的区别？

share_prt循环引用例子
```
两个share_prt互相引用,导致资源泄露
class A
{
    public:
    share_ptr<B> p;
};

class B
{
    public:
    share_ptr<A> p;
}
int main()
{
    while(true)
    {
        share_prt<A> pa(new A()); //pa的引用计数初始化为1
        share_prt<B> pb(new B()); //pb的引用计数初始化为1
        pa->p = pb; //pb的引用计数变为2
        pb->p = pa; //pa的引用计数变为2
    }
    //假设pa先离开，引用计数减一变为1，不为0因此不会调用class A的析构函数，因此其成员p也不会被析构，pb的引用计数仍然为2；
    //同理pb离开的时候，引用计数也不能减到0
    return 0;
}  
weak_ptr是一种弱引用指针，其存在不会影响引用计数，从而解决循环引用的问题  
```

weak_ptr unquie_ptr shar_ptr 的区别
```
shared_ptr:
    一个标准的共享所有权的智能指针,就是允许多个指针指向同一对象
    shared_ptr对象中不仅有一个指针指向某某对象，还拥有一个引用计数器，
    代表一共有多少指针指向了那个对象
unique_ptr:
    只能有一个unique_ptr指向一个给定的对象
    当unique_ptr被销毁,它所指的对象也会被销毁。
weak_ptr:
    shared_ptr的弱引用
```
weak_ptr shared_ptr 循环引用
```
强引用:
    一个强引用当被引用的对象活着的时候，这个引用也存在
    当至少有一个强引用，那么这个对象就不能被释放
弱引用:
    弱引用当引用的对象活的时候不一定存在
    弱引用它并不对对象的内存进行管理
weak_ptr只是提供了对管理对象一个访问手段
由于弱引用不更改引用计数，类似普通指针，
只要把循环引用的一方使用弱引用，即可解除循环引用
```

模板特化
```
模板特化分为全特化和偏特化，模板特化的目的就是对于某一种变量类型具有不同的实现，因此需要特化版本。
```

### STL

STL里的内存池实现
```
STL内存分配分为一级分配器和二级分配器
一级分配器:
    采用malloc分配内存
二级分配器:
    采用内存池。
内存池设计:
    分别给8k,16k,...,128k的内存片维护一个链表,每个链表的头节点有数组来维护
    需要分配的时候从何时的大小的链表中取下一块内存
    释放内存的时候,将内存结点归还给链表
```

红黑树
```
红黑树:
    一种平衡二叉查找树
与avl树区别:
    AVL树是完全平衡的，红黑树基本上是平衡的。
红黑树优势:
    红黑数是平衡二叉树，其插入和删除的效率都是N(logN)，
    与AVL相比红黑数插入和删除最多只需要3次旋转，
    而AVL树为了维持其完全平衡性，在坏的情况下要旋转的次数太多。
红黑树的定义:
    节点是红色或者黑色；
    父节点是红色的话，子节点就不能为红色；
    从根节点到每个页子节点路径上黑色节点的数量相同；
    根是黑色的，NULL节点被认为是黑色的。
```
set map注意点
```
set map 底层是红黑树,删除和新增只是移动树的结点
不会导致迭代器失效
因为红黑树是有序的,所以set map的key必须是可以比较大小的
如果是自定义类型作为key值,需要重载<运算符
```
array
```
特点:
    固定大小的顺序容器，保存以严格的线性顺序排列的特定数量的元素
```
vector
```
特点:
    可以改变大小的数组的序列容器
注意点:
    每次扩容的时候是上次大小的2倍,因此定义一个长度是必要的,以减少realloc次数
    clear并不会释放内存,调用swap，交换个空vector即可释放内存
    vector存储值时深拷贝
reserve和resize的区别:
---------------------------------------------------------------------------------------------
1、 reserve是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back），
    就可以提高效率，其次还可以减少多次要拷贝数据的问题。
2、 reserve只是保证vector中的空间大小（capacity）最少达到参数所指定的大小n。reserve()只有一个参数。
3、 resize()可以改变有效空间的大小，也有改变默认值的功能。capacity的大小也会随着改变。resize()可以有多个参数
----------------------------------------------------------------------------------------------------
size和capacity的区别：
```
    size表示当前vector中有多少个元素（finish - start）;
    capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage - start）;
```
vector中erase方法与algorithn中的remove方法区别
----------------------------------------------------------
1、 vector中erase方法真正删除了元素，迭代器不能访问了
2、 remove只是简单地将元素移到了容器的最后面，迭代器还是可以访问到。
    因为algorithm通过迭代器进行操作，不知道容器的内部结构，
    所以无法进行真正的删除
----------------------------------------------------------
vector迭代器失效的情况
----------------------------------------------------------------------------
1、 当插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。
2、 当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。
3、 erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it);。
------------------------------------------------------------------------------------
正确释放vector的内存(clear(), swap(), shrink_to_fit())
-------------------------------------------------------------------
1、 vec.clear()：清空内容，但是不释放内存。
2、 vector<int>().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。
3、 vec.shrink_to_fit()：请求容器降低其capacity和size匹配。
4、 vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。
------------------------------------------------------------------------
erase: 
    如果vector存内存地址,erase并不会对对应的内存进行处理,需要手工释放内存后
    在删除
-------------------------------------------------------------------------
```
STL的Vector原理及迭代器失效的理解。
```
迭代器失效: 
1、 当使用一个容器的insert或者erase函数通过迭代器插入或删除元素"可能"会导致迭代器失效
    因此我们为了避免危险，
2、 应该获取insert或者erase返回的迭代器，以便用重新获取的新的有效的迭代器进行正确的操作 
迭代器失效的类型：
1、 由于插入元素，使得容器元素整体“迁移”导致存放原容器元素的空间不再有效，
    从而使得指向原空间的迭代器失效。
2、 由于删除元素使得某些元素次序发生变化使得原本指向某元素的迭代器不再指向希望指向的元素。
```
sort note
```
 sort算法要求(Strict WeakOrdering原则), 如果两个对象相等，
 必须返回false。否则算法会造成访问越界奔溃
```

谈谈std::move的理解和使用
```
std::move和std::forward仅仅是进行类型转换的函数
std::move无条件的将其参数转换为右值
std::forward只在必要情况下进行这个转换
-------------------------------------------------------------
move的功能:
1、 std::move执行一个无条件的转化到右值。它本身并不移动任何东西；
2、 std::forward把其参数转换为右值，仅仅在那个参数被绑定到一个右值时；
3、 std::move和std::forward在运行时（runtime）都不做任何事。
----------------------------------------------------------------
为什么使用move而不是copy：
1、 提高效率,某些情况下不需要copy，直接移动就行,如vector数组就不需要copy
2、 IO类或unique_ptr包含不能共享的资源,这些对象不能拷贝,只能移动
-----------------------------------------------------------------
移动的是堆上内存的所有权，其他类型的与拷贝没什么区别
```
关于new和malloc以及delete和frees是否可以混用
```
当申请的空间是内置类型时，delete和free可以混用
当申请的空间是自定义类型时:
1、 若没有析构函数，delete和malloc可以混用，有[]和没有[]都相同
2、 若申请的空间有析构函数时，malloc申请的空间可以用delete和free释放，
    但是用delete释放时不能加[]
3、 若申请的空间有析构函数时，new申请的空间不能用free释放，可以用delete释放，
    但是释放时必须加上[]
```
STL的Map基于红黑树实现的原因，为什么不选择哈希表
```
1、 map始终保证遍历的时候是按key的大小顺序的，
    这是一个主要的功能上的差异
2、 map可以做范围查找，而unordered_map不可以。
3、 map的iterator除非指向元素被删除，否则永远不会失效。
    unordered_map的iterator在对unordered_map修改时有时会失效。
4、 因为3，所以对map的遍历可以和修改map在一定程度上并行，
    而对unordered_map的遍历必须防止修改
    map的iterator可以双向遍历，这样可以很容易查找到当前map中刚好大于这个key的值，
    或者刚好小于这个key的值
```
map[]和find的区别
```
map的下标运算符[]:
    将关键码作为下标去执行查找，并返回对应的值；
    如果不存在这个关键码，就将一个具有该关键码和值类型的
    默认值的项插入这个map。
find: 
    用关键码执行查找，找到了返回该位置的迭代器；
    如果不存在这个关键码，就返回尾迭代器
find更快 不需要插入值 
```
deque
```
特点:
    一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素
    并且能够高效地插入和删除容器的尾部元素
备注:
    实际是由一段一段的定量连续空间构成。
    一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，
    串接在整个deque的头端或尾端

```
list
```
list是双链表，forward_list是单链表
forward_list特点:
1、 只提供钱箱迭代器，因此不支持反向迭代器，比如rbegin()等成员函数。
2、 不提供size（）成员函数。
3、 没有指向最末元素的锚点，因此不提供back（）、push_back（）和pop_back（）。
4、 不提供随机访问，这一点跟list相同。
5、 允许在序列中的任何地方进行恒定的时间插入和擦除操作
list特点:
    允许在序列中的任何地方进行常数时间插入和擦除操作，
    并在两个方向上进行迭代,可以高效地进行插入删除元素
```
stack
```
特点:
    没有迭代器，是一种容器适配器，用于在LIFO（后进先出）的操作，
    其中元素仅从容器的一端插入和提取
    底层一般用list或deque实现，封闭头部即可，
    不用vector的原因应该是容量大小有限制，扩容耗时
```
堆
```
定义：
1、 是一颗完全二叉树；
2、 某个节点的值总是不大于或不小于其孩子节点的值；
3、 每个节点的子树都是堆树。
最大堆:
    父节点的键值总是大于或等于任何一个子节点的键值
最小堆:
    父节点的键值总是小于或等于任何一个子节点的键值
```
queue
```
特点:
    一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。
    队列不提供迭代器，不实现遍历操作。
优先队列:
    其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个
```
set
```
定义:
    按照特定顺序存储唯一元素的容器
特点:
1、 对set进行插入删除操作 都不会引起iterator的失效
    因为迭代器相当于一个指针指向每一个二叉树的节点，对set的插入删除并不会改变原有内存中节点的改变
2、 检索速度很快，因为采用二分查找的方法
```
map
```
定义:
    关联容器,按照特定顺序存储由key value (键值) 和 mapped value (映射值) 组合形成的元素
```
为何map和set的插入删除效率比其他序列容器高
```
因为不需要内存拷贝和内存移动
```

map和set删除插入效率高且iterator不会失效
```
因为插入操作只是结点指针换来换去，结点内存没有改变。
而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。
存储的是结点，不需要内存拷贝和内存移动。
插入操作只是结点指针换来换去，结点内存没有改变。
而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。
```
map 、set、multiset、multimap的特点
```
set和multiset会根据特定的排序准则自动将元素排序，
set中元素不允许重复，multiset可以重复。
map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序
map中元素的key不允许重复，multimap可以重复。
map和set的增删改查速度为都是logn，是比较高效的。
```
hash_map与map的区别 
```
构造函数:
    hash_map需要hash function和等于函数，而map需要比较函数（大于或小于）。
存储结构:
    hash_map以hashtable为底层，而map以RB-TREE为底层。
总结:
    hash_map查找速度比map快，而且查找速度基本和数据量大小无关，属于常数级别。
    而map的查找速度是logn级别。但不一定常数就比log小，
    而且hash_map还有hash function耗时。
    如果考虑效率，特别当元素达到一定数量级时，用hash_map。
    考虑内存，或者元素数量较少时，用map。
```
vector、list、deque、priority_queue区别
```
vector:
    可以随机存储元素，但在非尾部插入删除数据时，
    效率很低，适合对象简单，对象数量变化不大，
    随机访问频繁。除非必要，我们尽可能选择使用vector而非deque，
    因为deque的迭代器比vector迭代器复杂很多。
list:
    不支持随机存储，适用于对象大，对象数量变化频繁，
    插入和删除频繁，比如写多读少的场景。
deque: 
    需要从首尾两端进行插入或删除操作的时候需要选择deque。
priority_queue:
    优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。
```
线程不安全的情况
```
    在对同一个容器进行多线程的读写、写操作时；
    在每次调用容器的成员函数期间都要锁定该容器；
    在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器；
    在每个在容器上调用的算法执行期间锁定该容器。
```
Hash表实现（拉链和分散地址）
```
开链法: 
    使用数组链表的方式来保存数据,建立一个数据，每个数组的元素是一个链表
分散地址法: 
    出现冲突时,使用通过查找数组空位而不是通过哈希函数来获取数组下标
```
Hash策略常见的有哪些？
```
线性探测法: 
    查找距离冲突单元最近的空闲单元保存
二次探测法: 
    避免聚簇；从冲突位置将搜索单元向前推进一定的距离
双重哈希法: 
    引入两个hash函数,使偏移到下一个位置与key值相关
随机散列法: 
    探测序列是由密钥播种的伪随机数生成器的输出生成
```
STL中hash_map如何扩容
```
1、 创建一个新桶，该桶是原来桶两倍大最接近的质数
2、 将原来桶里的数通过指针的转换，插入到新桶中
3、 通过swap函数将新桶和旧桶交换，销毁新桶。
```

|容器|底层数据结构|时间复杂度|有无序|是否可重复|
|----|-----------|---------|-----|---------|
|array|数组|随机读改O(1)|无序|可重复|
|vector|数组|随机读改,尾部插入，尾部删除O(1)头部插入、头部删除O(n)|无序|可重复|
|dequeue|双端队列|头尾插入、头尾删除O(1)|无序|可重复|
|forward_list|单向链表|插入删除O(1)|无序|可重复|
|list|双向链表|插入删除O(1)|无序|可重复|
|stack|deque/list|顶部插入、顶部删除O(1)|无序|可重复|
|queue|deque/list|尾部插入、头部删除O(1)|无序|可重复|
|priority_quue|vector/max-heap|插入、删除O(logn)|有序|可重复|
|set|红黑树|插入、删除、查找O(logn)|有序|不可重复|
|----|-----------|---------|-----|---------|

队列和栈的区别
```
相同点:
    都是线性结构
    插入操作都是限定在表尾进行
    都可以通过顺序结构和链式结构实现
    插入和删除的时间复杂度都是O(1),空间复杂度上也一样
    多链栈和多链队列的管理模式可以相同
不同点:
    删除数据元素的位置不同,栈的删除操作在表尾队列的删除操作在表头
    顺序栈能够实现多栈空间共享,顺序队列不能
    应用场景不同
```
典型的应用场景
```
栈的应用场景:
    括号问题的求解 表达式的转换和求值 函数调用和递归实现 深度优先搜索遍历
队列的应用场景
    各种资源的管理 消息缓冲器管理  广度游戏搜索遍历
```

如何设计一个C++类？实现String类。
```
class String
{

public:
    String(const char *str = NULL);            //通用构造函数
    String(const String &str);                 //拷贝构造函数
    ~String();                                 //析构函数
    String operator+(const String &str) const; //重载+
    String &operator=(const String &str);      //重载+
    String &operator+=(const String &str);     //重载+
    bool operator==(const String &str) const;  //重载+
    char &operator[](int n) const;             //重载[]
    size_t size() const;                       //获取长度
    const char *c_str() const;                 //获取C字符串
private:
    char *data;
    size_t length;
};

String::String(const char *str)
{
    if (str == NULL)
    {
        length = 0;
        data = new char[1];
        *data = '\0';
    }
    else
    {
        length = strlen(str);
        data = new char[length + 1];
        strcpy(data, str);
    }
}

String::String(const String &str)
{
    length = str.length;
    data = new char[length + 1];
    strcpy(data, str.c_str());
}

String::~String()
{
    delete[] data;
    length = 0;
}

String String::operator+(const String &str) const
{
    String newStr;
    newStr.length = length + str.length;
    newStr.data = new char[newStr.length + 1];
    strcpy(newStr.data, data);
    strcat(newStr.data, str.c_str());
    return newStr;
}

String &String::operator=(const String &str)
{
    if (this == &str)
        return *this;
    delete[] data;
    data = new char[str.length + 1];
    length = str.length;
    strcpy(data, str.c_str());
    return *this;
}

bool String::operator==(const String &str) const
{
    if (length != str.length)
        return false;
    return strcmp(data, str.data) ? false : true;
}

char &String::operator[](int n) const
{
    if (n > length)
        return data[length - 1];
    else
    {
        return data[n];
    }
}

size_t String::size() const
{
    return length;
}

const char *String::c_str() const
{
    return data;
}
```

### 编程基础

手写strcpy
```
char strcpy(char dst, const char src)
{
    assert(dst);
    assert(src);
    char ret = dst;
    while((dst++ = src++) != '\0');
    return ret;
}
//该函数是没有考虑重叠的
char strcpy(char dst, const char src)
{
    assert((dst != NULL) && (src != NULL));
    char ret = dst;
    int size = strlen(src) + 1;
    if(dst > src || dst < src + len)
    {
        dst = dst + size - 1;
        src = src + size - 1;
        while(size--)
        {
            dst-- = src--;
        }
    }
    else
    {
        while(size--)
        {
            dst++ = src++;
        }
    }
    return ret;
}
```
手写memcpy函数
```
void memcpy(void dst, const void src, size_t size)
{
    if(dst == NULL || src == NULL)
    {
        return NULL;
    }
    void res = dst;
    char pdst = (char)dst;
    char psrc = (char)src;
    if(pdst > psrc && pdst < psrc + size) //重叠
    {
        pdst = pdst + size - 1;
        psrc = pdst + size - 1;
        while(size--)
        {
            *pdst-- = *psrc--;
        }
    }
    else //无重叠
    {
        while(size--)
        {
            *dst++ = *src++;
        }
    }
    return ret;
}
```
手写strcat函数
```
char strcat(char dst, const char src)
{
    char ret = dst;
    while(*dst != '\0')
        ++dst;
    while((*dst++ = *src) != '\0');
    return ret;
}
```
手写strcmp函数
```
int strcmp(const char str1, const char str2)
{
    while(*str1 == *str2 && *str1 != '\0')
    {
        ++str1;
        ++str2;
    }
    return *str1 - *str2;
}
```
判断大小端
```
union un
{
int i;
char ch;
};

void fun()
{
    union un test;
    test.i = 1;
    if(ch == 1)
    cout << "小端" << endl;
        else
    cout << "大端" << endl;
}
```