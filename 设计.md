### 如何设置一个延迟队列

定义: 
    与普通队列相比,延迟队列的元素入队时会指定一个延时时间,表示其希望能够在经过该指定时间后处理。从某种意义上来讲,延迟队列的结构并不像一个队列,
    更像一个以时间为权重的有序堆结构
应用场景:
    包含不同延迟时间的任务,如下列情况:
```
    新建的订单，如果用户在 15 分钟内未支付，则自动取消。
    公司的会议预定系统，在会议预定成功后，会在会议开始前半小时通知所有预定该会议的用户。
    安全工单超过 24 小时未处理，则自动拉企业微信群提醒相关责任人。
    用户下单外卖以后，距离超时时间还有 10 分钟时提醒外卖小哥即将超时。
``` 
实现方案：
    使用redis的zset数据结构,zset每个元素都有一个对应score，zset总所有元素是按照其score进行排序的
----------------------------------------------------------------------------------------------
    rabbitMQ:
        RabbitMQ 本身并不直接提供对延迟队列的支持，我们依靠 RabbitMQ 的TTL以及死信队列功能，来实现延迟队列的效果
    ```
    死信队列: 消息被拒绝,TTL过期了，消息队列达到最大长度 这样的消息被称为死信, 消息一变为死信,就会被转发到对应的死信队列上，监听该队列可以重新被消费
    ```
    设置消息TTL为延时时间,一直不去消费，延时时间过后,该消息就会投递到死信队列中,同时使用消费者进程实时的消费死信队列；
-------------------------------------------------------------------------------------------------
   TimeWheel:
        时间轮算法, 有一个数组来表示时间，每个数组对应一个双向链表；
-------------------------------------------------------------------------------------------------

#### 设计一个C++HashMap类

```
hash_map基于hash table（哈希表）
哈希表最大的优点: 
    就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；
    而代价仅仅是消耗比较多的内存。
    然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。
    编码比较容易也是它的特点之一
基本原理:
    使用一个下标范围比较大的数组来存储元素。
    可以设计一个函数（哈希函数，也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应，
    于是用这个数组单元来存储这个元素；也可以简单的理解为，
    按照关键字为每一个元素“分类”，然后将这个元素存储在相应“类”所对应的地方，称为桶。 
    “直接定址”与“解决冲突”是哈希表的两大特点
    
```

#### bitmap原理
```
bitmap 实质上是把每个值的位(bit)拼接起来,组成一个长度足够长的数组,
如果某个值存入bitmap,就在bitmap找到对应的位设置位1,这即代表这个值；
一般使用int类型的数组来实现bitmap,一个int值包含4*8=32位,存储一个数字时,
先确定目标值在数组的对应位置,然后与这个值进行位运算
index = value%/32
inter = value/32
vector[index] = vector[index]|inter
其中:
    index代表数组对应的索引
    inter 代表索引值存储的位
计算数组位存储的某个值：
value = 32*index + inter
```
阻塞队列设计
```
原理:
    入队出队操作时阻塞的,只有一个成员入队或出队的操作完成后,
    才能执行下一个成员的入队或出队操作
实现:
    使用条件变量和互斥锁实现,入队是判断队列释放已满,
    已满则等待出队操作后才能入队;
    同理出队时判断队列是否为空,为空时等待入队操作后才能
    执行出队操作
    需要注意的时需要有个退出标志,当标志为真时,入队出队操作
    都不在执行,同时释放互斥锁,避免阻塞在空队列中
```
线程池设计
```
原理:
    事先创建若干个可执行的线程放入一个池(容器)中，
    需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，
    从而减少创建和销毁线程对象的开销。
实现:
    初始化数量m的线程,从认为队列中获取任务执行,
    如果任务队列满了且线程池数量未达到最大值,创建线程放入线程池；
    如果任务队列满了且线程池数量达到最大值,拒绝任务,返回false
    如果任务队列未满,且线程池数量大于线程池最小值,释放线程池的线程
    直到线程池数量为最小数量

```

