
### C++基础
extern 关键字的作用

```
    extern声明变量在外部的定义？
        1、 全局变量如果不在文件开始定义,则其作用域有效区域为定义部分到文件结尾,之前的部分如果需要使用全局变量,需要使用extern声明
        2、 如果多个文件公用一个全局变量,在非定义文件中需要使用extern声明
    extern 修饰函数？
        与修饰变量作用类似,如果在一个文件中定义了函数func1，在另一个文件中可以使用extern声明这个函数，然后直接调用;不需要包含头文件；一般使用在较小的文件中，较大的文件通过头文件来使用；
    extern C的作用
        为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后,会指示编译器这部分代码按C语言的方式进行编译。由于C++支持函数重载,因此编译器编译函数的过程中会将函数的参数类型加到编译后的代码中,而不仅仅是函数名;而C语言不支持函数重载,因此编译C语言代码不会带上函数的参数类型,一般只包含函数名；
```

为什么要使用字节对齐
```
字节对齐是C/C++编译器的一种技术手段，主要是在可接受空间浪费的前提下，尽可能地提高对相同元素过程的快速处理。
（比如32位系统，4字节对齐能使CPU访问速度提高）
需要字节对齐的根本原因在于CPU访问数据的效率问题。
    因为现代计算机都使用了Cache。Cache可以看成一些可以用非常快的速度进行访问的临时内存。但是Cache的容量不大，CPU访问内存非常慢，
    所以硬件会将平时经常使用的内容存放到Cache里面。Cache是通过一些Cache Line来组织的，每一条Cache Line一般包含16个字节，32个字节或64个字节等。 
    比如某个计算机一级Cache的Cache Line长度是32个字节，那么每段Cache Line总是会包含32个字节对齐的一段内存。
    现在有一个4字节的整数，如果它的地址不是4字节对齐的，那么就有可能访问它的时候，需要使用两条Cache Line,这增加了总线通讯量，而且增加了对Cache的使用量，
    而且使用的数据没有在Cache里面（这时需要将数据从内存调入Cache,会非常慢）的机会会增加，这些都降低了程序的速度。
字节对齐的原则
    从0位置开始存储；
    变量存储的起始位置是该变量大小的整数倍；
    结构体总的大小是其最大元素的整数倍，不足的后面要补齐；
    结构体中包含结构体，从结构体中最大元素的整数倍开始存；
    如果加入pragma pack(n) ，取n和变量自身大小较小的一个。
```
C++11有哪些新特性
```
    1）关键字及新语法：auto、nullptr、for
    2）STL容器：std::array、std::forward_list、std::unordered_map、std::unordered_set
    3）多线程：std::thread、std::atomic、std::condition_variable
    4）智能指针内存管理：std::shared_ptr、std::weak_ptr
    5）其他：std::function、std::bind和lamda表达式
```
引用和指针的区别？
```
1) 指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。
2) 引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）
3) 有多级指针，但是没有多级引用，只能有一级引用。
4) 指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）
5) sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。
6) 引用访问一个变量是直接访问，而指针访问一个变量是间接访问。
7) 使用指针前最好做类型检查，防止野指针的出现；
8) 引用底层是通过指针实现的；
9) 作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。
```

指针与数组千丝万缕的联系
```
    一个一维int数组的数组名实际上是一个int* const 类型；
    一个二维int数组的数组名实际上是一个int (*const p)[n];
    数组名做参数会退化为指针，除了sizeof
```
静态变量什么时候初始化
```
1) 初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。
2) 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。
    在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，
    变量所处的全局内存会被全部回收。
    在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，
    在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，
    并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。
    所以在C++中是可以使用变量对静态局部变量进行初始化的。
```
指针和const的用法
```
1) 当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。
2) int const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过p2读写这个变量的值。顶层指针表示指针本身是一个常量
3) int const *p1或者const int p1两种情况中const修饰p1，所以理解为p1的值不可以改变，即不可以给p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。底层指针表示指针所指向的变量是一个常量。
4) int const *const p;
```
5. C++中的指针参数传递和引用参数传递
```
1) 指针参数传递本质上是值传递，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。
2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。
3) 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。
4) 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。
```
6. 形参与实参的区别？
```
1) 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。
2) 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。
3) 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。
4) 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
5) 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。
    1) 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象  或是大的结构体对象，将耗费一定的时间和空间。（传值）
    2) 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）
    3) 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）
    4) 效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。
```
7. static的用法和作用？
```
1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。
2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
    共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。
3.static的第三个作用是默认初始化为0（static变量）其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。
    在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。
4.static的第四个作用：
    C++中的类成员声明static
        1) 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值； 
        2) 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；  
        3) 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；  
        4) 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；  
        5) 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。类内：
        6) static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；
        7) 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，
            所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；
        8) static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，
            虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function

-----------------------------------------------------------------------------------------------------------------------------------------------
    static 修饰全局变量
        限定变量使用范围只能在本文件中使用,即使使用extern外部声明也不可以在其他文件内使用；
    static 修饰普通函数
        限定使用范围,这个函数只能在本文件内使用,不能被其他文件调用.
    static 修饰成员变量
        static成员变量属于类,不属于某个具体的对象,即使创建多个对象,所有对象使用的都是这份内存中的数据,当某个对象修改这个变量,其他对象也会影响其他对象
        static成员变量必须在类声明的外部初始化,具体形式为:  type class::name = value
        静态成员变量初始化时不能再加static 但必须要有数据类型
        static成员变量的内存既不是在声明类时分配,也不是在创建对象时分配,而是在初始化时分配；
        static既可以通过类直接访问 Class::static 也可以通过Object.static访问,也可以Point->static访问
        这三种方式等效
        static成员变量不占用对象的内存,而是在所有对象之外开辟内存,即使不创建对象也可以访问

    static 修饰成员函数
        1. static成员函数不包含this指针，所以static成员函数不能访问非static类成员,只能访问static修饰的类成员
        2.static成员函数不能定义为const的，static函数不能访问非静态成员变量(备注:编译错误 static member function  cannot have cv-qualifier)   
引用:
    2.1 总的来说
    （1）在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
    （2）static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。
    （3）static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。
    （4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。
    （5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。
    2.2 静态变量与普通变量
    静态全局变量有以下特点：

    （1）静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量;
    （2）未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；
    （3）静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。
    优点：静态全局变量不能被其它文件所用；其它文件中可以定义相同名字的变量，不会发生冲突。

    （1）全局变量和全局静态变量的区别
    1）全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。
    2）全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。
    2.3 静态局部变量有以下特点：
    （1）该变量在全局数据区分配内存；
    （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
    （3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；
    （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。
    一般程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。


    static 修饰局部变量 
        存储区: 由栈变为静态存储区,生存期为整个源程序,只能在定义该变量的函数内使用.退出该函数后,尽管变量还继续存在,但不能使用他；
        作用域: 作用域仍为局部作用域,当定义它的函数或者语句块结束的时候,作用域随之结束.
    static 修饰对象,如果类生命了构造函数,则会调用类的构造函数来初始化对象,如果没有的话,不会合成默认构造函数,但是依然会初始化,类的内置类型成员与普通内置类型初始化相同； 
```
8. volatile的作用是什么
```
        1. 访问寄存器要比访问内存快,因此CPU会优先访问该数据在寄存器中的存储效果,但是内存中的数据可能已经发生改变,而寄存器中还保留着原来的结果.为了避免这种情况的发生,将该变量声明为volatile,告诉cpu每次都从内存去读取数据.
        2. 一个参数可以即是const又是volatile的吗？ 可以
```    
9. const的作用: 
```
        1. const 修饰全局变量
        2. const 修饰局部变量
        3. const 修饰指针const int *;
        5. const 修饰指针指向的对象 int * const
        6. const 修饰成员变量,必须在构造函数列表中初始化
        7. const 修饰成员函数,说明该函数不应该修改非静态成员,但是这并不十分可靠,指针所指的非静态成员可能会被改变
 ```   
10. new与malloc的区别: 验证下 operator new delete 与 delete new的效果
```
        1. new分配内存按照数据类型进行分配,malloc分配内存按照大下分配；
        2. new不仅分配一段内存,而且会调用构造函数,但是malloc不会；
            解析:
            new实现的原理:  
                调用operator new 函数申请空间
                在申请的空间上执行构造函数,完成对象的构造
            delete的原理:
                在空间上执行析构函数,完成对象中资源的清理工作在空间上执行析构函数,完成对象中资源的清理工作
            new T[N]的原理:
                调用operator new[]函数,在operator new[]中实际调用operator new函数完成N个对象的申请
                在申请的空间上执行N次构造函数
            delete[]的原理;
                在是否的对象空间上执行N次析构函数,完成N个对象中的资源的清理
                调用operator delete[]释放空间,实际在operator delete[]中调用operator delete来释放空间

        3. new返回的是指定对象的指针,而malloc返回的是void*
        4. new是一个操作符可以重载,malloc是一个库函数
        5. new分配的内存要用delete销毁,malloc要用free来销毁;delete销毁的时候会调用对象的析构函数,而free不会
        6. malloc分配的内不够的时候,可以用realloc扩容(扩容的原理？) new没有这样的操作
        7. new如果分配失败了会抛出bad_malloc的异常,而malloc失败了会返回NULL。因此对于new，正确的字试是采用try...catch语法,而malloc则应该判断指针的返回值,为了兼容很多c语言程序员的习惯,c++也可以采用new nothrow的方法禁止抛出异常返回NULL;
        8. new和new[] 的区别,new[]一次分配所有内存,多次调用构造函数;分别搭配使用delete和delete[].
        9. 谈谈new和malloc的实现,空闲链表,分配方法(首次适配原则,最佳视频原则,最差适配原则,快速适配原则)。delete和free实现原理；free为什么知道销毁多大的空间;

    malloc的实现方案：
        1）malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。
        2）调用 malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。
        3）调用 free 函数时，它将用户释放的内存块连接到空闲链表上。
        4）到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。

    brk和mmap：从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。
        1、brk是将数据段(.data)的最高地址指针_edata往高地址推；
        2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。
    申请后系统的响应
        栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
        堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲 结点链表中删除，
            并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。
            另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
    申请大小的限制及生长方向
        栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，
            栈的大小是2M（也可能是1M，它是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。
            因此，能从栈获得的空间较小 。
        堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。
            堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
    申请效率的比较：
        栈由系统自动分配，速度较快。但程序员是无法控制的。
        堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
    堆和栈中的存储内容
    栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，
        参数是由右往左入栈的，然后是函数中的局部变量。
        注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
```
11. sizeof和strlen的区别
```
1 sizeof是运算符，而strlen是函数；
2 sizeof的用法是sizeof(参数)，这个参数可以是数组，指针，类型，对象，甚至是函数，其值在编译的时候就计算好了，而strlen的参数必须是字符型指针（char*）,
    其值必须在函数运行的时候才能计算出来；
3 sizeof的功能是获得保证能容纳实现的建立的最大对象的字节的大小，而strlen的功能是返回字符串的长度，切记这里的字符串的长度是包括结束符的；
4 当数组作为参数传递给函数的时候，传的是指针，而不是数组，传递数组的首地址；
```

12. C++多态性和虚函数表
```
       多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现,在编译的时候确定。
       动态多态通过虚函数和继承关系实现,执行动态绑定,在运行的时候确定。
       动态多态实现有几个条件:
        1. 虚函数
        2. 一个基类的指针或引用指向派生类的对象

            基类指针在调用成员函数(虚函数)时,就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。
            查找该虚函数表中该函数的指针进行调用。每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，
            该类的对象的都指向这同一个虚函数表。虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，
            虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。
        虚函数实现原理：
            虚函数表和虚函数指针。纯虚函数： virtual int fun() = 0;函数的运行版本由实参决定，在运行时选择函数的版本，所以动态绑定又称为运行时绑定。当编译器遇到一个模板定义时，它并不生成代码。只有当实例化出模板的一个特定版本时，编译器才会生成代码。
```
13. 虚函数可以声明为inline吗?
```
1)  虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。
    而内联函数用于提高效率。内联函数的原理是，在编译期间，对调用内联函数的地方的代码替换成函数代码。
    内联函数对于程序中需要频繁使用和调用的小函数非常有用。
2)  虚函数要求在运行时进行类型确定，而内敛函数要求在编译期完成相关的函数替换；
```

50. 虚函数的作用？
```
    虚函数用于实现多态，这点大家都能答上来
    但是虚函数在设计上还具有封装和抽象的作用。比如抽象工厂模式。(实现下)
    动态绑定是如何实现的？
    第一个问题中基本回答了，主要都是结合虚函数表来答就行。
    静态多态和动态多态。静态多态是指通过模板技术或者函数重载技术实现的多态，其在编译器确定行为。动态多态是指通过虚函数技术实现在运行期动态绑定的技术。

    虚函数表
        虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？
        编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。
    纯虚函数如何定义，为什么对于存在虚函数的类中析构函数要定义成虚函数
        为了实现多态进行动态绑定，将派生类对象指针绑定到基类指针上，对象销毁时，如果析构函数没有定义为析构函数，
        则会调用基类的析构函数，显然只能销毁部分数据。
        如果要调用对象的析构函数，就需要将该对象的析构函数定义为虚函数，销毁时通过虚函数表找到对应的析构函数。
        纯虚函数定义
        virtual ~myClass() = 0;
```

51. 析构函数能抛出异常吗
```
    答案肯定是不能。 
    C++标准指明析构函数不能、也不应该抛出异常。
    C++异常处理模型最大的特点和优势就是对C++中的面向对象提供了最强大的无缝支持。
    那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象(也即对象超出了它原来的作用域)，
    并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，
    所以从这个意义上说，析构函数已经变成了异常处理的一部分。
    (1) 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，
        则这些动作不会执行，会造成诸如资源泄漏的问题。
    (2) 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，
        则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。
```

14. 类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？
```
1)  赋值初始化，通过在函数体内进行赋值初始化；
    列表初始化，在冒号后使用初始化列表进行初始化。
    这两种方式的主要区别在于：
        对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。
        列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),
        那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。 
2)  一个派生类构造函数的执行顺序如下：
    ① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。
    ② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。
    ③ 类类型的成员对象的构造函数（按照初始化顺序）
    ④ 派生类自己的构造函数。
3) 方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。
    我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。
```
15. 成员列表初始化？
```
1) 必须使用成员初始化的四种情况
    ① 当初始化一个引用成员时；
    ② 当初始化一个常量成员时；
    ③ 当调用一个基类的构造函数，而它拥有一组参数时；
    ④ 当调用一个成员类的构造函数，而它拥有一组参数时；
2) 成员初始化列表做了什么
    ① 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；
    ② list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；
```

16. 必须在构造函数初始化式里进行初始化的数据成员有哪些
```
    (1) 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
    (2) 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
    (3) 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化
```

17. 构造函数为什么不能为虚函数？析构函数为什么要虚函数？
```
1.  从存储空间角度，虚函数相应一个指向vtable虚函数表的指针，这大家都知道，但是这个指向vtable的指针事实上是存储在对象的内存空间的。
    问题出来了，假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？
    所以构造函数不能是虚函数。 
2.  从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。
    构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。
    虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。
    而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。 
3.  构造函数不须要是虚函数，也不同意是虚函数，由于创建一个对象时我们总是要明白指定对象的类型，
    虽然我们可能通过实验室的基类的指针或引用去訪问它但析构却不一定，我们往往通过基类的指针来销毁对象。
    这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。 
4.  从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数从实际含义上看，
    在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；
    并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。 
5.  当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR。
    因此，它仅仅能知道它是“当前”类的，而全然忽视这个对象后面是否还有继承者。
    当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（由于类不知道谁继承它）。
    所以它使用的VPTR必须是对于这个类的VTABLE。并且，仅仅要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE,
    但假设接着另一个更晚派生的构造函数被调用，这个构造函数又将设置VPTR指向它的 VTABLE，等.直到最后的构造函数结束。
    VPTR的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的还有一个理由。
    可是，当这一系列构造函数调用正发生时，每一个构造函数都已经设置VPTR指向它自己的VTABLE。
    假设函数调用使用虚机制，它将仅仅产生通过它自己的VTABLE的调用，而不是最后的VTABLE（全部构造函数被调用后才会有最后的VTABLE）。
    因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。
    另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。
    直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
    假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。
    那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。
```
18. 析构函数的作用，如何起作用？
 ```
1)  构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。
    规则，只要你一实例化对象，系统自动回调用一个构造函数，就是你不写，编译器也自动调用一次。
2)  析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；
    特点：析构函数与构造函数同名，但该函数前面加~。 析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 
    当撤销对象时，编译器也会自动调用析构函数。 每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。
    一般析构函数定义为类的公有成员。
 ```
19. 构造函数和析构函数可以调用虚函数吗，为什么
```
1) 在C++中，提倡不在构造函数和析构函数中调用虚函数；
2) 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；
3) 因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；
4) 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，
    派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。
```

20. 构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？
```
1) 构造函数顺序
    ① 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
    ② 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。
    ③ 派生类构造函数。
2) 析构函数顺序
    ① 调用派生类的析构函数；
    ② 调用成员类对象的析构函数；
    ③ 调用基类的析构函数。
```

21. 虚析构函数的作用，父类的析构函数是否要设置为虚函数？
```
1) C++中基类采用virtual虚析构函数是为了防止内存泄漏。
    具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
    假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。
    那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
    所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。
2)  纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。
    因此，缺乏任何一个基类析构函数的定义，就会导致链接失败。因此，最好不要把虚析构函数定义为纯虚析构函数。
```
22. 构造函数析构函数可以调用虚函数吗？
```
1) 在构造函数和析构函数中最好不要调用虚函数；
2) 构造函数或者析构函数调用虚函数并不会发挥虚函数动态绑定的特性，跟普通函数没区别；
3) 即使构造函数或者析构函数如果能成功调用虚函数， 程序的运行结果也是不可控的。
```

23. 构造函数析构函数可否抛出异常
```
1)  C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。
    因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。
2)  用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；
3)  如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；
4)  如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。
```
24. 在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？
```
父构造函数 子构造函数 子析构函数 父析构函数
```
25. 在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？
```
    构造函数不能够声明为虚函数:
        1. 构造一个对象需要先确定对象的类型,而虚函数是在运行时确定的，虚构造函数无法在构造对象的时候确定所构造的对象类型;
        2. 虚函数的执行需要依赖于虚函数表。而虚函数表在构造函数中进行初始化工作,即初始化vptr，让它指向正确的虚函数表。而在构造
            对象期间,虚函数表还没有被初始化,将无法进行。
    析构函数可以被声明为虚函数,且在某些情况下必须声明为虚函数:
        1. 在类的继承中,如果有积累指针执行派生类,那么用基类指针delete是时,如果不定义为虚函数,派生类中派生的那部分无法析构;
    构造函数析构函数是否能够调用虚函数:
    １.　从语法上讲，调用完全没有问题。
    ２.　但是从效果上看，往往不能达到需要的目的。
    Effective 的解释是：
        派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。
        同样，进入基类析构函数时，对象也是基类类型。
        所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。
```
26. 什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？
```
    虚表:  虚函数的地址表,按照虚函数声明的顺序存储,如果子类覆盖父类函数,虚函数表中同样会覆盖;
```

33. mutable
```
1) 如果需要在const成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为mutable。即用mutable修饰的成员变量不受const成员方法的限制;
2) 可以认为mutable的变量是类的辅助状态，但是只是起到类的一些方面表述的功能，修改他的内容我们可以认为对象的状态本身并没有改变的。实际上由于const_cast的存在，这个概念很多时候用处不是很到了。
```
34. 深拷贝与浅拷贝？
```
1) 浅复制 —-只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。深复制 —-在计算机中开辟了一块新的内存地址用于存放复制的对象。
2) 在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。
```
35. C++模板是什么，底层怎么实现的？
```
1) 编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。
2) 这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。
```
36. C语言struct和C++struct区别
```
1) C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）。
2) C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数。
3) C++中，struct的成员默认访问说明符为public（为了与C兼容），class中的默认访问限定符为private，struct增加了访问权限，且可以和类一样有成员函数。
4) struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名
```
37. 类如何实现只能静态分配和只能动态分配
```
1) 前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建
2) 建立类的对象有两种方式：① 静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；② 动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；
3) 只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有。
```
38. 如果想将某个类用作基类，为什么该类必须定义而非声明？
```
1) 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。
```
39. 什么情况会自动生成默认构造函数？
```
1) 带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。不过这个合成操作只有在构造函数真正被需要的时候才会发生；如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；
2) 带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；
3) 带有一个虚函数的类
4) 带有一个虚基类的类
5) 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。
```
40. 什么是类的继承？
```
1) 类与类之间的关系has-A包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；is-A，继承关系，关系具有传递性；
2) 继承的相关概念所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；
3) 继承的特点子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；
4) 继承中的访问控制public、protected、private
5) 继承中的构造和析构函数
6) 继承中的兼容性原则
```
41. 什么是组合？
```
1) 一个类里面的数据成员是另一个类的对象，即内嵌其他类的对象作为自己的成员；创建组合类的对象：首先创建各个内嵌对象，难点在于构造函数的设计。创建对象时既要对基本类型的成员进行初始化，又要对内嵌对象进行初始化。
2) 创建组合类对象，构造函数的执行顺序：先调用内嵌对象的构造函数，然后按照内嵌对象成员在组合类中的定义顺序，与组合类构造函数的初始化列表顺序无关。然后执行组合类构造函数的函数体，析构函数调用顺序相反。
```
42. 抽象基类为什么不能创建对象？
```
抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。
（1）抽象类的定义：   称带有纯虚函数的类为抽象类。
（2）抽象类的作用：   抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。
（3）使用抽象类时注意：  抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。
    一、纯虚函数定义 　纯虚函数是一种特殊的虚函数，它的一般格式如下： 　　class <类名> 　　{ 　　virtual <类型><函数名>(<参数表>)=0; 　　… 　　}; 　在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。 　　
    纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。
    二、纯虚函数引入原因 　 
        1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 　 
        2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。 　　
        为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）。
        若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。
        这样就很好地解决了上述两个问题。 例如，绘画程序中，shape作为一个基类可以派生出圆形、矩形、正方形、梯形等， 如果我要求面积总和的话，那么会可以使用一个 shape * 的数组，只要依次调用派生类的area()函数了。如果不用接口就没法定义成数组，因为既可以是circle ,也可以是square ,而且以后还可能加上rectangle，等等.三、相似概念 1、多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。
        C++支持两种多态性：编译时多态性，运行时多态性。 　　
            a.编译时多态性：通过重载函数实现 　　
            b.运行时多态性：通过虚函数实现。 2、虚函数 　　虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。 
    3、抽象类 　　包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。
```

43. 类什么时候会析构？
```
1) 对象生命周期结束，被销毁时；
2) delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；
3) 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。
```
44. 为什么友元函数必须在类内部声明？
```
1) 因为编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分
```

46. 继承机制中对象之间如何转换？
```
指针和引用之间如何转换？
1) 向上类型转换将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。
2) 向下类型转换将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。
```
47. 组合与继承优缺点？
```
一：继承继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。
    继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。
    继承的缺点有以下几点：
        ①：父类的内部细节对子类是可见的。
        ②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。
        ③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。
        所以说子类与父类是一种高耦合，违背了面向对象思想。
二：组合组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。
    组合的优点：
        ①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。
        ②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。
        ③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。
    组合的缺点：
        ①：容易产生过多的对象。
        ②：为了能组合多个对象，必须仔细对接口进行定义。
```
48. 左值右值
```
1) 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。
    在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。
    举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址；
    表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。
2) C++11对C++98中的右值进行了扩充。
    在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。
    其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，
    这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值，或者转换为T&&的类型转换函数的返回值。
    将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。
3) 左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。
4) 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。
```
49. 移动构造函数
```
1) 我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；
2) 拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a->value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间；
3) 移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。
```
54. 智能指针是怎么实现的？什么时候改变引用计数？
```
    构造函数中计数初始化为1；
    拷贝构造函数中计数值加1；
    赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；
    析构函数中引用计数减一；
    在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象。
    share_prt<T>与weak_ptr<T>的区别？
    //share_ptr可能出现循环引用，从而导致内存泄露
    class A
    {
        public:
        share_ptr<B> p;
    };

    class B
    {
        public:
        share_ptr<A> p;
    }
    int main()
    {
        while(true)
        {
            share_prt<A> pa(new A()); //pa的引用计数初始化为1
            share_prt<B> pb(new B()); //pb的引用计数初始化为1
            pa->p = pb; //pb的引用计数变为2
            pb->p = pa; //pa的引用计数变为2
        }
        //假设pa先离开，引用计数减一变为1，不为0因此不会调用class A的析构函数，因此其成员p也不会被析构，pb的引用计数仍然为2；
        //同理pb离开的时候，引用计数也不能减到0
        return 0;
    }
    /*
    ** weak_ptr是一种弱引用指针，其存在不会影响引用计数，从而解决循环引用的问题
    */
```
55. C++四种类型转换：static_cast, dynamic_cast, const_cast, reinterpret_cast
```
    const_cast用于将const变量转为非const
    static_cast用的最多，对于各种隐式转换，非const转const，void*转指针等, static_cast能用于多态想上转化，如果向下转能成功但是不安全，结果未知；
    dynamic_cast用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。
        只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
    reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；
    为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。
```


57. 内联函数有什么优点？内联函数与宏定义的区别？
```
    宏定义在预编译的时候就会进行宏替换；
    内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译。
    内联函数相比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。
    使用宏定义函数要特别注意给所有单元都加上括号，#define MUL(a, b) a b，这很危险，正确写法：#define MUL(a, b) ((a) (b))
```

### STL

59. STL里的内存池实现
```
    STL内存分配分为一级分配器和二级分配器，一级分配器就是采用malloc分配内存，二级分配器采用内存池。
        二级分配器设计的非常巧妙，分别给8k，16k,..., 128k等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。
        需要分配内存时从合适大小的链表中取一块下来。假设需要分配一块10K的内存，那么就找到最小的大于等于10k的块，也就是16K，
        从16K的空闲链表里取出一个用于分配。释放该块内存时，将内存节点归还给链表。
        如果要分配的内存大于128K则直接调用一级分配器。为了节省维持链表的开销，采用了一个union结构体，
        分配器使用union里的next指针来指向下一个节点，而用户则使用union的空指针来表示该节点的地址。
```

60. STL里set和map是基于什么实现的。红黑树的特点？
```
set和map都是基于红黑树实现的。
    红黑树是一种平衡二叉查找树，与AVL树的区别是什么？AVL树是完全平衡的，红黑树基本上是平衡的。
    为什么选用红黑数呢？因为红黑数是平衡二叉树，其插入和删除的效率都是N(logN)，与AVL相比红黑数插入和删除最多只需要3次旋转，
        而AVL树为了维持其完全平衡性，在坏的情况下要旋转的次数太多。
    红黑树的定义：
    (1) 节点是红色或者黑色；
    (2) 父节点是红色的话，子节点就不能为红色；
    (3) 从根节点到每个页子节点路径上黑色节点的数量相同；
    (4) 根是黑色的，NULL节点被认为是黑色的。

STL里的其他数据结构和算法实现也要清楚
这个问题，把STL源码剖析好好看看，不仅面试不慌，自己对STL的使用也会上升一个层次。
```

61. 模板特化
```
    (1) 模板特化分为全特化和偏特化，模板特化的目的就是对于某一种变量类型具有不同的实现，因此需要特化版本。
    例如，在STL里迭代器为了适应原生指针就将原生指针进行特化。
```
容器的区别
```
array 是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。
vector 是表示可以改变大小的数组的序列容器。
deque 容器为一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素，并且能够高效地插入和删除容器的尾部元素。
    但它又与vector不同，deque支持高效插入和删除容器的头部元素，因此也叫做双端队列。
    deque的中控器: deque是由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。
    deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器结构。
list时双链表，forward_list是单链表，forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。
    在链表的任何位置进行插入/删除操作都非常快。
    forward_list只提供钱箱迭代器，因此不支持反向迭代器，比如rbegin()等成员函数。
    forward_list不提供size（）成员函数。
    forward_list没有指向最末元素的锚点，因此不提供back（）、push_back（）和pop_back（）。
    forward_list不提供随机访问，这一点跟list相同。
    插入和删除元素不会造成“指向至其他元素”的指针，引用和迭代器失效。
    list双向链表，是序列容器，允许在序列中的任何地方进行常数时间插入和擦除操作，并在两个方向上进行迭代,可以高效地进行插入删除元素。
stack没有迭代器，是一种容器适配器，用于在LIFO（后进先出）的操作，其中元素仅从容器的一端插入和提取。 
    stack底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
queue 是一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。
    队列不提供迭代器，不实现遍历操作。
优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。

set 是按照特定顺序存储唯一元素的容器。
    set 的 底层数据结构是 红黑树，一种高效的平衡检索二叉树。
    对 set 进行插入删除操作 都不会引起iterator的失效，因为迭代器相当于一个指针指向每一个二叉树的节点，对set的插入删除并不会改变原有内存中节点的改变， 
    但是vector的插入删除操作一般会发生内存移动和内存拷贝，所以会发生迭代器的失效。
    set容器的检索速度很快，因为采用二分查找的方法 。
map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。
vector中的reserve和resize的区别
    reserve是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back），就可以提高效率，其次还可以减少多次要拷贝数据的问题。
    reserve只是保证vector中的空间大小（capacity）最少达到参数所指定的大小n。reserve()只有一个参数。
resize()可以改变有效空间的大小，也有改变默认值的功能。capacity的大小也会随着改变。resize()可以有多个参数

vector中的size和capacity的区别
    size表示当前vector中有多少个元素（finish - start）;
    capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage - start）;
vector中erase方法与algorithn中的remove方法区别
    vector中erase方法真正删除了元素，迭代器不能访问了
    remove只是简单地将元素移到了容器的最后面，迭代器还是可以访问到。因为algorithm通过迭代器进行操作，不知道容器的内部结构，所以无法进行真正的删除
vector迭代器失效的情况
    当插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。
    当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。
    erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it);。
正确释放vector的内存(clear(), swap(), shrink_to_fit())
    vec.clear()：清空内容，但是不释放内存。
    vector<int>().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。
    vec.shrink_to_fit()：请求容器降低其capacity和size匹配。
    vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。

什么情况下用vector，什么情况下用list，什么情况下用deque
    vector:可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，
        随机访问频繁。除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。
    list:不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。
    deque: 需要从首尾两端进行插入或删除操作的时候需要选择deque。
    priority_queue：优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。

为何map和set的插入删除效率比其他序列容器高
    因为不需要内存拷贝和内存移动

为何map和set每次Insert之后，以前保存的iterator不会失效？
    因为插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。

map 、set、multiset、multimap的特点
    set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。
    map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以map默认是按key排序的），
        map中元素的key不允许重复，multimap可以重复。
    map和set的增删改查速度为都是logn，是比较高效的。
为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？
    存储的是结点，不需要内存拷贝和内存移动。
    插入操作只是结点指针换来换去，结点内存没有改变。
    而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。

hash_map与map的区别？什么时候用hash_map，什么时候用map？ 
    构造函数：hash_map需要hash function和等于函数，而map需要比较函数（大于或小于）。
    存储结构：hash_map以hashtable为底层，而map以RB-TREE为底层。
    总的说来，hash_map查找速度比map快，而且查找速度基本和数据量大小无关，属于常数级别。
    而map的查找速度是logn级别。但不一定常数就比log小，而且hash_map还有hash function耗时。
    如果考虑效率，特别当元素达到一定数量级时，用hash_map。
    考虑内存，或者元素数量较少时，用map。

线程不安全的情况:
    在对同一个容器进行多线程的读写、写操作时；
    在每次调用容器的成员函数期间都要锁定该容器；
    在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器；
    在每个在容器上调用的算法执行期间锁定该容器。
```
stl

|容器|底层数据结构|时间复杂度|有无序|是否可重复|
|----|-----------|---------|-----|---------|
|array|数组|随机读改O(1)|无序|可重复|
|vector|数组|随机读改,尾部插入，尾部删除O(1)头部插入、头部删除O(n)|无序|可重复|
|dequeue|双端队列|头尾插入、头尾删除O(1)|无序|可重复|
|forward_list|单向链表|插入删除O(1)|无序|可重复|
|list|双向链表|插入删除O(1)|无序|可重复|
|stack|deque/list|顶部插入、顶部删除O(1)|无序|可重复|
|queue|deque/list|尾部插入、头部删除O(1)|无序|可重复|
|priority_quue|vector/max-heap|插入、删除O(logn)|有序|可重复|
|set|红黑树|插入、删除、查找O(logn)|有序|不可重复|

### 编程基础
33. strcat,strcpy,strncpy,memset,memcpy的内部实现？
```
c++11标准增加了全局函数std::to_string可以使用std::stoi/stol/stoll等等函数strcpy拥有返回值，有时候函数原本不需要返回值，但为了增加灵活性如支持链式表达，
```
22. 手写strcpy
```
    char strcpy(char dst, const char src)
    {
    assert(dst);
    assert(src);
    char ret = dst;
    while((dst++ = src++) != '\0');
    return ret;
    }
    //该函数是没有考虑重叠的
    char strcpy(char dst, const char src)
    {
    assert((dst != NULL) && (src != NULL));
    char ret = dst;
    int size = strlen(src) + 1;
    if(dst > src || dst < src + len)
    {
    dst = dst + size - 1;
    src = src + size - 1;
    while(size--)
    {
    dst-- = src--;
    }
    }
    else
    {
    while(size--)
    {
    dst++ = src++;
    }
    }
    return ret;
    }
```


22. 手写memcpy函数
```
void memcpy(void dst, const void src, size_t size)
{
if(dst == NULL || src == NULL)
{
return NULL;
}
void res = dst;
char pdst = (char)dst;
char psrc = (char)src;
if(pdst > psrc && pdst < psrc + size) //重叠

{

pdst = pdst + size - 1;

psrc = pdst + size - 1;

while(size--)

{

*pdst-- = *psrc--;

}

}

else //无重叠

{

while(size--)

{

*dst++ = *src++;

}

}

return ret;

}

```

23. 手写strcat函数
```
char strcat(char dst, const char src)
{
char ret = dst;



while(*dst != '\0')

++dst;



while((*dst++ = *src) != '\0');

return ret;

}
```


24. 手写strcmp函数
```
int strcmp(const char str1, const char str2)
{



while(*str1 == *str2 && *str1 != '\0')

{

++str1;

++str2;

}

return *str1 - *str2;

}
```
- 判断大小端
```
union un
{
int i;
char ch;
};

void fun()
{
union un test;
test.i = 1;
if(ch == 1)
cout << "小端" << endl;
else
cout << "大端" << endl;
}
```
设计模式
单例模式线程安全的写法
STL里的迭代器使用了迭代器模式
1. 有序  查找  如果包含这两个关键字首先要想到的时二分查找法
2. 字符串替换，顺序调整 可以考虑逆序复制
3. 反转字符串 可以考虑先把每个单词逆序,然后整个字符串逆序  负负得正



26.二叉树
```

递归是解决二叉树相关问题的神级方法；
树的各种常见算法题(http://blog.csdn.net/xiajun07061225/article/details/12760493)；
```

27. Trie树(字典树)]
```
每个节点保存一个字符
根节点不保存字符
每个节点最多有n个子节点(n是所有可能出现字符的个数)
查询的复杂父为O(k)，k为查询字符串长度
```

28. 链表
```
链表和插入和删除，单向和双向链表都要会
链表的问题考虑多个指针和递归

```




******************
# 网络与TCP/IP
- [TCP与UDP之间的区别](http://blog.csdn.net/shanghairuoxiao/article/details/68927070)

#### 安全相关



****************
- SQL语言(内外连接，子查询，分组，聚集，嵌套，逻辑)

-





### TCP网络



# Linux



********


### 多线程
### [**死锁**](http://blog.csdn.net/shanghairuoxiao/article/details/70444940)

哈希表的桶个数为什么是质数，合数有何不妥？
3. enable_share_from_this 是做什么的，请举一个场景说明？
```
然后就开始聊多线程编程模式、线程安全等问题。
我觉得这个问题是一个很好的问题，从语言出发，扩展到工程经验和对编程的理解。
而且弱指针确实是c++非常有特色的一个特性
```

 ++i是否是原子操作
明显不是，++i主要有三个步骤，把数据从内存放在寄存器上，在寄存器上进行自增，把数据从寄存器拷贝会内存，每个步骤都可能被中断。


熟悉一下一些算不上多线程设计模式的小技巧，比如传递只读对象可以避免加锁，或者Copy传递以防外部修改之类的（讨论环节被问过）。
另外值得特别一提的一个小细节是，，值得一看（只被问过一次，不过我答挂了，所以印象及其深）。还有可能会问的是一些有趣的小场景让你实现一些功能需要线程安全



编程语言阐述
如何设计一个C++类？实现String类。
谈谈对C++虚函数机制的理解。
STL的Vector原理及迭代器失效的理解。
设计一个C++HashMap类。
使用C++实现一个堆的模板类。

写一个宏定义比较函数并解释宏展开过程。
谈谈std::move的理解和使用。

malloc的内存可以用delete释放吗？原因？
简述C++11的新特性以及解决了什么问题。

STL的Map原理、插入和删除复杂度分析。
STL的Map基于红黑树实现的原因，为什么不选择哈希表？
为什么需要虚析构？虚析构和普通析构函数的区别是什么？

说明C++对象的内存布局模型。
---------------------------------------
聊聊C++临时对象和右值引用，写个例子。
使用C++写一个高效的多维矩阵乘法。
谈谈对智能指针的认识并实现一个智能指针类。
----------------------------------------
STL中Map的查找时[]和find区别是什么？哪个更快？
实现memcpy函数效率尽可能高。尝试实现C/C++中常用字符串库函数。
谈谈C++中强制类型转换的原理和使用，写个例子。

谈谈C++的设计模式，重点介绍下单例模式、工程模式等。


数据结构和算法
求二叉树节点和为N的所有路径。实现二叉树的镜像。
实现两棵二叉树相加生成一棵新的二叉树。
实现单链表的递归逆置和非递归逆置。
二分查找变种问题。
二叉树的后序非递归遍历。
两个无序整型数组交换元素使得两数组和差距最小。
给定整型数组和目标数输出数组所有两数之和为目标数的组合。
找到带权重二叉树中从根到叶子的最大和路径。
最长公共子序列LCS问题。
二叉树中找到指定两个节点最近公共祖先。
实现堆排序求Top10数据。
实现最小栈。

简述并尝试设计一个布隆过滤器。
外排序的基本实现过程。
常见排序算法的性能对比。
快速排序的非递归实现

数据库存储
谈谈对于Redis的底层数据结构的理解。跳表了解吗？

Redis的zset实现原理以及为什么不用红黑树。
Redis哨兵原理以及集群版故障转移过程。
基于Redis实现分布式锁。

Redis渐进式Rehash的实现原理。
Redis和LevelDB的区别以及LevelDB的LSM树和WAL原理。

Redis主从同步的实现原理和过程、产生数据丢失的原因。
MyISAM和InnoDB的区别。
MySQL索引原理和优化。

Redis集群版如何实现一致性Hash算法的。
Redis的单线程网络框架原理和混合持久化机制。
类Redis数据库Pika了解吗？基本设计架构是什么？

如何设计一个缓存系统以及缓存击穿的解决方案？
一致性协议raft/paxos/2pc/3pc基本原理。
Redis的Gossip协议原理。
Redis4.0+版本的BIO线程原理和使用。
简述如何自己实现一个NoSQL，需要考虑什么。

Linux系统LVS实现负载均衡的原理。
简述Linux内存管理原理以及伙伴算法和Slab算法。
select和epoll的对比以及epoll实现的底层原理和数据结构。
epoll的LT模式和ET模式下读写操作，实现一下ET模式的read/write。
使用C++简单实现一个生产者消费者模型。
Linux虚拟内存和物理内存的区别与联系
如何使用gdb调试多进程、多线程程序。
谈谈C10K和C10M问题及大致实现思路。
```
使用select epoll等网络库更高效的处理网络
```
Linux地址复用和端口复用的使用。
谈谈Reactor和Proactor模式区别与联系。
尝试基于epoll实现一个高并发网络框架。
Nginx的基本原理以及负载均衡实现方法。
谈谈Linux服务器内存/cpu/磁盘/网络带宽的监控命令和问题排查。
谈谈CAP理论以及分布式一致性算法。
了解CpuCache吗，如何据此来优化代码。
读写锁、RCU锁、自旋锁的对比以及设计读优先/写优先的读写锁
自己设计实现一个简单的读写锁。谈
谈grpc的使用以及brpc的对比。
对比协程和进线程，重点说明系统开销差异和各自优缺点。
谈谈对线程同步和多线程安全的理解。
Https的C/S交互过程、http1.0/2.0/3.0的对比。
多进程通信的方法和对比。
多线程同步的实现和线程安全。
实现一个基于LRU的本地缓存。
TCP/IP的拥塞控制原理和缺陷、BBR算法对比。
使用Python实现多进程和多线程以及谈谈对GIL的理解。
网络攻击有哪些？简述DDos、CC攻击。
对比内存分配malloc/tcmalloc/ptmalloc。
Protobuf协议的简单原理和使用。
Coredump的常见原因。
```
内存越界
多次释放内存
 多线程程序使用了线程不安全的函数
 多线程读写的数据未加锁保护
 非法指针
 堆栈溢出
```
死锁的原理以及写一个死锁。
MapReduce的基本原理、写个简单的map和reduce的程序。
同步异步阻塞非阻塞IO的理解。
git的基本原理以及常用命令。
局部性hash算法simhash的原理。
服务端长短连接的区别、优势和场景。
如何避免多线程的虚假唤醒问题。
```
虚假唤醒: 指条件变量会在条件不符合的时候也会唤醒,所以需要使用死循环来等待条件变量唤醒，避免丢失
```
实现简单的线程池和连接池。
实现一个可以完成C10K+的TCP网络框架。
尝试多种方法实现一个守护进程，
2 magic fork了解吗？惊群问题知道吗？Nginx是如何解决的？
```
多个进程同时等待网络的连接事件，当这个事件发生时，这些进程被同时唤醒，就是“惊群”
Nginx中使用mutex互斥锁解决这个问题，具体措施有使用全局互斥锁，每个子进程在epoll_wait()之前先去申请锁，申请到则继续处理，获取不到则等待，并设置了一个负载均衡的算法（当某一个子进程的任务量达到总设置量的7/8时，则不会再尝试去申请锁）来均衡各个进程的任务量
```

谈谈对服务治理和服务发现的理解。
微服务接触过吗？谈谈对微服务的理解。服务异步化编程了解过吗？
开源组件常用的MQ有哪些以及各自的对比和场景
Kafka的基本原理和实现要点
libevent/libuv的基本原理和使用
Boost.Asio的原理和使用
微信协程库libco原理和使用
DPDK的基本原理和用户态协议栈的概念
Redis和Memcached
对比RPC框架对比：brpc/grpc/thrif
tSTL源码的理解和阅读分析
Nginx的架构、原理、使用注

工程设计
信息流推荐中会生成大量点击率文章，设计一个程序实现即时排序，返回热门文章。词库每个词都有根据点击率来计算的热度，
实现一个系统，支持前缀匹配并且返回Top10的热词。
设计一个支持千万级文章相似度去重的程序，来实现抄袭、洗稿文章的识别，时间ms级，准确率不低于95%。
小内存机器有两个文件A和B，分别存放5亿条均长64字节的url，试着找到A和B中所有重复的url。
尝试实现一个简单的音乐推荐系统，可以不涉及具体算法，主要说明工程部分即可。
设计一个黑词服务实现黄反、指令词、敏感词等过滤功能，耗时ms级。
