
- **fork与vfork区别**
```
fork和vfork都用于创建子进程
vfork创建子进程后,父进程阻塞,直到子进程调用exit()或者excle();
对于内核中过程fork通过调用clone函数,然后clone函数调用do_fork();
do_fork()中调用copy_process()函数先复制task_struct结构体,然后复制其他关于内存，文件，寄存器等信息;
fork采用写时拷贝技术，因此子进程和父进程的页表指向相同的页框;
但是vfork不需要拷贝页表，因为父进程会一直阻塞，直接使用父进程页表。
```
- **exit()与_exit()区别**
```
exit()清理后进入内核，_exit()直接陷入内核。
```

- **孤儿进程与僵死进程**
```
 孤儿进程:
    一个父进程退出,而它的一个或多个子进程还在运行.那么那些子进程将成为孤儿进程。
    孤儿进程将被init进程(进程号为1)所收养,并由init进程对它们完成状态收集工作。
僵尸进程:
    子进程先于父进程退出后,子进程的PCB需要其父进程释放,但是父进程并没有释放子进程的PCB,这样的子进程就称为僵尸进程;
    僵尸进程实际上是一个已经死掉的进程
僵死进程的危害:
    如果有大量的僵尸进程驻在系统之中,必然消耗大量的系统资源。
    但是系统资源是有限的，因此当僵尸进程达到一定数目时，系统因缺乏资源而导致奔溃
如何避免僵死进程的产生:
1. 一种比较暴力的做法是将其父进程杀死,那么它的子进程,即僵尸进程会变成孤儿进程,由系统来回收
    但是这种做法在大多数情况下都是不可取的,如父进程是一个服务器程序,如果为了回收其子进程的资源,而杀死服务器程序,
    那么将导致整个服务器崩溃,得不偿失。显然这种回收进程的方式是不可取的，但其也有一定的存在意义。

2. SIGCHLD信号处理
    当父进程接收到SIGCHLD信号后就应该调用 wait 或 waitpid 函数对子进程进行善后处理，释放子进程占用的资源。
```

Linux是如何避免内存碎片的
```
1. 伙伴算法，用于管理物理内存，避免内存碎片;
2. 高速缓存Slab层用于管理内核分配内存，避免碎片。

伙伴: 大小相同、物理地址连续的两个页块称为伙伴
伙伴算法工作原理:
    首先在大小满足要求的块链表中查找是否有空闲块，若有则直接分配，
    否则在更大的块的块链表中查找；

    逆过程是块的释放，此时会把满足伙伴关系的块合并，
    组成一个更大的块，并插入到相应的块链表中
```
- **共享内存的实现原理？**
```
共享内存实现分为两种方式一种是采用mmap，另一种是采用XSI机制中的共享内存方法。mmap是内存文件映射，将一个文件映射到进程的地址空间，用户进程的地址空间的管理是通过vm_area_struct结构体进行管理的。mmap通过映射一个相同的文件到两个不同的进程，就能实现这两个进程的通信，采用该方法可以实现任意进程之间的通信。mmap也可以采用匿名映射，不指定映射的文件，但是只能在父子进程间通信。XSI的内存共享实际上也是通过映射文件实现，只是其映射的是一种特殊文件系统下的文件，该文件是不能通过read和write访问的。
二者区别：

> 1、 系统V共享内存中的数据，从来不写入到实际磁盘文件中去；而通过mmap()映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中。注：前面讲到，系统V共享内存机制实际是通过映射特殊文件系统shm中的文件实现的，文件系统shm的安装点在交换分区上，系统重新引导后，所有的内容都丢失。



> 2、 系统V共享内存是随内核持续的，即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在（除非显式删除共享内存），在内核重新引导之前，对该共享内存区域的任何改写操作都将一直保留。



> 3、 通过调用mmap()映射普通文件进行进程间通信时，一定要注意考虑进程何时终止对通信的影响。而通过系统V共享内存实现通信的进程则不然。注：这里没有给出shmctl的使用范例，原理与消息队列大同小异。
```


- 系统调用与库函数(open, close, create, lseek, write, read)

- 同步方法有哪些？

1. 互斥锁，自旋锁，信号量，读写锁，屏障

2. 互斥锁与自旋锁的区别：互斥锁得不到资源的时候阻塞，不占用cpu资源。自旋锁得不到资源的时候，不停的查询，而然占用cpu资源。

3. [死锁](http://blog.csdn.net/shanghairuoxiao/article/details/70444940)

### [**进程间通讯方式**](http://www.cnblogs.com/CheeseZH/p/5264465.html)



> **管道( pipe )**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

>

**命名管道 (FIFO) **： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

>

> **信号量**：信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据，有XSI信号量和POSIX信号量，POSIX信号量更加完善。

>

**消息队列( message queue )** ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

>

**共享内存( shared memory ) **：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。(原理一定要清楚，常考)

>

>**信号 ( sinal ) **： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生，常见的信号。

>

**套接字( socket ) **： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。



- **匿名管道与命名管道的区别**：匿名管道只能在具有公共祖先的两个进程间使用。

- **共享文件映射mmap**

mmap建立进程空间到文件的映射，在建立的时候并不直接将文件拷贝到物理内存，同样采用缺页终端。mmap映射一个具体的文件可以实现任意进程间共享内存，映射一个匿名文件，可以实现父子进程间共享内存。



- **常见的信号有哪些？**：SIGINT，SIGKILL(不能被捕获)，SIGTERM(可以被捕获)，SIGSEGV，SIGCHLD，SIGALRM

### 进程调度

1. Linux进程分为两种，实时进程和非实时进程；

2. 优先级分为静态优先级和动态优先级，优先级的范围；

3. 调度策略，FIFO，LRU，时间片轮转

4. 交互进程通过平均睡眠时间而被奖励；
### 命令行
- Linux命令 在一个文件中，倒序打印第二行前100个大写字母
cat filename | head -n 2 | tail -n 1 | grep '[[:upper:]]' -o | tr -d '\n'| cut -c 1-100 | rev

- 与CPU，内存，磁盘相关的命令(top，free, df, fdisk)
- 网络相关的命令netstat，tcpdump等
- sed, awk, grep三个超强大的命名，分别用与格式化修改，统计，和正则查找
- ipcs和ipcrm命令
- 查找当前目录以及字母下以.c结尾的文件，且文件中包含"hello world"的文件的路径
- 创建定时任务


**********
### [**内存管理**](http://blog.csdn.net/shanghairuoxiao/article/details/70256247)

1. 虚拟内存的作用？

2. 虚拟内存的实现？

3. 操作系统层面对内存的管理？

4. 内存池的作用？STL里[内存池如何实现](https://github.com/oscarwin/MemoryPool)？

5. 进程空间和内核空间对内存的管理不同？

6. Linux的slab层，VAM？

7. 伙伴算法

8. 高端内存
一、 OS中都有什么锁

1.1互斥锁



mutex（mutual exclusive）即互斥量（互斥体）。也便是常说的互斥锁。mutex是最常见的多线程同步方式。多线程共享一个互斥量，然后线程之间去竞争。得到锁的线程可以进入临界区执行代码。



1.2 读写锁



读写锁是一种 读共享，写独占的锁。



读写锁的特性：



当读写锁被加了写锁时，其他线程对该锁加读锁或者写锁都会阻塞（不是失败）。



当读写锁被加了读锁时，其他线程对该锁加写锁会阻塞，加读锁会成功。



1.3 自旋锁



自旋就是在共享资源的状态不满足时， 自旋锁持续不停的检测状态，它和其他锁的区别就在于不会使线程休眠，也就是不会产生上下文切换，但是会浪费cpu。







二、 内核态和用户态

内核态与用户态是操作系统的两种运行级别 ，在内核态下CPU可执行任何指令，在用户态下CPU只能执行非特权指令。当CPU处于内核态，可以随意进入用户态；而当CPU处于用户态时，用户从用户态切换到内核态只有在系统调用和中断两种情况下发生，一般程序一开始都是运行于用户态，当程序需要使用系统资源时，就必须通过调用软中断进入内核态。



Linux进程的4GB地址空间，3G-4G部分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。





三、 内存管理

3.1 分段存储和分页存储的区别以及优缺点

3.1.1页式管理

页式管理的基本原理是将各进程的虚拟空间划分为若干个长度相等的页。把内存空间按页的大小划分为片或者页面，然后把页式虚拟地址与内存地址建立一一对应的页表，并用相应的硬件地址转换机构来解决离散地址变换问题



3.1.2 段式管理

段式管理的基本思想是把程序按内容或过程函数关系分成段，每段有自己的名字。段是信息的逻辑单位，它含有一组其意义相对完整的信息 一个用户作业或者进程所包含的段对应一个二维线性虚拟空间，也就是一个二维虚拟存储器。段式管理程序以段为单位分配内存，然后通过地址映射机构把段式虚拟地址转换为实际内存物理地址。



1. 分页是出于系统管理的需要，分段是出于用户应用的需要

2. 页大小是系统固定的，而段大小则通常不固定。

3. 分页是一维的，程序员只需用一个记忆符，即可表示一个地址;而分段是二维的，程序员在标识一个地址时，既要给出段名，又需给出段内地址。

4. 通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度

5. 页和段都有存储保护机制。但存取权限不同：段有读、写和执行三种权限；而页只有读和写两种权限



3.1.3 块表

虚拟内存的段页式存储地址变换中，有快表和没快表，有什么区别？



基本地址变换机构	        ---两次访问

①算页号、页内偏移量 ②检查页号合法性 ③查页表，找到页面存放的内存块号 ④根据内存块号与页内偏移量得到物理地址 ⑤访问目标内存单元



具有快表的地址变换机构	--- 一次访问

①算页号、页内偏移量 ②检查页号合法性 ③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤;若未命中则进行④ ④查页表，找到页面存放的内存块号，并且将页表项复制到快表中 ⑤根据内存块号与页内偏移量得到物理地址 ⑥访问目标内存单元



快表命中，只需一次访存 快表未命中，需要两次访存





四、 页面置换方法

1. 最优页面置换算法 

    从主存中移出最长时间不需要访问的页面

2. 先进先出页面置换算法

（FIFO）移除内存中驻留时间最长的页面

3. 时钟页面置换算法

（clock）

4. 最近最少使用页面置换算法

（LRU）

5. 工作集算法





五、 虚拟内存

虚拟内存提供了三个重要的能力：



将主存看作一个存储在磁盘上的地址空间的缓存，根据需要在主存和磁盘间传送数据，更高效的使用了主存。

为进程提供相同的地址空间，从而简化了内存管理。

保护了每个进程的空间不受其他进程破坏。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。



这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。



5.1 虚拟内存的好处



5.1.1 简化链接



linux中每个进程都使用类似的内存布局， 这样可以大大简化链接器的设计，链接器可以生成完全独立于物理内存中代码和数据的链接完全的可执行文件



5.1.2 简化加载



把目标文件中 .text 和 .data 段加载到一个新创建的进程中 ，只需要为他们分配虚拟页即可，虚拟内存系统会按照需要自动地调入数据页，而不需要加载器来操作



5.1.3 简化共享



将多个进程的虚拟内存地址映射到相同的物理页，实现多个进程之间的数据共享。



5.1.4 简化内存分配



当进程要求额外的堆空间时， 比如调用malloc， 需要分配连续的地址空间，但是通过虚拟内存，可以将连续的虚拟地址映射到不连续的物理地址下。



5.2 虚拟内存的代价



1. 虚存内存管理需要建立很多数据结构，需要占用很大的内存空间。

2. 虚拟地址到物理地址的转换，增加了指令空间。

3. 页面的置换需要硬盘io，需要消耗时间。





5.3抖动你知道是什么吗？它也叫颠簸现象

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够)



为进程分配的物理块太少，会使进程发生抖动现象。





5.3.1 内存溢出与内存泄漏

内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory



内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间



内存泄漏最终会导致内存溢出.



六、 系统调用的过程





1. 程序通过调用函数库中的外壳函数，发起系统调用。

2. 函数将通过堆栈传入外壳函数的参数置入指定的寄存器。

3. 将系统调用的编号复制到EAX

4. 外壳函数执行中断指令0x80，处理器从用户态进入到内核态

5. 内核调用system_call

i.  在内核栈中保存寄存器的值

ii. 审核系统调用编号的有效性

iii. 以编号索引找到对应的系统调用服务，并执行

iv. 从内核栈恢复寄存器的值，将系统调用返回值置于栈中

v.  返回用户态



七、 Linux文件系统



7.1 linux中链接分为硬链接和软链接。



7.1.1 硬链接



硬链接是指将该文件名直接指向一个另一个文件的inode，当删除原文件后，由于该文件名了解该文件inode，所以不会受到影响。每次创建硬链接会使inode中记录的引用计数+1，当引用计数减少到0，则释放该inode。



硬链接是不能跨文件系统建立的。



7.1.2 软链接



创建软链接会真正的分配一个inode存储指向原文件的文件名，也就是读取该inode，则直接跳转到原文件的目录下进行查找原文件从而进行操作。所以，软链接是可以跨文件系统建立的。



7.2 linux 下建立一个文件的步骤

1. 存储文件属性，首先找到一个空闲的inode， 把文件属性记录在其中。

2. 存储文件数据申请空间块，在自由块中寻找足够的块。

3. 记录存储情况，将块地址填入inode

4. 添加文件名到该目录下，并将文件名与inode建立连接。



八、五种IO模型

8.1 Unix io存在五种模型



阻塞式IO

应用进程被阻塞，直到数据从内核缓冲区中返回进程缓冲区才返回



非阻塞式IO

进行系统调用后，内核返回一个错误码，进程不断轮询查看io是否完成



IO复用

使用select，poll，epoll等待处理数据，并可以同时监听多个socket



信号驱动式IO

立即返回，当数据准备完成内核向进程发送信号，信号处理程序来拷贝数据



异步IO

立即返回，应用进程继续执行，内核会在所有操作完成之后向进程发送信号



8.2 什么是同步io什么是异步io

同步IO和异步IO的区别就在于第二个步骤是否阻塞。



如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO服用、信号驱动IO都是同步IO。



如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。



阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。







九、 select() poll() epoll() 区别

这三种方式是在IO多路复用中常见的几种方式



9.1 select



使用无差别轮询方式进行查看是否有io事件发生，支持的文件描述符较少，默认是1024，可以修改内核参数来改变最大的文件描述符数量，但是会影响效率



select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景 ，可移植性更好，几乎被所有主流平台所支持。



9.2 poll



poll本质上与select没有差别，只是它是使用链表来存储的，所以对最大连接数没有限制。若对精度没有要求，选择poll



9.3 epoll



epoll是一种时间复杂度为O(1)的方式，相对于select和poll，epoll会更加灵活，没有描述符的限制，它将用户关心的描述符放在内核中的一个事件表中，这样进行io时，仅需copy一次即可。



9.3.1 epoll使用三个函数实现io复用



epoll_create(size)



size会告诉内核这个监听数量有多大，但是size并非是一个限制，而是对初始内部数据分配的一个建议



epoll_ctl



对指定描述符修改，添加，删除它的监听事件。



int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);



等待io事件，最多返回maxevent个事件。



9.3.2 原理

epoll 维护了一颗红黑树，作为内核事件表，用于收集描述符，维护一个就绪队列，用来存放有就绪队列的文件描述符，每个epoll事件都有一个epollevent结构体，存放着epoll_ctl方法添加进来的事件，并将其insert到红黑树中，红黑树可以高效的识别出重复的事件。当有IO事件发生时，内核会将发生io的文件放入就绪队列中，从而实现O(1)的查询。



若有大量的描述符需要同时轮询，使用epoll。



9.3.3 EPOLL可监听的事件类型

EPOLLIN：套接字可读

EPOLLOUT：套接字可写

EPOLLRDHUP：对端关闭了套接字，或者对端关闭了写

EPOLLPRI：套接字上有紧急数据到达

EPOLLHUP：对端挂断了套接字

epollET模式中的epolloneshot

此规定操作系统最多触发其上注册的一个可读或者可写或者异常事件，且只触发一次，如此无论线程再多，只能有一个线程或进程处理同一个描述符。当然处理完之后线程要重置这个epolloneshot事件，进而当此描述符有事件可读时让其他进程可以处理此描述符。



这样，在epoll对fd进行读写时，fd再次发生写事件，系统不会再给fd开辟一条线程再次处理



9.3.4 讲一下LT和ET的区别

LT是电平触发，ET是边沿触发



LT的工作方式，当队列中当前文件描述符没有处理或没有完成，则下一次epoll会再次提醒，即程序可以不立即处理该事件。



ET的工作方式在下一次epoll是不会提醒的，它要求应用程序收到一次提醒后，必须将事件都处理完成。



LT是只要某个文件描述符在readable/writeable，epoll_wait都会返回该socket，而ET是只有在变化时才会返回socket。



9.4 硬链接和软链接的区别

1. 硬链接指通过索引节点来进行连接 ，硬链接就是多个文件名指向同一个文件的索引节点。当删除原文件后，硬链接仍然可用

2. 软链接也是符号链接，它更像一个快捷方式，它指向原文件，当删除原文件后，则软链接不可用。



十、 网络编程

10.1 服务端编程API

```cpp
int getaddrinfo(const char *host, const char *service, const struct addrinfo *hints, struct addrinfo **result);
//通过给出host和service两个socket地址的组成部分，getaddrinfo返回result，指向一个addrinfo的链表头节点，接下来遍历这个链表，依次尝试每个套接字地址知道调用socket和connect成功，使用freeaddrinfo释放链表头节点即可。
//addrinfo结构中包含了各种api使用的参数，这样可以使我们编写任何版本ip的程序。




int socket(int domain, int type, int protocol);
//domain : 使用哪个协议族 一般为 PF_INET (IPv4) PF_INET6 (ipv6)
//type : 使用什么服务类型 SOCK_STREAM 流服务即TCP, SOCK_DGRAM 数据报服务即UDP
//protocol : 选择一个具体的协议， 一般设为0 表示使用默认协议
// 系统调用成功返回一个socket文件描述符，失败返回-1 设置errno


int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen);
//将myaddr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指出该socket地址长度。
//成功返回0 失败返回-1


int listen(int sockfd, int backlog);
// 指定监听的socket文件描述符， backlog为内核监听队列最长的长度。


int accept(int listenfd, struct sockaddr *addr, socklen_t *addrlen);
//listenfd为监听描述符， addr用来获取远端描述符，该地址长度有addrlen指出。
// accept成功返回一个socket文件描述符，否则返回-1


int connect(int clientfd, const struct sockaddr *serv_addr, socklen_t addrlen);
// connect尝试与套接字地址为serv_addr的服务器建立一个因特网连接。


```





十一、 reactor和proactor

11.1 Reactor和Proactor是两种io多路复用的模式



1. Reactor采用的是同步io，proactor采用的是异步io。

2. Reactor模式，本质就是当IO事件(如读写事件)触发时，通知我们主动去读取，也就是要我们主动将socket接收缓存中的数据读到应用进程内存中。

3. Proactor模式，我们需要指定一个应用进程内的buffer(内存地址)，交给系统，当有数据包到达时，则写入到这个buffer并通知我们收了多少个字节。

## Reactor 工作流程：

1. 主线程向epoll内核事件表中注册socket上的读就绪事件

2. 主线程调用epoll_wait等待socket上有数据可读

3. 当socket有数据可读，epoll_wait通知主进程，主线程将socket可读事件放入请求队列

4. 唤醒请求队列上的某个工作线程，开始从socket读取数据，处理客户需求，并向epoll内核事件表中注册写就绪事件

5. 主线程调用epoll_wait等待主线程可写

6. socket可写时，epollwait通知主线程，主线程将socket放入请求队列

7. 唤醒某个工作进程 向socket上写入服务器处理客户请求的结果

### 优点

1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；



2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；



3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；



4）可复用性，reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；







十二、 IPC工具





12.1 管道

int pipe(int fd[2]);  






12.1.1 管道的性质

1. fd[0] 和 fd[1] 构成了管道的两端， 向fd[1]输入的数据可以由fd[0]读出，管道是单工的，无法反向传输，若想实现双工，使用两个管道即可，管道的读取与写入的顺序是完全相同的，无法使用lseek来随机读取。



2. 管道是面向字节流的，即数据在管道中是不存在消息或消息边界的概念的，从管道中读取数据可以读取任意大小的数据块，只要满足管道本身的容量限制， 默认大小是65536，可以通过Fcntl修改



3. fcntl(fd, F_SETPIPE_SZ, size) 可以修改命名管道的容量上限



4. 管道缓冲区存在于内核中，每次写入和读出都需要陷入内核态进行操作，所以数据传输速度较慢。



5. 保证写入不超过POP_BUF字节的操作是原子的



12.1.2 管道操作

* 父子进程通信



在fork()期间，子进程会继承父进程的操作符，将不使用的文件描述符关闭，比如将父进程的fd[0]关闭，子进程的fd[1]关闭，这时就可以在父子进程间进行通信，即父进程可向子进程传输数据。



不能两个进程都不关闭读入描述符，可能会造成两个进程的数据竞争。



* 相关进程通信



由想要通信的进程共同的祖先进程创建管道，而后除了两个进程需要使用的管道端口外，其他的管道文件描述符全部关闭。这样就可以直接传送数据。



*  关闭未使用的文件描述符



1. 关闭写入描述符

所有进程的写入描述符关闭后，read才能够读到文件结束符，否则read检测到仍然存在打开的写入描述符，就会阻塞进程等待数据。



2. 关闭读入描述符

当一个进程试图向一个管道中写入数据但是没有任何一个管道读入符打开的时候，内核会向写入进程发送SIGPIPE信号，及时处理这种情况，而若存在一个不使用的读入描述符，那么内核不会发送信号，无法进行处理。



* 进程同步



进程同步使用的是read的互斥性。父进程创建子进程之前创建一个管道，所有子进程会继承这个管道描述符，让子进程完成其工作后再关闭这些描述符，期间父进程一直被read阻塞，当所有进程完成任务退出后，才能重新进入运行。



为了防止子进程意外退出，可以令所有子进程在管道中写入一字节数据再退出，父进程进行读入分析。



使用管道进行同步和信号同步的优缺点

管道可以用来一个进程与多个相关进程的同步，而信号不能

信号可以被广播到进程组所有成员处。



*  连接过滤器



使用dup操作，关闭标准输入输出文件并复制管道输入符到STDOUT， 复制管道输出符到STDIN，这样就形成了过滤器



STDOUT -> pfd[1] -> pfd[0] -> STDIN



12.3 FIFO

int mkfifo(const char* pathname, mode_t mode)



FIFO与管道类似，其最大差别就是FIFO在文件系统中存在一个名称，并且其打开方式和普通文件是一样的。一旦FIFO被创建，任何进程都能打开它。



12.4 消息队列

共享内存的实现及api

int shmget(key_t key, size_t size, int shmflg); //用来创建或打开共享内存
void *shmat(int shmid, const void *shmaddr, int shmflg); //将共享内存段连接到进程地址空间
int shmdt(const void *shmaddr); //将共享内存与当前进程脱离
int shmctl(int shmid, int cmd, struct shmid_ds *buf); //用于控制共享内存






12.5 mmap

直接分配虚拟内存，而不映射到物理内存，当真正操作当前内存才通过缺页中断请求分页调入页表缓存



十三、伙伴系统

Linux伙伴系统的引入为内核提供了一种用于分配一组连续的页而建立的一种高效的分配策略，并有效的解决了外碎片问题。



Linux中的内存管理的“页”大小为4KB。



把所有的空闲页分组为11个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256，512和1024个连续页框的页块。最大可以申请1024个连续页，对应4MB大小的连续内存。每个页块的第一个页的物理地址是该块大小的整数倍。



当向内核请求分配(2^(i-1)，2^i]数目的页块时，按照2^i页块请求处理。如果对应的块链表中没有空闲页块，则在更大的页块链表中找。当分配的页块中有多余的页时，伙伴系统根据多余的页框大小插入到对应的空闲页块链表中。



　　当释放单页的内存时，内核将其置于CPU高速缓存中，对很可能出现在cache的页，则放到“快表”的列表中。在此过程中，内核先判断CPU高速缓存中的页数是否超过一定“阈值”，如果是，则将一批内存页还给伙伴系统，然后将该页添加到CPU高速缓存中。



　　当释放多页的块时，内核首先计算出该内存块的伙伴的地址。内核将满足以下条件的三个块称为伙伴：(1)两个块具有相同的大小，记作b。(2)它们的物理地址是连续的。(3)第一块的第一个页的物理地址是2*(2^b)的倍数。如果找到了该内存块的伙伴，确保该伙伴的所有页都是空闲的，以便进行合并。内存继续检查合并后页块的“伙伴”并检查是否可以合并，依次类推。



十四、 大端小端规则

大端: 将高位字节存储在低地址，低位字节存储在高地址



小端：将低位字节存储在低地址，高位字节存储在高地址



一般网络字节序为大端字节序，主机字节序为小端。



linux提供了几个函数可以进行网络字节序和主机字节序的转化。

ntohs()
ntohl()
ntohll()
 
htons()
htonl()
htonll()


14.1 为什么会有大端小端

对于计算机来说， 对于数据从低位开始计算更容易，所以一般计算机内部都是小端字节序





十五、 磁盘调度算法

1. 先来先服务

按照磁盘请求的顺序进行调度。



优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。



2. 最短寻道时间优先

优先调度与当前磁头所在磁道距离最近的磁道。



虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。



3. 电梯扫描算法

电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。



电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。



因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。





十六、 进程管理

16.1 进程与线程

进程是对运行时程序的封装，每个进程拥有独立的内存空间，是系统进行资源调度和分配的基本单位。



线程是进程的子任务，是CPU调度和分派的基本单位。用于保证程序的实时性，实现进程内部的并发。每个线程拥有独自的虚拟处理器，独立的寄存器组，指令计数器，和处理器状态，栈段，每个线程完成自己的任务，但是共用地址空间。



16.2 区别：



1. 一个线程只能属于一个进程，但一个进程允许有多个线程，一个进程可以分配的线程数量取决于进程分配虚拟空间的大小和线程栈段的大小。



2. 进程在运行时拥有自己独立的内存单元，线程共享进程的内存。



3. 进程编程调试可靠性高，但是创建销毁的开销很大，线程编程相反，开销小但是编程调试较为复杂。



4. 通信方式不同



16.3  进程间通信方式



1. 管道(pipe)：允许一个进程和另一个与它有共同祖先的进程之间进行通信

2. 命名管道(FIFO)：类似于管道，但是它可以用于任何两个进程之间的通信，命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建

3. 消息队列(MQ)：消息队列是消息的连接表，包括POSIX消息对和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能成该无格式字节流以及缓冲区大小受限等缺点；

4. 信号量(semaphore)：信号量主要作为进程间以及同进程不同线程之间的同步手段；

5. 共享内存(shared memory)：它使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。这是针对其他通信机制运行效率较低而设计的。它往往与其他通信机制，如信号量结合使用，以达到进程间的同步及互斥

6. 信号(signal)：信号是比较复杂的通信方式，用于通知接收进程有某种事情发生，除了用于进程间通信外，进程还可以发送信号给进程本身

7. Socket：它是更为通用的进程间通信机制，可用于不同机器之间的进程间通信

16.4 线程间通信方式：



1. 信号：类似进程间的信号处理

2. 锁机制：互斥锁、读写锁和自旋锁

3. 条件变量：使用通知的方式解锁，与互斥锁配合使用

4. 信号量：包括无名线程信号量和命名线程信号量



十七、 进程调度的具体过程

17.1 常见的进程调度算法

1. 先来先服务算法，只考虑就绪的先后，按就绪队列给进程分配资源

2. 短作业优先算法， 对预计处理时间短的作业优先分配资源

3. 轮转法，让每个进程在就绪队列中等待的时间与享受服务时间成正比例

4. 多级反馈队列算法， 设置多个就绪队列分别赋予优先级，较高的优先级队列分配较少的时间片

5. 最短剩余时间优先 shortest remaining time next（SRTN）

6. 优先级调度 为每个进程分配一个优先级，按优先级进行调度。

17.2一个进程可以创建多少线程，和什么有关？

一个进程可以创建的线程数由可用虚拟空间和线程的栈的大小共同决定，只要虚拟空间足够，那么新线程的建立就会成功。



在x86 32位系统的情况下，进程的用户可用虚拟地址空间是2G，系统占用2G，默认分配栈大小为1M时，创建线程的最大数量就为2G/1M=2048个。



十八、 死锁

18.1  产生死锁的条件

互斥

占有和等待

不可抢占

环路等待

18.2 死锁的解决策略

鸵鸟策略



18.3死锁检测与死锁恢复



抢占资源



回滚恢复



杀死进程



18.4 死锁预防



破坏互斥条件



破坏占有等待条件



破坏不可抢占条件



破坏环路等待条件 给资源统一编号，进程只能按编号顺序来请求资源。



18.5 死锁避免 - 银行家算法



十九、 协程

协程是用户态的一种轻量级线程，协程拥有自己的上下文和栈，协程调度时可以把上下文和栈保存在其他地方，协程能保留上一次调用时的状态，再次运行时能直接进入上次的状态。



19.1 协程的好处：



无需线程上下文切换的开销

无需原子操作锁定及同步的开销

方便切换控制流，简化编程模型







19.2 线程之间什么是共享的，什么是不共享的。

堆，全局变量，静态变量是共享的。



栈与寄存器是不共享的。



19.3一个进程启动时的内存管理是怎样的？

19.4 僵尸进程和孤儿进程

 19.4.1 僵尸进程



子进程退出后需要父进程的确认收到才能在进程表中删除，而如果在自己成退出后，父进程并没有对其消亡进行确认，该进程就保存进程表中，占用资源。



可以使用ps aux | grep Z查看当前的僵尸进程。

使用kill -s SIGCHLD pid删除该父进程的所有僵尸进程





19.4.2 孤儿进程



当父进程死亡后，进程就变为了孤儿进程，由init进程代为收养。同时由init进程对其资源释放。



父进程如何知道子进程的存亡， 子进程如何知道父进程的存亡

父进程可以使用waitpid查看子进程是否已经销毁，当其子进程销毁后，父进程会收到SIGCHD信号



子进程只需查看其ppid是否是1，也就是其父进程是否是init，是否被init收养。



19.5 守护进程

指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等



创建守护进程要点：



（1）让程序在后台执行。方法是调用fork（）产生一个子进程，然后使父进程退出。



（2）调用setsid（）创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响，方法是调用setsid（）使进程成为一个会话组长。setsid（）调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。



（3）禁止进程重新打开控制终端。经过以上步骤，进程已经成为一个无终端的会话组长，但是它可以重新申请打开一个终端。为了避免这种情况发生，可以通过使进程不再是会话组长来实现。再一次通过fork（）创建新的子进程，使调用fork的进程退出。



（4）关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的错误。首先获得最高文件描述符值，然后用一个循环程序，关闭0到最高文件描述符值的所有文件描述符。



（5）将当前目录更改为根目录。



（6）子进程从父进程继承的文件创建屏蔽字可能会拒绝某些许可权。为防止这一点，使用unmask（0）将屏蔽字清零。



（7）处理SIGCHLD信号。对于服务器进程，在请求到来时往往生成子进程处理请求。如果子进程等待父进程捕获状态，则子进程将成为僵尸进程（zombie），从而占用系统资源。如果父进程等待子进程结束，将增加父进程的负担，影响服务器进程的并发性能。在Linux下可以简单地将SIGCHLD信号的操作设为SIG_IGN。这样，子进程结束时不会产生僵尸进程。



二十、 copy-on-write 写时复制

写时复制是一种优化策略，当存在多个调用者请求相同资源时， 他们会共同获取相同的指针指向内存上的资源，而不是直接复制一份，仅当调用进程有写入需求时，操作系统才会真正的去分配一块资源来复制一份副本进行写入改动。







二十一、 问题

## 管道和套接字的区别

## 信号量的具体原理

信号量是为了进程的互斥与同步，多个进程通过相互传递信号进行合作，发明的一种信号设施。



其本质就是一个整数，当有进程想要使用该资源，就将通知信号量-1，再进行使用，使用结束后将信号量加回去，当发现信号量小于零时就代表没有资源可用，将进程挂起等待资源释放后在进行使用。否则直接进行使用无需等待。



## 多进程架构与多线程架构有什么区别

## 操作系统实现锁的方法

## 缓存一致性

保持缓存中的数据同步修改



## 原子操作如何实现

处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。



1. 所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。



2. 所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效

通常情况下，计算机上会运行着许多应用程序，它们都需要对内存和 CPU 进行交互，操作系统的目的就是为了保证这些访问和交互能够准确无误的进行。

操作系统的主要功能
一般来说，现代操作系统主要提供下面几种功能

进程管理: 进程管理的主要作用就是任务调度，在单核处理器下，操作系统会为每个进程分配一个任务，进程管理的工作十分简单；而在多核处理器下，操作系统除了要为进程分配任务外，还要解决处理器的调度、分配和回收等问题

内存管理：内存管理主要是操作系统负责管理内存的分配、回收，在进程需要时分配内存以及在进程完成时回收内存，协调内存资源，通过合理的页面置换算法进行页面的换入换出

设备管理：根据确定的设备分配原则对设备进行分配，使设备与主机能够并行工作，为用户提供良好的设备使用界面。

文件管理：有效地管理文件的存储空间，合理地组织和管理文件系统，为文件访问和文件保护提供更有效的方法及手段。

提供用户接口：操作系统提供了访问应用程序和硬件的接口，使用户能够通过应用程序发起系统调用从而操纵硬件，实现想要的功能。

软件访问硬件的几种方式
软件访问硬件其实就是一种 IO 操作，软件访问硬件的方式，也就是 I/O 操作的方式有哪些。

硬件在 I/O 上大致分为并行和串行，同时也对应串行接口和并行接口。

随着计算机技术的发展，I/O 控制方式也在不断发展。选择和衡量 I/O 控制方式有如下三条原则

（1） 数据传送速度足够快，能满足用户的需求但又不丢失数据；

（2） 系统开销小，所需的处理控制程序少；

（3） 能充分发挥硬件资源的能力，使 I/O 设备尽可能忙，而 CPU 等待时间尽可能少。

根据以上控制原则，I/O 操作可以分为四类

直接访问：直接访问由用户进程直接控制主存或 CPU 和外围设备之间的信息传送。直接程序控制方式又称为忙/等待方式。

中断驱动：为了减少程序直接控制方式下 CPU 的等待时间以及提高系统的并行程度，系统引入了中断机制。中断机制引入后，外围设备仅当操作正常结束或异常结束时才向 CPU 发出中断请求。在 I/O 设备输入每个数据的过程中，由于无需 CPU 的干预，一定程度上实现了 CPU 与 I/O 设备的并行工作。

上述两种方法的特点都是以 CPU 为中心，数据传送通过一段程序来实现，软件的传送手段限制了数据传送的速度。接下来介绍的这两种 I/O 控制方式采用硬件的方法来显示 I/O 的控制

DMA 直接内存访问：为了进一步减少 CPU 对 I/O 操作的干预，防止因并行操作设备过多使 CPU 来不及处理或因速度不匹配而造成的数据丢失现象，引入了 DMA 控制方式。

通道控制方式：通道，独立于 CPU 的专门负责输入输出控制的处理机，它控制设备与内存直接进行数据交换。有自己的通道指令，这些指令由 CPU 启动，并在操作结束时向 CPU 发出中断信号。

解释一下操作系统的主要目的是什么
操作系统是一种软件，它的主要目的有三种

管理计算机资源，这些资源包括 CPU、内存、磁盘驱动器、打印机等。

提供一种图形界面，就像我们前面描述的那样，它提供了用户和计算机之间的桥梁。

为其他软件提供服务，操作系统与软件进行交互，以便为其分配运行所需的任何必要资源。

操作系统的种类有哪些
操作系统通常预装在你购买计算机之前。大部分用户都会使用默认的操作系统，但是你也可以升级甚至更改操作系统。但是一般常见的操作系统只有三种：Windows、macOS 和 Linux。

为什么 Linux 系统下的应用程序不能直接在 Windows 下运行
这是一个老生常谈的问题了，在这里给出具体的回答。

其中一点是因为 Linux 系统和 Windows 系统的格式不同，格式就是协议，就是在固定位置有意义的数据。Linux 下的可执行程序文件格式是 elf，可以使用 readelf 命令查看 elf 文件头。

图片

而 Windows 下的可执行程序是 PE 格式，它是一种可移植的可执行文件。

还有一点是因为 Linux 系统和 Windows 系统的 API 不同，这个 API 指的就是操作系统的 API，Linux 中的 API 被称为系统调用，是通过 int 0x80 这个软中断实现的。而 Windows 中的 API 是放在动态链接库文件中的，也就是 Windows 开发人员所说的 DLL ，这是一个库，里面包含代码和数据。Linux 中的可执行程序获得系统资源的方法和 Windows 不一样，所以显然是不能在 Windows 中运行的。

操作系统结构
单体系统
在大多数系统中，整个系统在内核态以单一程序的方式运行。整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行程序，这种系统称为单体系统。

在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中

在单体系统中，对于每个系统调用都会有一个服务程序来保障和运行。需要一组实用程序来弥补服务程序需要的功能，例如从用户程序中获取数据。可将各种过程划分为一个三层模型

图片

除了在计算机初启动时所装载的核心操作系统外，许多操作系统还支持额外的扩展。比如 I/O 设备驱动和文件系统。这些部件可以按需装载。在 UNIX 中把它们叫做 共享库(shared library)，在 Windows 中则被称为 动态链接库(Dynamic Link Library,DLL)。他们的扩展名为 .dll，在 C:\Windows\system32 目录下存在 1000 多个 DLL 文件，所以不要轻易删除 C 盘文件，否则可能就炸了哦。

分层系统
分层系统使用层来分隔不同的功能单元。每一层只与该层的上层和下层通信。每一层都使用下面的层来执行其功能。层之间的通信通过预定义的固定接口通信。

图片

微内核
为了实现高可靠性，将操作系统划分成小的、层级之间能够更好定义的模块是很有必要的，只有一个模块 --- 微内核 --- 运行在内核态，其余模块可以作为普通用户进程运行。由于把每个设备驱动和文件系统分别作为普通用户进程，这些模块中的错误虽然会使这些模块崩溃，但是不会使整个系统死机。

MINIX 3 是微内核的代表作，它的具体结构如下

图片

在内核的外部，系统的构造有三层，它们都在用户态下运行，最底层是设备驱动器。由于它们都在用户态下运行，所以不能物理的访问 I/O 端口空间，也不能直接发出 I/O 命令。相反，为了能够对 I/O 设备编程，驱动器构建一个结构，指明哪个参数值写到哪个 I/O 端口，并声称一个内核调用，这样就完成了一次调用过程。

客户-服务器模式
微内核思想的策略是把进程划分为两类：服务器，每个服务器用来提供服务；客户端，使用这些服务。这个模式就是所谓的 客户-服务器模式。

客户-服务器模式会有两种载体，一种情况是一台计算机既是客户又是服务器，在这种方式下，操作系统会有某种优化；但是普遍情况下是客户端和服务器在不同的机器上，它们通过局域网或广域网连接。

图片

客户通过发送消息与服务器通信，客户端并不需要知道这些消息是在本地机器上处理，还是通过网络被送到远程机器上处理。对于客户端而言，这两种情形是一样的：都是发送请求并得到回应。

为什么称为陷入内核
如果把软件结构进行分层说明的话，应该是这个样子的，最外层是应用程序，里面是操作系统内核。

图片

应用程序处于特权级 3，操作系统内核处于特权级 0 。如果用户程序想要访问操作系统资源时，会发起系统调用，陷入内核，这样 CPU 就进入了内核态，执行内核代码。至于为什么是陷入，我们看图，内核是一个凹陷的构造，有陷下去的感觉，所以称为陷入。

什么是用户态和内核态
用户态和内核态是操作系统的两种运行状态。

内核态：处于内核态的 CPU 可以访问任意的数据，包括外围设备，比如网卡、硬盘等，处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况，一般处于特权级 0 的状态我们称之为内核态。

用户态：处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。

那么为什么要有用户态和内核态呢？

这个主要是访问能力的限制的考量，计算机中有一些比较危险的操作，比如设置时钟、内存清理，这些都需要在内核态下完成，如果随意进行这些操作，那你的系统得崩溃多少次。

用户态和内核态是如何切换的？
所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即用户态 -> 内核态 -> 用户态，而唯一能够做这些操作的只有 系统调用，而能够执行系统调用的就只有 操作系统。

一般用户态 -> 内核态的转换我们都称之为 trap 进内核，也被称之为 陷阱指令(trap instruction)。

他们的工作流程如下：

图片

首先用户程序会调用 glibc 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。

glibc 库知道针对不同体系结构调用系统调用的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。

然后，glibc 库调用软件中断指令(SWI) ，这个指令通过更新 CPSR 寄存器将模式改为超级用户模式，然后跳转到地址 0x08 处。

到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问

从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 vector_swi()。

在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 sys_call_table 的索引，调转到系统调用函数。

执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。

什么是内核
在计算机中，内核是一个计算机程序，它是操作系统的核心，可以控制操作系统中所有的内容。内核通常是在 boot loader 装载程序之前加载的第一个程序。

这里还需要了解一下什么是 boot loader。

boot loader 又被称为引导加载程序，能够将计算机的操作系统放入内存中。在电源通电或者计算机重启时，BIOS 会执行一些初始测试，然后将控制权转移到引导加载程序所在的主引导记录(MBR) 。

什么是实时系统
实时操作系统对时间做出了严格的要求，实时操作系统分为两种：硬实时和软实时

硬实时操作系统规定某个动作必须在规定的时刻内完成或发生，比如汽车生产车间，焊接机器必须在某一时刻内完成焊接，焊接的太早或者太晚都会对汽车造成永久性伤害。

软实时操作系统虽然不希望偶尔违反最终的时限要求，但是仍然可以接受。并且不会引起任何永久性伤害。比如数字音频、多媒体、手机都是属于软实时操作系统。

你可以简单理解硬实时和软实时的两个指标：是否在时刻内必须完成以及是否造成严重损害。

Linux 操作系统的启动过程
当计算机电源通电后，BIOS会进行开机自检(Power-On-Self-Test, POST)，对硬件进行检测和初始化。因为操作系统的启动会使用到磁盘、屏幕、键盘、鼠标等设备。下一步，磁盘中的第一个分区，也被称为 MBR(Master Boot Record) 主引导记录，被读入到一个固定的内存区域并执行。这个分区中有一个非常小的，只有 512 字节的程序。程序从磁盘中调入 boot 独立程序，boot 程序将自身复制到高位地址的内存从而为操作系统释放低位地址的内存。

复制完成后，boot 程序读取启动设备的根目录。boot 程序要理解文件系统和目录格式。然后 boot 程序被调入内核，把控制权移交给内核。直到这里，boot 完成了它的工作。系统内核开始运行。

内核启动代码是使用汇编语言完成的，主要包括创建内核堆栈、识别 CPU 类型、计算内存、禁用中断、启动内存管理单元等，然后调用 C 语言的 main 函数执行操作系统部分。

这部分也会做很多事情，首先会分配一个消息缓冲区来存放调试出现的问题，调试信息会写入缓冲区。如果调试出现错误，这些信息可以通过诊断程序调出来。

然后操作系统会进行自动配置，检测设备，加载配置文件，被检测设备如果做出响应，就会被添加到已链接的设备表中，如果没有相应，就归为未连接直接忽略。

配置完所有硬件后，接下来要做的就是仔细手工处理进程0，设置其堆栈，然后运行它，执行初始化、配置时钟、挂载文件系统。创建 init 进程(进程 1 ) 和 守护进程(进程 2)。

init 进程会检测它的标志以确定它是否为单用户还是多用户服务。在前一种情况中，它会调用 fork 函数创建一个 shell 进程，并且等待这个进程结束。后一种情况调用 fork 函数创建一个运行系统初始化的 shell 脚本（即 /etc/rc）的进程，这个进程可以进行文件系统一致性检测、挂载文件系统、开启守护进程等。

然后 /etc/rc 这个进程会从 /etc/ttys 中读取数据，/etc/ttys 列出了所有的终端和属性。对于每一个启用的终端，这个进程调用 fork 函数创建一个自身的副本，进行内部处理并运行一个名为 getty 的程序。

getty 程序会在终端上输入

login:
等待用户输入用户名，在输入用户名后，getty 程序结束，登陆程序 /bin/login 开始运行。login 程序需要输入密码，并与保存在 /etc/passwd 中的密码进行对比，如果输入正确，login 程序以用户 shell 程序替换自身，等待第一个命令。如果不正确，login 程序要求输入另一个用户名。

整个系统启动过程如下

图片

进程和线程篇
多处理系统的优势
随着处理器的不断增加，我们的计算机系统由单机系统变为了多处理系统，多处理系统的吞吐量比较高，多处理系统拥有多个并行的处理器，这些处理器共享时钟、内存、总线、外围设备等。

图片

多处理系统由于可以共享资源，因此可以开源节流，省钱。整个系统的可靠性也随之提高。

什么是进程和进程表
进程就是正在执行程序的实例，比如说 Web 程序就是一个进程，shell 也是一个进程，文章编辑器 typora 也是一个进程。

操作系统负责管理所有正在运行的进程，操作系统会为每个进程分配特定的时间来占用 CPU，操作系统还会为每个进程分配特定的资源。

操作系统为了跟踪每个进程的活动状态，维护了一个进程表。在进程表的内部，列出了每个进程的状态以及每个进程使用的资源等。

什么是线程，线程和进程的区别
这又是一道老生常谈的问题了，从操作系统的角度来回答一下吧。

我们上面说到进程是正在运行的程序的实例，而线程其实就是进程中的单条流向，因为线程具有进程中的某些属性，所以线程又被称为轻量级的进程。浏览器如果是一个进程的话，那么浏览器下面的每个 tab 页可以看作是一个个的线程。

下面是线程和进程持有资源的区别

图片

线程不像进程那样具有很强的独立性，线程之间会共享数据

创建线程的开销要比进程小很多，因为创建线程仅仅需要堆栈指针和程序计数器就可以了，而创建进程需要操作系统分配新的地址空间，数据资源等，这个开销比较大。

什么是上下文切换
对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。上下文切换 (Context Switch) 是一种 将 CPU 资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态 (包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。

使用多线程的好处是什么
多线程是程序员不得不知的基本素养之一，所以，下面我们给出一些多线程编程的好处

能够提高对用户的响应顺序

在流程中的资源共享

比较经济适用

能够对多线程架构有深入的理解

进程终止的方式
进程的终止
进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的

正常退出(自愿的)

错误退出(自愿的)

严重错误(非自愿的)

被其他进程杀死(非自愿的)

正常退出
多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 exit ，在 Windows 中是 ExitProcess。面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它所打开的任何临时文件，然后终止。

错误退出
进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令

cc foo.c    
为了能够编译 foo.c 但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。

严重错误
进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是 0 等。在有些系统比如 UNIX 中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。

被其他进程杀死
第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 TerminateProcess（注意不是系统调用）。

进程间的通信方式
进程间的通信方式比较多，首先你需要理解下面这几个概念

竞态条件：即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)。

临界区：不仅共享资源会造成竞态条件，事实上共享文件、共享内存也会造成竞态条件、那么该如何避免呢？或许一句话可以概括说明：禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写。换句话说，我们需要一种 互斥(mutual exclusion) 条件，这也就是说，如果一个进程在某种方式下使用共享变量和文件的话，除该进程之外的其他进程就禁止做这种事（访问统一资源）。

一个好的解决方案，应该包含下面四种条件

任何时候两个进程不能同时处于临界区

不应对 CPU 的速度和数量做任何假设

位于临界区外的进程不得阻塞其他进程

不能使任何进程无限等待进入临界区

图片

忙等互斥：当一个进程在对资源进行修改时，其他进程必须进行等待，进程之间要具有互斥性，我们讨论的解决方案其实都是基于忙等互斥提出的。

进程间的通信用专业一点的术语来表示就是 Inter Process Communication，IPC，它主要有下面 7。种通信方式

图片

消息传递：消息传递是进程间实现通信和同步等待的机制，使用消息传递，进程间的交流不需要共享变量，直接就可以进行通信；消息传递分为发送方和接收方

先进先出队列：先进先出队列指的是两个不相关联进程间的通信，两个进程之间可以彼此相互进程通信，这是一种全双工通信方式

管道：管道用于两个相关进程之间的通信，这是一种半双工的通信方式，如果需要全双工，需要另外一个管道。

直接通信：在这种进程通信的方式中，进程与进程之间只存在一条链接，进程间要明确通信双方的命名。

间接通信：间接通信是通信双方不会直接建立连接，而是找到一个中介者，这个中介者可能是个对象等等，进程可以在其中放置消息，并且可以从中删除消息，以此达到进程间通信的目的。

消息队列：消息队列是内核中存储消息的链表，它由消息队列标识符进行标识，这种方式能够在不同的进程之间提供全双工的通信连接。

共享内存：共享内存是使用所有进程之间的内存来建立连接，这种类型需要同步进程访问来相互保护。

进程间状态模型
进程的三态模型
当一个进程开始运行时，它可能会经历下面这几种状态

图片

图中会涉及三种状态

运行态：运行态指的就是进程实际占用 CPU 时间片运行时

就绪态：就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态

阻塞态：阻塞态又被称为睡眠态，它指的是进程不具备运行条件，正在等待被 CPU 调度。

逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程可运行，但是第二种情况没有获得 CPU 时间分片。第三种状态与前两种状态不同的原因是这个进程不能运行，CPU 空闲时也不能运行。

三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生状态1的轮转，在某些系统中进程执行系统调用，例如 pause，来获取一个阻塞的状态。在其他系统中包括 UNIX，当进程从管道或特殊文件（例如终端）中读取没有可用的输入时，该进程会被自动终止。

转换 2 和转换 3 都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。转换 2 的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行 CPU 时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得 CPU 时间片的时候了，就会发生转换 3。

程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。

当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换 4。如果此时没有其他进程在运行，则立刻触发转换 3，该进程便开始运行，否则该进程会处于就绪阶段，等待 CPU 空闲后再轮到它运行。

进程的五态模型
在三态模型的基础上，增加了两个状态，即 新建 和 终止 状态。

图片

新建态：进程的新建态就是进程刚创建出来的时候

创建进程需要两个步骤：即为新进程分配所需要的资源和空间，设置进程为就绪态，并等待调度执行。

终止态：进程的终止态就是指进程执行完毕，到达结束点，或者因为错误而不得不中止进程。

终止一个进程需要两个步骤：

先等待操作系统或相关的进程进行善后处理。

然后回收占用的资源并被系统删除。

调度算法都有哪些
调度算法分为三大类：批处理中的调度、交互系统中的调度、实时系统中的调度

批处理中的调度
先来先服务
很像是先到先得。。。可能最简单的非抢占式调度算法的设计就是 先来先服务(first-come,first-serverd)。使用此算法，将按照请求顺序为进程分配 CPU。最基本的，会有一个就绪进程的等待队列。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。

图片

这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。

不过，先来先服务也是有缺点的，那就是没有优先级的关系，试想一下，如果有 100 个 I/O 进程正在排队，第 101 个是一个 CPU 密集型进程，那岂不是需要等 100 个 I/O 进程运行完毕才会等到一个 CPU 密集型进程运行，这在实际情况下根本不可能，所以需要优先级或者抢占式进程的出现来优先选择重要的进程运行。

最短作业优先
批处理中，第二种调度算法是 最短作业优先(Shortest Job First)，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法

图片

如上图 a 所示，这里有 4 个作业 A、B、C、D ，运行时间分别为 8、4、4、4 分钟。若按图中的次序运行，则 A 的周转时间为 8 分钟，B 为 12 分钟，C 为 16 分钟，D 为 20 分钟，平均时间内为 14 分钟。

现在考虑使用最短作业优先算法运行 4 个作业，如上图 b 所示，目前的周转时间分别为 4、8、12、20，平均为 11 分钟，可以证明最短作业优先是最优的。考虑有 4 个作业的情况，其运行时间分别为 a、b、c、d。第一个作业在时间 a 结束，第二个在时间 a + b 结束，以此类推。平均周转时间为 (4a + 3b + 2c + d) / 4 。显然 a 对平均值的影响最大，所以 a 应该是最短优先作业，其次是 b，然后是 c ，最后是 d 它就只能影响自己的周转时间了。

需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。

最短剩余时间优先
最短作业优先的抢占式版本被称作为 最短剩余时间优先(Shortest Remaining Time Next) 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。当一个新作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，当前进程就被挂起，而运行新的进程。这种方式能够使短期作业获得良好的服务。

交互式系统中的调度
交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度

轮询调度
一种最古老、最简单、最公平并且最广泛使用的算法就是 轮询算法(round-robin)。每个进程都会被分配一个时间段，称为时间片(quantum)，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。

图片

优先级调度
事实情况是不是所有的进程都是优先级相等的。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了优先级调度(priority scheduling)

图片

它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。

但是也不意味着高优先级的进程能够永远一直运行下去，调度程序会在每个时钟中断期间降低当前运行进程的优先级。如果此操作导致其优先级降低到下一个最高进程的优先级以下，则会发生进程切换。或者，可以为每个进程分配允许运行的最大时间间隔。当时间间隔用完后，下一个高优先级的进程会得到运行的机会。

最短进程优先
对于批处理系统而言，由于最短作业优先常常伴随着最短响应时间，一种方式是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 T0，现在假设测量到其下一次运行时间为 T1，可以用两个值的加权来改进估计时间，即aT0+ (1- 1)T1。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列

图片

可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。

有时把这种通过当前测量值和先前估计值进行加权平均从而得到下一个估计值的技术称作 老化(aging)。这种方法会使用很多预测值基于当前值的情况。

彩票调度
有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 彩票调度(lottery scheduling)算法。他的基本思想为进程提供各种系统资源的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得资源。比如在 CPU 进行调度时，系统可以每秒持有 50 次抽奖，每个中奖进程会获得额外运行时间的奖励。

可以把彩票理解为 buff，这个 buff 有 15% 的几率能让你产生 速度之靴 的效果。

公平分享调度
如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。

为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。

影响调度程序的指标是什么
会有下面几个因素决定调度程序的好坏

CPU 使用率：

CPU 正在执行任务（即不处于空闲状态）的时间百分比。

等待时间

这是进程轮流执行的时间，也就是进程切换的时间

吞吐量

单位时间内完成进程的数量

响应时间

这是从提交流程到获得有用输出所经过的时间。

周转时间

从提交流程到完成流程所经过的时间。

什么是 RR 调度算法
RR(round-robin) 调度算法主要针对分时系统，RR 的调度算法会把时间片以相同的部分并循环的分配给每个进程，RR 调度算法没有优先级的概念。这种算法的实现比较简单，而且每个线程都会占有时间片，并不存在线程饥饿的问题。

内存管理篇
什么是按需分页
在操作系统中，进程是以页为单位加载到内存中的，按需分页是一种虚拟内存的管理方式。在使用请求分页的系统中，只有在尝试访问页面所在的磁盘并且该页面尚未在内存中时，也就发生了缺页异常，操作系统才会将磁盘页面复制到内存中。

什么是虚拟内存
虚拟内存是一种内存分配方案，是一项可以用来辅助内存分配的机制。我们知道，应用程序是按页装载进内存中的。但并不是所有的页都会装载到内存中，计算机中的硬件和软件会将数据从 RAM 临时传输到磁盘中来弥补内存的不足。如果没有虚拟内存的话，一旦你将计算机内存填满后，计算机会对你说

图片

呃，不，对不起，您无法再加载任何应用程序，请关闭另一个应用程序以加载新的应用程序。对于虚拟内存，计算机可以执行操作是查看内存中最近未使用过的区域，然后将其复制到硬盘上。虚拟内存通过复制技术实现了 妹子，你快来看哥哥能装这么多程序 的资本。复制是自动进行的，你无法感知到它的存在。

虚拟内存的实现方式
虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或永久的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存的实需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：

请求分页存储管理。

请求分段存储管理。

请求段页式存储管理。

不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：

一定容量的内存和外存。

页表机制（或段表机制），作为主要的数据结构。

中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。

地址变换机构，逻辑地址到物理地址的变换。

内存为什么要分段
内存是随机访问设备，对于内存来说，不需要从头开始查找，只需要直接给出地址即可。内存的分段是从 8086 CPU 开始的，8086 的 CPU 还是 16 位的寄存器宽，16 位的寄存器可以存储的数字范围是 2 的 16 次方，即 64 KB，8086 的 CPU 还没有 虚拟地址，只有物理地址，也就是说，如果两个相同的程序编译出来的地址相同，那么这两个程序是无法同时运行的。为了解决这个问题，操作系统设计人员提出了让 CPU 使用 段基址 + 段内偏移 的方式来访问任意内存。这样的好处是让程序可以 重定位，这也是内存为什么要分段的第一个原因。

那么什么是重定位呢？

简单来说就是将程序中的指令地址改为另一个地址，地址处存储的内容还是原来的。

CPU 采用段基址 + 段内偏移地址的形式访问内存，就需要提供专门的寄存器，这些专门的寄存器就是 CS、DS、ES 等。

也就是说，程序中需要用到哪块内存，就需要先加载合适的段到段基址寄存器中，再给出相对于该段基址的段偏移地址即可。CPU 中的地址加法器会将这两个地址进行合并，从地址总线送入内存。

8086 的 CPU 有 20 根地址总线，最大的寻址能力是 1MB，而段基址所在的寄存器宽度只有 16 位，最大为你 64 KB 的寻址能力，64 KB 显然不能满足 1MB 的最大寻址范围，所以就要把内存分段，每个段的最大寻址能力是 64KB，但是仍旧不能达到最大 1 MB 的寻址能力，所以这时候就需要 偏移地址的辅助，偏移地址也存入寄存器，同样为 64 KB 的寻址能力，这么一看还是不能满足 1MB 的寻址，所以 CPU 的设计者对地址单元动了手脚，将段基址左移 4 位，然后再和 16 位的段内偏移地址相加，就达到了 1MB 的寻址能力。所以内存分段的第二个目的就是能够访问到所有内存。

物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别
物理地址就是内存中真正的地址，它就相当于是你家的门牌号，你家就肯定有这个门牌号，具有唯一性。不管哪种地址，最终都会映射为物理地址。

在实模式下，段基址 + 段内偏移经过地址加法器的处理，经过地址总线传输，最终也会转换为物理地址。

但是在保护模式下，段基址 + 段内偏移被称为线性地址，不过此时的段基址不能称为真正的地址，而是会被称作为一个选择子的东西，选择子就是个索引，相当于数组的下标，通过这个索引能够在 GDT 中找到相应的段描述符，段描述符记录了段的起始、段的大小等信息，这样便得到了基地址。如果此时没有开启内存分页功能，那么这个线性地址可以直接当做物理地址来使用，直接访问内存。如果开启了分页功能，那么这个线性地址又多了一个名字，这个名字就是虚拟地址。

不论在实模式还是保护模式下，段内偏移地址都叫做有效地址。有效抵制也是逻辑地址。

线性地址可以看作是虚拟地址，虚拟地址不是真正的物理地址，但是虚拟地址会最终被映射为物理地址。下面是虚拟地址 -> 物理地址的映射。

图片

空闲内存管理的方式
操作系统在动态分配内存时（malloc，new），需要对空间内存进行管理。一般采用了两种方式：位图和空闲链表。

使用位图进行管理
使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下

图片

å图 a 表示一段有 5 个进程和 3 个空闲区的内存，刻度为内存分配单元，阴影区表示空闲（在位图中用 0 表示）；图 b 表示对应的位图；图 c 表示用链表表示同样的信息

分配单元的大小是一个重要的设计因素，分配单位越小，位图越大。然而，即使只有 4 字节的分配单元，32 位的内存也仅仅只需要位图中的 1 位。32n 位的内存需要 n 位的位图，所以1 个位图只占用了 1/32 的内存。如果选择更大的内存单元，位图应该要更小。如果进程的大小不是分配单元的整数倍，那么在最后一个分配单元中会有大量的内存被浪费。

位图提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为位图的大小取决于内存和分配单元的大小。这种方法有一个问题，当决定为把具有 k 个分配单元的进程放入内存时，内容管理器(memory manager) 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）

使用空闲链表
另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c 来表示内存的使用情况。链表中的每一项都可以代表一个 空闲区(H) 或者是进程(P)的起始标志，长度和下一个链表项的位置。

在这个例子中，段链表(segment list)是按照地址排序的。这种方式的优点是，当进程终止或被交换时，更新列表很简单。一个终止进程通常有两个邻居（除了内存的顶部和底部外）。相邻的可能是进程也可能是空闲区，它们有四种组合方式。

图片

当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。

首次适配算法：在链表中进行搜索，直到找到最初的一个足够大的空闲区，将其分配。除非进程大小和空间区大小恰好相同，否则会将空闲区分为两部分，一部分为进程使用，一部分成为新的空闲区。该方法是速度很快的算法，因为索引链表结点的个数较少。

下次适配算法：工作方式与首次适配算法相同，但每次找到新的空闲区位置后都记录当前位置，下次寻找空闲区从上次结束的地方开始搜索，而不是与首次适配一样从头开始；

最佳适配算法：搜索整个链表，找出能够容纳进程分配的最小的空闲区。这样存在的问题是，尽管可以保证为进程找到一个最为合适的空闲区进行分配，但大多数情况下，这样的空闲区被分为两部分，一部分用于进程分配，一部分会生成很小的空闲区，而这样的空闲区很难再被进行利用。

最差适配算法：与最佳适配算法相反，每次分配搜索最大的空闲区进行分配，从而可以使得空闲区拆分得到的新的空闲区可以更好的被进行利用。

页面置换算法都有哪些
在地址映射过程中，如果在页面中发现所要访问的页面不在内存中，那么就会产生一条缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，那么操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。

下面我汇总的这些页面置换算法比较齐全，只给出简单介绍，算法具体的实现和原理读者可以自行了解。

图片

最优算法在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，因此实际上该算法不能使用。然而，它可以作为衡量其他算法的标准。

NRU 算法根据 R 位和 M 位的状态将页面分为四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。

FIFO 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。

第二次机会算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。

时钟 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。

LRU 算法是一个非常优秀的算法，但是没有特殊的硬件(TLB)很难实现。如果没有硬件，就不能使用 LRU 算法。

NFU 算法是一种近似于 LRU 的算法，它的性能不是非常好。

老化 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择

最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。WSClock 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。

最好的算法是老化算法和WSClock算法。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。

文件系统篇
提高文件系统性能的方式
访问磁盘的效率要比内存慢很多，是时候又祭出这张图了

图片

所以磁盘优化是很有必要的，下面我们会讨论几种优化方式

高速缓存
最常用的减少磁盘访问次数的技术是使用 块高速缓存(block cache) 或者 缓冲区高速缓存(buffer cache)。高速缓存指的是一系列的块，它们在逻辑上属于磁盘，但实际上基于性能的考虑被保存在内存中。

管理高速缓存有不同的算法，常用的算法是：检查全部的读请求，查看在高速缓存中是否有所需要的块。如果存在，可执行读操作而无须访问磁盘。如果检查块不再高速缓存中，那么首先把它读入高速缓存，再复制到所需的地方。之后，对同一个块的请求都通过高速缓存来完成。

高速缓存的操作如下图所示

图片

由于在高速缓存中有许多块，所以需要某种方法快速确定所需的块是否存在。常用方法是将设备和磁盘地址进行散列操作。然后在散列表中查找结果。具有相同散列值的块在一个链表中连接在一起（这个数据结构是不是很像 HashMap?），这样就可以沿着冲突链查找其他块。

如果高速缓存已满，此时需要调入新的块，则要把原来的某一块调出高速缓存，如果要调出的块在上次调入后已经被修改过，则需要把它写回磁盘。这种情况与分页非常相似。

块提前读
第二个明显提高文件系统的性能是在需要用到块之前试图提前将其写入高速缓存从而提高命中率。许多文件都是顺序读取。如果请求文件系统在某个文件中生成块 k，文件系统执行相关操作并且在完成之后，会检查高速缓存，以便确定块 k + 1 是否已经在高速缓存。如果不在，文件系统会为 k + 1 安排一个预读取，因为文件希望在用到该块的时候能够直接从高速缓存中读取。

当然，块提前读取策略只适用于实际顺序读取的文件。对随机访问的文件，提前读丝毫不起作用。甚至还会造成阻碍。

减少磁盘臂运动
高速缓存和块提前读并不是提高文件系统性能的唯一方法。另一种重要的技术是把有可能顺序访问的块放在一起，当然最好是在同一个柱面上，从而减少磁盘臂的移动次数。当写一个输出文件时，文件系统就必须按照要求一次一次地分配磁盘块。如果用位图来记录空闲块，并且整个位图在内存中，那么选择与前一块最近的空闲块是很容易的。如果用空闲表，并且链表的一部分存在磁盘上，要分配紧邻的空闲块就会困难很多。

不过，即使采用空闲表，也可以使用 块簇 技术。即不用块而用连续块簇来跟踪磁盘存储区。如果一个扇区有 512 个字节，有可能系统采用 1 KB 的块（2 个扇区），但却按每 2 块（4 个扇区）一个单位来分配磁盘存储区。这和 2 KB 的磁盘块并不相同，因为在高速缓存中它仍然使用 1 KB 的块，磁盘与内存数据之间传送也是以 1 KB 进行，但在一个空闲的系统上顺序读取这些文件，寻道的次数可以减少一半，从而使文件系统的性能大大改善。若考虑旋转定位则可以得到这类方法的变体。在分配块时，系统尽量把一个文件中的连续块存放在同一个柱面上。

在使用 inode 或任何类似 inode 的系统中，另一个性能瓶颈是，读取一个很短的文件也需要两次磁盘访问：一次是访问 inode，一次是访问块。通常情况下，inode 的放置如下图所示

图片

其中，全部 inode 放在靠近磁盘开始位置，所以 inode 和它所指向的块之间的平均距离是柱面组的一半，这将会需要较长时间的寻道时间。

一个简单的改进方法是，在磁盘中部而不是开始处存放 inode ，此时，在 inode 和第一个块之间的寻道时间减为原来的一半。另一种做法是：将磁盘分成多个柱面组，每个柱面组有自己的 inode，数据块和空闲表，如上图 b 所示。

当然，只有在磁盘中装有磁盘臂的情况下，讨论寻道时间和旋转时间才是有意义的。现在越来越多的电脑使用 固态硬盘(SSD)，对于这些硬盘，由于采用了和闪存同样的制造技术，使得随机访问和顺序访问在传输速度上已经较为相近，传统硬盘的许多问题就消失了。但是也引发了新的问题。

磁盘碎片整理
在初始安装操作系统后，文件就会被不断的创建和清除，于是磁盘会产生很多的碎片，在创建一个文件时，它使用的块会散布在整个磁盘上，降低性能。删除文件后，回收磁盘块，可能会造成空穴。

磁盘性能可以通过如下方式恢复：移动文件使它们相互挨着，并把所有的至少是大部分的空闲空间放在一个或多个大的连续区域内。Windows 有一个程序 defrag 就是做这个事儿的。Windows 用户会经常使用它，SSD 除外。

磁盘碎片整理程序会在让文件系统上很好地运行。Linux 文件系统（特别是 ext2 和 ext3）由于其选择磁盘块的方式，在磁盘碎片整理上一般不会像 Windows 一样困难，因此很少需要手动的磁盘碎片整理。而且，固态硬盘并不受磁盘碎片的影响，事实上，在固态硬盘上做磁盘碎片整理反倒是多此一举，不仅没有提高性能，反而磨损了固态硬盘。所以碎片整理只会缩短固态硬盘的寿命。

磁盘臂调度算法
一般情况下，影响磁盘快读写的时间由下面几个因素决定

寻道时间 - 寻道时间指的就是将磁盘臂移动到需要读取磁盘块上的时间

旋转延迟 - 等待合适的扇区旋转到磁头下所需的时间

实际数据的读取或者写入时间

这三种时间参数也是磁盘寻道的过程。一般情况下，寻道时间对总时间的影响最大，所以，有效的降低寻道时间能够提高磁盘的读取速度。

如果磁盘驱动程序每次接收一个请求并按照接收顺序完成请求，这种处理方式也就是 先来先服务(First-Come, First-served, FCFS) ，这种方式很难优化寻道时间。因为每次都会按照顺序处理，不管顺序如何，有可能这次读完后需要等待一个磁盘旋转一周才能继续读取，而其他柱面能够马上进行读取，这种情况下每次请求也会排队。

通常情况下，磁盘在进行寻道时，其他进程会产生其他的磁盘请求。磁盘驱动程序会维护一张表，表中会记录着柱面号当作索引，每个柱面未完成的请求会形成链表，链表头存放在表的相应表项中。

一种对先来先服务的算法改良的方案是使用 最短路径优先(SSF) 算法，下面描述了这个算法。

假如我们在对磁道 6 号进行寻址时，同时发生了对 11 , 2 , 4, 14, 8, 15, 3 的请求，如果采用先来先服务的原则，如下图所示

图片

我们可以计算一下磁盘臂所跨越的磁盘数量为 5 + 9 + 2 + 10 + 6 + 7 + 12 = 51，相当于是跨越了 51 次盘面，如果使用最短路径优先，我们来计算一下跨越的盘面

图片

跨越的磁盘数量为 4 + 1 + 1 + 4 + 3 + 3 + 1 = 17 ，相比 51 足足省了两倍的时间。

但是，最短路径优先的算法也不是完美无缺的，这种算法照样存在问题，那就是优先级 问题，

这里有一个原型可以参考就是我们日常生活中的电梯，电梯使用一种电梯算法(elevator algorithm) 来进行调度，从而满足协调效率和公平性这两个相互冲突的目标。电梯一般会保持向一个方向移动，直到在那个方向上没有请求为止，然后改变方向。

电梯算法需要维护一个二进制位，也就是当前的方向位：UP(向上)或者是 DOWN(向下)。当一个请求处理完成后，磁盘或电梯的驱动程序会检查该位，如果此位是 UP 位，磁盘臂或者电梯仓移到下一个更高跌未完成的请求。如果高位没有未完成的请求，则取相反方向。当方向位是 DOWN时，同时存在一个低位的请求，磁盘臂会转向该点。如果不存在的话，那么它只是停止并等待。

我们举个例子来描述一下电梯算法，比如各个柱面得到服务的顺序是 4，7，10，14，9，6，3，1 ，那么它的流程图如下

图片

所以电梯算法需要跨越的盘面数量是 3 + 3 + 4 + 5 + 3 + 3 + 1 = 22

电梯算法通常情况下不如 SSF 算法。

一些磁盘控制器为软件提供了一种检查磁头下方当前扇区号的方法，使用这样的控制器，能够进行另一种优化。如果对一个相同的柱面有两个或者多个请求正等待处理，驱动程序可以发出请求读写下一次要通过磁头的扇区。

这里需要注意一点，当一个柱面有多条磁道时，相继的请求可能针对不同的磁道，这种选择没有代价，因为选择磁头不需要移动磁盘臂也没有旋转延迟。

对于磁盘来说，最影响性能的就是寻道时间和旋转延迟，所以一次只读取一个或两个扇区的效率是非常低的。出于这个原因，许多磁盘控制器总是读出多个扇区并进行高速缓存，即使只请求一个扇区时也是这样。一般情况下读取一个扇区的同时会读取该扇区所在的磁道或者是所有剩余的扇区被读出，读出扇区的数量取决于控制器的高速缓存中有多少可用的空间。

磁盘控制器的高速缓存和操作系统的高速缓存有一些不同，磁盘控制器的高速缓存用于缓存没有实际被请求的块，而操作系统维护的高速缓存由显示地读出的块组成，并且操作系统会认为这些块在近期仍然会频繁使用。

当同一个控制器上有多个驱动器时，操作系统应该为每个驱动器都单独的维护一个未完成的请求表。一旦有某个驱动器闲置时，就应该发出一个寻道请求来将磁盘臂移到下一个被请求的柱面。如果下一个寻道请求到来时恰好没有磁盘臂处于正确的位置，那么驱动程序会在刚刚完成传输的驱动器上发出一个新的寻道命令并等待，等待下一次中断到来时检查哪个驱动器处于闲置状态。

RAID 的不同级别
RAID 称为 磁盘冗余阵列，简称 磁盘阵列。利用虚拟化技术把多个硬盘结合在一起，成为一个或多个磁盘阵列组，目的是提升性能或数据冗余。

RAID 有不同的级别

RAID 0 - 无容错的条带化磁盘阵列

RAID 1 - 镜像和双工

RAID 2 - 内存式纠错码

RAID 3 - 比特交错奇偶校验

RAID 4 - 块交错奇偶校验

RAID 5 - 块交错分布式奇偶校验

RAID 6 - P + Q冗余

IO 篇
操作系统中的时钟是什么
时钟(Clocks) 也被称为定时器(timers)，时钟/定时器对任何程序系统来说都是必不可少的。时钟负责维护时间、防止一个进程长期占用 CPU 时间等其他功能。时钟软件(clock software) 也是一种设备驱动的方式。下面我们就来对时钟进行介绍，一般都是先讨论硬件再介绍软件，采用由下到上的方式，也是告诉你，底层是最重要的。

时钟硬件
在计算机中有两种类型的时钟，这些时钟与现实生活中使用的时钟完全不一样。

比较简单的一种时钟被连接到 110 V 或 220 V 的电源线上，这样每个电压周期会产生一个中断，大概是 50 - 60 HZ。这些时钟过去一直占据支配地位。

另外的一种时钟由晶体振荡器、计数器和寄存器组成，示意图如下所示

图片

这种时钟称为可编程时钟 ，可编程时钟有两种模式，一种是 一键式(one-shot mode)，当时钟启动时，会把存储器中的值复制到计数器中，然后，每次晶体的振荡器的脉冲都会使计数器 -1。当计数器变为 0 时，会产生一个中断，并停止工作，直到软件再一次显示启动。还有一种模式是 方波(square-wave mode) 模式，在这种模式下，当计数器变为 0 并产生中断后，存储寄存器的值会自动复制到计数器中，这种周期性的中断称为一个时钟周期。

设备控制器的主要功能
设备控制器是一个可编址的设备，当它仅控制一个设备时，它只有一个唯一的设备地址；如果设备控制器控制多个可连接设备时，则应含有多个设备地址，并使每一个设备地址对应一个设备。

设备控制器主要分为两种：字符设备和块设备

设备控制器的主要功能有下面这些

接收和识别命令：设备控制器可以接受来自 CPU 的指令，并进行识别。设备控制器内部也会有寄存器，用来存放指令和参数

进行数据交换：CPU、控制器和设备之间会进行数据的交换，CPU 通过总线把指令发送给控制器，或从控制器中并行地读出数据；控制器将数据写入指定设备。

地址识别：每个硬件设备都有自己的地址，设备控制器能够识别这些不同的地址，来达到控制硬件的目的，此外，为使 CPU 能向寄存器中写入或者读取数据，这些寄存器都应具有唯一的地址。

差错检测：设备控制器还具有对设备传递过来的数据进行检测的功能。

中断处理过程
中断处理方案有很多种，下面是 《ARM System Developer’s Guide

Designing and Optimizing System Software》列出来的一些方案

非嵌套的中断处理程序按照顺序处理各个中断，非嵌套的中断处理程序也是最简单的中断处理

嵌套的中断处理程序会处理多个中断而无需分配优先级

可重入的中断处理程序可使用优先级处理多个中断

简单优先级中断处理程序可处理简单的中断

标准优先级中断处理程序比低优先级的中断处理程序在更短的时间能够处理优先级更高的中断

高优先级 中断处理程序在短时间能够处理优先级更高的任务，并直接进入特定的服务例程。

优先级分组中断处理程序能够处理不同优先级的中断任务

下面是一些通用的中断处理程序的步骤，不同的操作系统实现细节不一样

保存所有没有被中断硬件保存的寄存器

为中断服务程序设置上下文环境，可能包括设置 TLB、MMU 和页表，如果不太了解这三个概念，请参考另外一篇文章

为中断服务程序设置栈

对中断控制器作出响应，如果不存在集中的中断控制器，则继续响应中断

把寄存器从保存它的地方拷贝到进程表中

运行中断服务程序，它会从发出中断的设备控制器的寄存器中提取信息

操作系统会选择一个合适的进程来运行。如果中断造成了一些优先级更高的进程变为就绪态，则选择运行这些优先级高的进程

为进程设置 MMU 上下文，可能也会需要 TLB，根据实际情况决定

加载进程的寄存器，包括 PSW 寄存器

开始运行新的进程

上面我们罗列了一些大致的中断步骤，不同性质的操作系统和中断处理程序能够处理的中断步骤和细节也不尽相同，下面是一个嵌套中断的具体运行步骤

图片

什么是设备驱动程序
在计算机中，设备驱动程序是一种计算机程序，它能够控制或者操作连接到计算机的特定设备。驱动程序提供了与硬件进行交互的软件接口，使操作系统和其他计算机程序能够访问特定设备，不用需要了解其硬件的具体构造。

什么是 DMA
DMA 的中文名称是直接内存访问，它意味着 CPU 授予 I/O 模块权限在不涉及 CPU 的情况下读取或写入内存。也就是 DMA 可以不需要 CPU 的参与。这个过程由称为 DMA 控制器（DMAC）的芯片管理。由于 DMA 设备可以直接在内存之间传输数据，而不是使用 CPU 作为中介，因此可以缓解总线上的拥塞。DMA 通过允许 CPU 执行任务，同时 DMA 系统通过系统和内存总线传输数据来提高系统并发性。

直接内存访问的特点
DMA 方式有如下特点：

数据传送以数据块为基本单位

所传送的数据从设备直接送入主存，或者从主存直接输出到设备上

仅在传送一个或多个数据块的开始和结束时才需 CPU 的干预，而整块数据的传送则是在控制器的控制下完成。

DMA 方式和中断驱动控制方式相比，减少了 CPU 对 I/O 操作的干预，进一步提高了 CPU 与 I/O 设备的并行操作程度。

DMA 方式的线路简单、价格低廉，适合高速设备与主存之间的成批数据传送，小型、微型机中的快速设备均采用这种方式，但其功能较差，不能满足复杂的 I/O 要求。

死锁篇
什么是僵尸进程
僵尸进程是已完成且处于终止状态，但在进程表中却仍然存在的进程。僵尸进程通常发生在父子关系的进程中，由于父进程仍需要读取其子进程的退出状态所造成的。

死锁产生的原因
死锁产生的原因大致有两个：资源竞争和程序执行顺序不当

死锁产生的必要条件
资源死锁可能出现的情况主要有

互斥条件：每个资源都被分配给了一个进程或者资源是可用的

保持和等待条件：已经获取资源的进程被认为能够获取新的资源

不可抢占条件：分配给一个进程的资源不能强制的从其他进程抢占资源，它只能由占有它的进程显示释放

循环等待：死锁发生时，系统中一定有两个或者两个以上的进程组成一个循环，循环中的每个进程都在等待下一个进程释放的资源。

死锁的恢复方式
所以针对检测出来的死锁，我们要对其进行恢复，下面我们会探讨几种死锁的恢复方式

通过抢占进行恢复
在某些情况下，可能会临时将某个资源从它的持有者转移到另一个进程。比如在不通知原进程的情况下，将某个资源从进程中强制取走给其他进程使用，使用完后又送回。这种恢复方式一般比较困难而且有些简单粗暴，并不可取。

通过回滚进行恢复
如果系统设计者和机器操作员知道有可能发生死锁，那么就可以定期检查流程。进程的检测点意味着进程的状态可以被写入到文件以便后面进行恢复。检测点不仅包含存储映像(memory image)，还包含资源状态(resource state)。一种更有效的解决方式是不要覆盖原有的检测点，而是每出现一个检测点都要把它写入到文件中，这样当进程执行时，就会有一系列的检查点文件被累积起来。

为了进行恢复，要从上一个较早的检查点上开始，这样所需要资源的进程会回滚到上一个时间点，在这个时间点上，死锁进程还没有获取所需要的资源，可以在此时对其进行资源分配。

杀死进程恢复
最简单有效的解决方案是直接杀死一个死锁进程。但是杀死一个进程可能照样行不通，这时候就需要杀死别的资源进行恢复。

另外一种方式是选择一个环外的进程作为牺牲品来释放进程资源。

如何破坏死锁
和死锁产生的必要条件一样，如果要破坏死锁，也是从下面四种方式进行破坏。

破坏互斥条件
我们首先考虑的就是破坏互斥使用条件。如果资源不被一个进程独占，那么死锁肯定不会产生。如果两个打印机同时使用一个资源会造成混乱，打印机的解决方式是使用 假脱机打印机(spooling printer) ，这项技术可以允许多个进程同时产生输出，在这种模型中，实际请求打印机的唯一进程是打印机守护进程，也称为后台进程。后台进程不会请求其他资源。我们可以消除打印机的死锁。

后台进程通常被编写为能够输出完整的文件后才能打印，假如两个进程都占用了假脱机空间的一半，而这两个进程都没有完成全部的输出，就会导致死锁。

因此，尽量做到尽可能少的进程可以请求资源。

破坏保持等待的条件
第二种方式是如果我们能阻止持有资源的进程请求其他资源，我们就能够消除死锁。一种实现方式是让所有的进程开始执行前请求全部的资源。如果所需的资源可用，进程会完成资源的分配并运行到结束。如果有任何一个资源处于频繁分配的情况，那么没有分配到资源的进程就会等待。

很多进程无法在执行完成前就知道到底需要多少资源，如果知道的话，就可以使用银行家算法；还有一个问题是这样无法合理有效利用资源。

还有一种方式是进程在请求其他资源时，先释放所占用的资源，然后再尝试一次获取全部的资源。

破坏不可抢占条件
破坏不可抢占条件也是可以的。可以通过虚拟化的方式来避免这种情况。

破坏循环等待条件
现在就剩最后一个条件了，循环等待条件可以通过多种方法来破坏。一种方式是制定一个标准，一个进程在任何时候只能使用一种资源。如果需要另外一种资源，必须释放当前资源。

另一种方式是将所有的资源统一编号，如下图所示

图片

进程可以在任何时间提出请求，但是所有的请求都必须按照资源的顺序提出。如果按照此分配规则的话，那么资源分配之间不会出现环。

图片

死锁类型
两阶段加锁
虽然很多情况下死锁的避免和预防都能处理，但是效果并不好。随着时间的推移，提出了很多优秀的算法用来处理死锁。例如在数据库系统中，一个经常发生的操作是请求锁住一些记录，然后更新所有锁定的记录。当同时有多个进程运行时，就会有死锁的风险。

一种解决方式是使用 两阶段提交(two-phase locking)。顾名思义分为两个阶段，一阶段是进程尝试一次锁定它需要的所有记录。如果成功后，才会开始第二阶段，第二阶段是执行更新并释放锁。第一阶段并不做真正有意义的工作。

如果在第一阶段某个进程所需要的记录已经被加锁，那么该进程会释放所有锁定的记录并重新开始第一阶段。从某种意义上来说，这种方法类似于预先请求所有必需的资源或者是在进行一些不可逆的操作之前请求所有的资源。

不过在一般的应用场景中，两阶段加锁的策略并不通用。如果一个进程缺少资源就会半途中断并重新开始的方式是不可接受的。

通信死锁
我们上面一直讨论的是资源死锁，资源死锁是一种死锁类型，但并不是唯一类型，还有通信死锁，也就是两个或多个进程在发送消息时出现的死锁。进程 A 给进程 B 发了一条消息，然后进程 A 阻塞直到进程 B 返回响应。假设请求消息丢失了，那么进程 A 在一直等着回复，进程 B 也会阻塞等待请求消息到来，这时候就产生死锁。

尽管会产生死锁，但是这并不是一个资源死锁，因为 A 并没有占据 B 的资源。事实上，通信死锁并没有完全可见的资源。根据死锁的定义来说：每个进程因为等待其他进程引起的事件而产生阻塞，这就是一种死锁。相较于最常见的通信死锁，我们把上面这种情况称为通信死锁(communication deadlock)。

通信死锁不能通过调度的方式来避免，但是可以使用通信中一个非常重要的概念来避免：超时(timeout)。在通信过程中，只要一个信息被发出后，发送者就会启动一个定时器，定时器会记录消息的超时时间，如果超时时间到了但是消息还没有返回，就会认为消息已经丢失并重新发送，通过这种方式，可以避免通信死锁。

但是并非所有网络通信发生的死锁都是通信死锁，也存在资源死锁，下面就是一个典型的资源死锁。

当一个数据包从主机进入路由器时，会被放入一个缓冲区，然后再传输到另外一个路由器，再到另一个，以此类推直到目的地。缓冲区都是资源并且数量有限。如下图所示，每个路由器都有 10 个缓冲区（实际上有很多）。

图片

假如路由器 A 的所有数据需要发送到 B ，B 的所有数据包需要发送到 D，然后 D 的所有数据包需要发送到 A 。没有数据包可以移动，因为在另一端没有缓冲区可用，这就是一个典型的资源死锁。

活锁
某些情况下，当进程意识到它不能获取所需要的下一个锁时，就会尝试礼貌的释放已经获得的锁，然后等待非常短的时间再次尝试获取。可以想像一下这个场景：当两个人在狭路相逢的时候，都想给对方让路，相同的步调会导致双方都无法前进。

现在假想有一对并行的进程用到了两个资源。它们分别尝试获取另一个锁失败后，两个进程都会释放自己持有的锁，再次进行尝试，这个过程会一直进行重复。很明显，这个过程中没有进程阻塞，但是进程仍然不会向下执行，这种状况我们称之为 活锁(livelock)。

饥饿
与死锁和活锁的一个非常相似的问题是 饥饿(starvvation)。想象一下你什么时候会饿？一段时间不吃东西是不是会饿？对于进程来讲，最重要的就是资源，如果一段时间没有获得资源，那么进程会产生饥饿，这些进程会永远得不到服务。

我们假设打印机的分配方案是每次都会分配给最小文件的进程，那么要打印大文件的进程会永远得不到服务，导致进程饥饿，进程会无限制的推后，虽然它没有阻塞。

