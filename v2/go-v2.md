## 基础

### 基础数据结构

#### slice相关
---

底层实现
```
    切片是对数组一个连续片段的引用，是一个引用类型；
    本身是一个只读对象,其工作机制类似数据指针的一种封装；
    type slice sturct{
        array unsafe.Pointer //引用的数组指针
        len int //数组长度
        cap int //容量
    }
```
    
nil和空切片
```
nil切片:
    长度和容量都为0,和nil比较的结果为true
empty切片:
    长度和容量都为0,所有的空切片的数据指针都指向一个地址
    空切片和nil比较为false
区别是:
    空切片指向的地址不是nil，指向的是一个内存地址
    但是它没有分配任何内存空间，即底层元素包含0个元素
note:
    所有的空切片的数据指针指向同一个地址
```
reslice
```
定义:
    基于已有的slice创建新的slice对象
新slice和老slice共用底层数组,新老slice对底层数组的更改
都会影响到彼此
note:
    新老slice或者新slice 老数组互相影响的前提是两者共用底层数组
    如果因为执行 append 操作使得新 slice 底层数组扩容,移动到了新的位置,
    两者就不会相互影响了.所以,问题的关键在于两者是否会共用底层数组
```
扩容规则
```
1. 如果新申请的容量大于2倍的旧容量,最终容量就是新申请的容量
2. 否则，判断旧容量的长度小于1024,则最终容量就是旧容量的2倍
3. 否则，判断旧容量大于等于1024，则最终容量从旧容量开始循环增加
    原来的1/4，直至最终容量大于等于新申请的容量
    (分配之后都newcap做了内存对齐,这个和内存分配策略有关,新的slice容量
    要大于等于老slice容量的2倍或1.25倍)
4. 如果最终容量计算值溢出，则最终容量就是新申请的容量（TODO:溢出什么意思）
问题: 
    1. 扩容之后的数组一定是新的吗？
       不一定，如果数组长度满足扩容需求，会在原数组的基础上扩容
```
slice和array的区别
```
array: 
    1.数组长度固定，长度是数组类型的一部分;
    [3]int与[4]int是2种不同的类型
    2. 数组复制和传参都是值拷贝
slice: 
    1.切片非固定长度,包含长度，指针，容量三个属性
    2. 切片作为引用传递
```
为什么 nil slice 可以直接 append
```
    其实 nil slice 或者 empty slice 都是可以通过调用 append 函数来获得底层数组的扩容
    最终都是调用 mallocgc 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的nil slice 
    或 empty slice,然后摇身一变，成为“真正”的 slice 了
```
传 slice 和 slice 指针有什么区别
```
当 slice 作为函数参数时,就是一个普通的结构体
1. 若直接传 slice，在调用者看来,实参 slice 并不会被函数中的操作改变
2. 若传的是 slice 的指针，在调用者看来，是会被改变原 slice 的。
值的注意的是,不管传的是 slice 还是 slice 指针，
如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据
总结:
    当直接用切片作为函数参数时,可以改变切片的元素,不能改变切片本身;
    想要改变切片本身,可以将改变后的切片返回,函数调用者接收改变后的切片或者将切片指针作为函数参数
```

#### map相关
---
数据结构
```
// A header for a Go map.
type hmap struct {
    // 元素个数，调用 len(map) 时，直接返回此值
	count     int
	flags     uint8
	// buckets 的对数 log_2
	B         uint8
	// overflow 的 bucket 近似数
	noverflow uint16
	// 计算 key 的哈希的时候会传入哈希函数
	hash0     uint32
    // 指向 buckets 数组，大小为 2^B
    // 如果元素个数为0，就为 nil
	buckets    unsafe.Pointer
	// 扩容的时候，buckets 长度会是 oldbuckets 的两倍
	oldbuckets unsafe.Pointer
	// 指示扩容进度，小于此地址的 buckets 迁移完成
	nevacuate  uintptr
	extra *mapextra // optional fields
}
```
![map结构](https://user-images.githubusercontent.com/7698088/57576986-acd87600-749f-11e9-8710-75e423c7efdb.png)

扩容规则
```
底层使用hash表,是无序的
解决冲突办法:
    1 开放寻址法,多次寻址
    2 开链法
扩容规则:
    负载因子>6.5: 
        进行翻倍扩容,存储时新旧桶都存储数据,同时每次操作时也迁移部分数据
        迁移结束时,销毁旧桶
    负载因子没超标,但溢出桶太多: 等量扩容
    桶的数量>2^4时使用溢出桶
    溢出桶太多判断: 常规桶数量 <= 2^15 , 溢出桶>=2^桶数量
                   常规桶数量 > 2^15, 溢出桶数量> 2^15
    等量扩容的意义:
        溢出桶太多基本由于删除太多,等量扩容相当于重新hash,能够减少
        溢出桶的使用,使数据存储的更加紧凑
```
内存泄漏:
```
TODO:
    map扩容过程中会申请新的内存,扩容完成老的内存不会立即释放
    需要进一步了解原因
```
note:
```
    map是一个可以存储key/value对的数据结构,是一个引用类型；
    内部实现了一个hash table，因此map中存入的数据是无序的
key/value要求的类型:
    key: 必须是可以比较的类型，map,slice,function不能作为key的类型
    value: 任何类型都可以
map不是线程安全的

有序排列:
    附加slice排序key,然后根据key获取value;
map需要初始化之后才能使用:
    golang中使用new初始化struct,如果struct中包含map,new并不能初始化map;
	需要单独初始化map,可以使用构造函数初始化map
```
sync.map
```
type Map struct {
	mu Mutex //互斥量,保护read dirty
	read atomic.Value // atomic.Value的类型,可以并发的读
	dirty map[interface{}]*entry //一个非线程安全的原始map。
	misses int
}
总结:
1. sync.map是线程安全的,读取，插入，删除也都保持着常数级的时间复杂度。
2. 通过读写分离，降低锁时间来提高效率，适用于读多写少的场景。
3. Range 操作需要提供一个函数，参数是 k,v，返回值是一个布尔值：f func(key, value interface{}) bool。
4. 调用 Load 或 LoadOrStore 函数时，如果在 read 中没有找到 key，则会将 misses 值原子地增加 1，
    当 misses 增加到和 dirty 的长度相等时，会将 dirty 提升为 read。以期减少“读 miss”。
5. 新写入的 key 会保存到 dirty 中，如果这时 dirty 为 nil，就会先新创建一个 dirty，并将 read 中未被删除的元素拷贝到 dirty。
6. 当 dirty 为 nil 的时候，read 就代表 map 所有的数据；当 dirty 不为 nil 的时候，dirty 才代表 map 所有的数据
```

#### channel相关
---
channel结构
```
结构:
    type hchan struct {
    qcount   uint           // 队列中数据个数
    dataqsiz uint           // channel 大小
    buf      unsafe.Pointer // 存放数据的环形数组
    elemsize uint16         // channel 中数据类型的大小
    closed   uint32         // 表示 channel 是否关闭
    elemtype *_type // 元素数据类型
    sendx    uint   // send 的数组索引
    recvx    uint   // recv 的数组索引
    recvq    waitq  // 由 recv 行为（也就是 <-ch）阻塞在 channel 上的 goroutine 队列
    sendq    waitq  // 由 send 行为 (也就是 ch<-) 阻塞在 channel 上的 goroutine 队列
    lock mutex
}
使用:
    1. 重复关闭channel会导致panic
    2. 向关闭的channel发送数据会panic
    3. 从关闭的channel读数据不会panic
典型用法:
    1. goroutine通信 goroutine中写入，goroutine外读出
    2. select 一般配合for使用，管理多个channel的读写
    3. range channel 可以直接读取channel的值，当使用range来操作的时候，
       一旦channel关闭,channel内部数据读完之后循环自动结束。
    4. 超时控制
        select {
            case <- ch:
            case <time.After(2):        
        }
    5. 生产者消费者模型
```
channel如何实现消息通知的
```
channel应用场景:
    数据交流:
        当作并发的buffer或者queue,解决生产者消费者问题
        多个goroutine可以并发当作生产者（Producer）和消费者（Consumer）。
    数据传递:
        一个goroutine将数据交给另一个goroutine,相当于把数据的拥有权托付出去。
    信号通知:
        一个goroutine可以将信号(closing，closed，data ready等)传递给另一个或者另一组goroutine。
    任务编排:
        可以让一组goroutine按照一定的顺序并发或者串行的执行，这就是编排功能。
    锁机制:
        利用channel实现互斥机制。
channel注意事项:
    向已经关闭的channel中写入数据会发生Panic
    关闭已经关闭的channel会发生Panic
    关闭值为nil的channel会发生Panic

nil是chan的零值,是一种特殊的 chan,对值是nil的chan的发送接收调用者总是会阻塞。
```

##### interface相关

鸭子类型
```
鸭子类型是动态编程语言的一种对象推断策略,更关注对象如何被使用,而不是对象的类型本身
Go作为静态语言,通过接口的方式完美支持鸭子类型
```
方法
```
拥有接收者的函数就是方法，接收者包含值接收者和指针接收者
在调用方法的时候,值类型可以调用值接收者的方法,也可以调用指针接收者的方法
指针类型可以调用指针接收者的方法，也可以调用值接收者的方法
之所以不必严格按照值接收者和指针接收者来调用,是因为编译器在背后做了一些工作
1. 值类型调用者调用值接收者方法,方法会使用调用者的一个副本，类似于“传值”
2. 值类型调用者调用指针接收者方法,方法会使用值的引用来调用方法 T.Func()实际是(&T).Func()
3. 指针类型调用者调用值接收者方法,方法会使用指针被解引用为值,T.Func()实际是(*T).Func()
4. 指针类型调用者调用指针接收者方法,方法使用穿过来的指针,类似于指针传值
```
值接收者和指针接收者
```
总结:
    实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法;
    实现了接收者是指针类型的方法,不会自动生成对应接收者是值类型的方法
原因:
    接收者是指针类型的方法,很可能在方法中会对接收者的属性进行更改操作,从而影响接收者;
    接收者是值类型的方法,在方法中不会对接收者本身产生影响
    所以当实现了一个接收者是值类型的方法,可以自动生成一个接收者是对应指针类型的方法，
    因为两者都不会影响接收者;
    但是当一个实现接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本既往对接收者
    的改变(通过指针实现),现在无法实现
    总的来说，如果实现了接收者是值类型的方法,会隐含的实现接收者是指针类型的方法
使用场景:
    如果接收者成员都是GO内置类型,可以定义值接收者类型，因为使用它们的时候实际创建了一个header，
    header本身有利于复制；
    如果接收者包含自定义类型,应该使用指针接收者,因为struct不能安全的复制，应该只有一份实体
使用指针接收者的理由:
    1. 方法能够修改接收者指向的值
    2. 避免在每次调用方法时复制该值,在值类型为大型结构体时更高效
```
interface结构
```
interface包含2中底层结构,区别在于iface描述的接口包含方法
eface则是不包含任何方法的空接口
```
iface
```
type iface struct {
	tab  *itab //指向一个itab实体
	data unsafe.Pointer //指向接口具体的值

type itab struct {
	inter  *interfacetype//描述接口的类型
	_type  *_type//描述实体的类型,包括内存的对齐方式,大小等
	link   *itab
	hash   uint32 // copy of _type.hash. Used for type switches.
	bad    bool   // type does not implement interface
	inhash bool   // has this itab been added to hash?
	unused [2]byte
	fun    [1]uintptr //放置和接口方法对于的具体数据的方法地址;
                      //实现接口调用方法的动态分配;一般在每次给接口赋值发生转换时会更新此表
                      //或者直接拿缓存的itab
}
type interfacetype struct {
	typ     _type //描述Go语言中各种数据类型的结构体
	pkgpath name //定义了接口的包名
	mhdr    []imethod //接口所定义的函数列表
}
```
![interface](https://user-images.githubusercontent.com/7698088/56564826-82527600-65e1-11e9-956d-d98a212bc863.png)
```
type eface struct {
    _type *_type //空接口所承载的具体的实体类型
    data  unsafe.Pointer //具体的值
}
type _type struct {
    // 类型大小
	size       uintptr
    ptrdata    uintptr
    // 类型的 hash 值
    hash       uint32
    // 类型的 flag，和反射相关
    tflag      tflag
    // 内存对齐相关
    align      uint8
    fieldalign uint8
    // 类型的编号，有bool, slice, struct 等等等等
	kind       uint8
	alg        *typeAlg
	// gc 相关
	gcdata    *byte
	str       nameOff
	ptrToThis typeOff
}
```
接口的动态类型和动态值
```
定义:
    动态类型值: iface中接口表指针,指向类型信息
    动态值: data数据指针,指向具体的数据
接口值的零值实在动态类型和动态值都为nil,当且仅当两部分的值都为nil的情况下，
    接口值就才会被认为接口值==nil
```
interface比较
```
动态值和动态类型都相等,interface才相等
```
2个nil可能不相等
```
原因:
    接口等于nil,表示其类型T和值V处于unset状态
    两个值比较时会先比较T,在比较V;
例子:
func main() {
	var p *int = nil
	var i interface{} = p
	fmt.Println(i == p) // true
	fmt.Println(p == nil) // true
	fmt.Println(i == nil) // false
}
上面这个例子中,将一个 nil 非接口值 p 赋值给接口 i;
i的内部字段为(T=*int, V=nil)，
i 与 p 作比较时，将 p 转换为接口后再比较，因此 i == p，
p 与 nil 比较，直接比较值，所以 p == nil。
但是当 i 与 nil 比较时，会将 nil 转换为接口 (T=nil, V=nil)，与i (T=*int, V=nil) 不相等，
因此 i != nil。因此 V 为 nil ，但 T 不为 nil 的接口不等于 nil。
```
如何打印出接口的动态类型和动态值
```
代码里直接定义了一个 iface 结构体,用两个指针来描述 itab 和 data;
之后将 a, b, c 在内存中的内容强制解释成我们自定义的 iface
最后就可以打印出动态类型和动态值的地址。
------------------------------------------------------------
例子:
type iface struct {
	itab, data uintptr
}

func main() {
	var a interface{} = nil
	var b interface{} = (*int)(nil)
	x := 5
	var c interface{} = (*int)(&x)
	ia := *(*iface)(unsafe.Pointer(&a))
	ib := *(*iface)(unsafe.Pointer(&b))
	ic := *(*iface)(unsafe.Pointer(&c))
	fmt.Println(ia, ib, ic)
	fmt.Println(*(*int)(unsafe.Pointer(ic.data)))
}
```
编译器自动检测类型是否实现接口
```
var _ io.Writer = (*myWriter)(nil)
var _ io.Writer = myWriter{}

原理:
    上述赋值语句会发生隐式地类型转换,在转换的过程中,
    编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数
```
类型转换和断言的区别
```
    空接口interface{}没有定义任何函数,因此Go中所有类型都实现了空接口;
    当一个函数的形参是interface{}，那么在函数中，需要对形参进行断言，从而得到它的真实类型。
断言的语法:
    <目标类型的值>,<布尔参数> := <表达式>.(目标类型) //安全断言
    <目标类型的值> := <表达式>.(目标类型) //非安全类型断言
引申1:
    fmt.Println函数的参数是interface;对于内置类型,函数内部会用穷举法,得出它的真实类型,
    然后转换为字符串打印;
    而对于自定义类型,首先确定该类型是否实现了String()方法,如果实现了,则直接打印输出String()方法的结果；
    否则，会通过反射来遍历对象的成员进行打印。
```
接口转换的原理
```
当判定一种类型是否满足某个接口时,Go 使用类型的方法集和接口所需要的方法集进行匹配,
如果类型的方法集完全包含接口的方法集,则可认为该类型实现了该接口。
接口函数进行了排序,提高了比较效率
---------------------------------------------------------------------------
1. 具体类型转空接口时,_type 字段直接复制源类型的 _type;
    调用 mallocgc 获得一块新内存,把值复制进去,data 再指向这块新内存。
2. 具体类型转非空接口时,入参 tab 是编译器在编译阶段预先生成好的,
    新接口 tab 字段直接指向入参 tab 指向的 itab;
    调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。
3. 而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。
```
interface实现多态
```
多态特点:
1. 一种类型具有多种类型的能力
2. 允许不同的对象对同一消息做出灵活的反应
3. 以一种通用的方式对待使用的对象
4. 非动态语言必须通过继承和接口的方式来实现
多态例子:

func main() {
	qcrao := Student{age: 18}
	whatJob(&qcrao)

	growUp(&qcrao)
	fmt.Println(qcrao)

	stefno := Programmer{age: 100}
	whatJob(stefno)

	growUp(stefno)
	fmt.Println(stefno)
}

func whatJob(p Person) {
	p.job()
}

func growUp(p Person) {
	p.growUp()
}

type Person interface {
	job()
	growUp()
}

type Student struct {
	age int
}

func (p Student) job() {
	fmt.Println("I am a student.")
	return
}

func (p *Student) growUp() {
	p.age += 1
	return
}

type Programmer struct {
	age int
}

func (p Programmer) job() {
	fmt.Println("I am a programmer.")
	return
}

func (p Programmer) growUp() {
	// 程序员老得太快 ^_^
	p.age += 10
	return
}
```
Go接口与C++接口的异同
```
侵入式:
    实现类需要明确生命自己实现了某个接口
非侵入式:
    一个类只需要实现了接口要求的所有函数,就实现了该接口
C++定义接口的方式是侵入式，Go采用的是非侵入式
note:
    C++ 和 Go 在定义接口方式上的不同,也导致了底层实现上的不同.
    C++ 通过虚函数表来实现基类调用派生类的函数,而Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数;
    C++ 中的虚函数表是在编译期生成的,而 Go 的itab中的 fun 字段是在运行期间动态生成的
    原因在于,Go 中实体类型可能会无意中实现 N 多接口,很多接口并不是本来需要的,所以不能为类型实现的所有接口都生成一个 itab;
    这也是“非侵入式”带来的影响l
    这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。
```


##### 函数相关

定义
```
函数是唯一一种基于特定输入、实现特定任务并可反馈认为执行结果的代码块
本质上Go程序就是一组函数的集合
一等函数:
    一等函数允许将函数分配给变量(将函数通过变量进行传递),作为参数传递给其他函数
    并从其他函数返回
匿名函数:   
    没有定义函数名字的函数
高阶函数:
    满足至少一项的函数:
    1. 以一个或者多个函数作为参数
    2. 返回一个函数作为其结果
闭包:
    闭包是由函数及其相关引用环境组合而成的实体
    或者说能访问函数主题之外的变量的函数就是闭包
    在Golang中,所有的匿名函数都是闭包
```
#### 反射相关
---
定义
```
在运行时更新变量和检查它们的值、调用它们的方法,但是在编译时并不知道这些变量的具体类型
```
使用场景
```
1. 未知的参数类型,需要使用反射判断类型
2. 需要在运行期间根据函数和函数的参数类型动态的执行函数

```

### 高级

#### GO内存管理相关

内存逃逸
```
逃逸定义:
    程序中每个函数都会分配一个栈帧用来存放自己的局部变量、返回地址,函数运行结束后栈帧销毁；
    但是有些变量在结束后仍会使用,那么就需要将这个变量分配在堆上；
    这种从栈上逃逸到堆上的现象就称为内存逃逸    
由编译器决定:
    编译器通过逃逸分析确定变量是在栈上还是堆上
    当发现变量的作用域没有超出函数范围,就可以在栈上,反之则必须分配在堆上
内存逃逸的五种情况:
    1 发送指针的指针或值包含了指针到channel中,由于在编译阶段无法确定其作用域与传递的路径,所以一般都会逃逸到堆上分配。
    2 slices中的值是指针的指针或包含指针字段。
    3 slice由于append操作超出其容量,因此会导致slice重新分配。
    4 在interface类型上调用方法
        在interface类型上调用方法都是动态调度的;方法的真正实现只能在运行时知道.
	    想象一个io.reader类型变量r,调用r.read(b)会使得r的值和切片b的背后存储都逃逸掉,所以会在堆上分配.
    5 返回局部变量的引用,生命周期大于栈,导致内存逃逸
避免内存逃逸的办法:
    对于小型的数据,使用传值而不是传指针,避免内存逃逸。
    避免使用长度不固定的slice切片,在编译期无法确定切片长度,只能将切片使用堆分配。
    interface调用方法会发生内存逃逸，在热点代码片段，谨慎使用。
逃逸分析:
	go build -gcflags=-m main.go
```
函数返回局部变量的指针是否安全
```
Go中是安全的,Go 编译器将会对每个局部变量进行逃逸分析。
如果发现局部变量的作用域超出该函数，则不会将内存分配在栈上，而是分配在堆上
```
##### 垃圾回收的工作原理
```
golang通过三色标记法加写屏障技术实现垃圾回收

标记清除法:
    定义:
        标记清除收集器是跟踪式垃圾收集器,其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段：
        标记阶段:
            从根对象出发查找并标记堆中所有存活的对象；
        清除阶段:
            遍历堆中的全部对象，回收未被标记的垃圾对象并将回收的内存加入空闲链表。
        问题:
            是在标记期间,需要暂停程序（Stop the world，STW)
            标记结束之后,用户程序才可以继续执行

    三色标记法:
        将程序中的对象分成白色、黑色和灰色三类:
            白色: 不确定对象
            灰色: 存活对象,子对象待处理
            黑色: 存活对象
        执行流程:
            1 标记开始时所有对象加入白色集合(需要STW).
            2 将根对象标记为灰色,并加入灰色集合
            3 垃圾收集器取出一个灰色对象,并将其标记为黑色,将其指向的对象标记为灰色,加入灰色集合
            4 重复3的过程,直到灰色集合为空,标记阶段结束; 那么白色对象就是需要清理的对象;
              而黑色对象均是根可达的对象,不能清理
        总结:
            从根遍历所有对象,不可达的对象即认为可清理的对象
            因为多了一个白色的状态存放不确定的对象,后续的标记阶段可以并发执行
            并发过程中可能会有遗漏,因为最开始的黑色对象有可能在标记过程中
            就已经不可达了
        问题:
            在 GC 过程中,对象指针会发生了改变,导致不该回收的对象回收了
            使用写屏障技术解决这个问题
            例子:
            A (黑) -> B (灰) -> C (白) -> D (白)
            正常情况下，D 对象最终会被标记为黑色，不应被回收。
            但在标记和用户程序并发执行过程中，用户程序删除了 C 对 D 的引用，
            而 A 获得了 D 的引用。标记继续进行，D 就没有机会被标记为黑色了（A 已经处理过，这一轮不会再被处理）。
            A (黑) -> B (灰) -> C (白) 
            ↓
            D (白)
    写屏障技术:
            当对象新增或更新时,会将其着色为灰色
            这样即使与用户程序并发执行,对象的引用发生改变时,垃圾收集器也能正确处理了
GC四个阶段：
    1 标记准备(Mark Setup，需 STW)，打开写屏障(Write Barrier)
    2 使用三色标记法标记（Marking, 并发）
    3 标记结束(Mark Termination，需 STW)，关闭写屏障。
    4 清理(Sweeping, 并发)
```

屏障机制
```
强-弱三色不变式
    强三色不变式: 不存在黑色对象引用到白色对象的指针
    弱三色不变式: 所有被黑色对象引用的白色对象都处于灰色保护状态
插入屏障:
    具体操作: 在A对象引用B对象的时候,B对象被标记为灰色
    满足: 强三色不变式
    缺点: 结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活
删除屏障:
    具体操作: 被删除的对象,如果自身为灰色和白色,那么被标记为灰色
    满足: 弱三色不变式(保护灰色对象到白色对象的路径不会断)
    缺点:
        回收精度低，GC开始时STW扫描堆栈来记录初始快照
        这个过程会保护开始时刻的所有存活对象
不执行STW的话下面2种情况会丢失
条件1: 一个白色对象被黑色对象引用(白色被挂在黑色下)
条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏(灰色同时丢了该白色)

```

golang的内存模型
```
内存一致模型:
    或称内存模型,是一份语言用户与语言自身,语言自身与所在的操作系统平台,所在操作系统平台与硬件平台之间的契约;
    它定义了并行状态下拥有确定读取和写入的时序的条件.并回答了一个共享变量是否具有足够的同步机制来保障
    一个线程的写入能否发生在另一个线程的读取之前这个问题
    Go语言的内存模型规定了一个goroutine可以看到另外一个goroutine修改同一个变量的值的条件
    为了保证多goroutine下读取共享数据的正确性，go中引入happens before原则，即在go程序中定义了多个内存操作执行的一种偏序关系。
    如果操作e1先于e2发生，我们说e2 happens after e1,如果e1操作既不先于e2发生又不晚于e2发生，我们说e1操作与e2操作并发发生

```
Golang的内存模型中为什么小对象多了会造成GC压力
```
通常小对象过多会导致GC三色法消耗过多的CPU.
优化思路时减少对象分配.
```

golang栈空间管理
```
go 1.3之前:
    使用分段栈, 当栈空间不足的时候,会申请一段新的空间,并通过指针与原本的栈链接
    分段栈的好处:
        可以按需增长，空间利用率比较高
    分段栈的坏处:
        当一个段即将用尽，这时使用for循环执行一个比较耗空间的函数，会导致函数执行时goroutine进行段的分配，
        而执行完成返回时，进行段的销毁，这样就会导致在循环中出现多次栈的扩容和收缩，造成很大的性能损失，
        这种情况被称作栈分裂
1.3及之后:
    使用连续栈
    当栈空间不够时，直接new一个2倍大的栈空间，并将原先栈空间中的数据拷贝到新的栈空间中，而后销毁旧栈
总结:
    相比于分段栈，连续栈避免了某些场景下栈空间的的频繁伸缩。
    有一点需要注意的是，连续栈的收缩也是需要重新申请一段空间（原先的1/2大小），并进行栈拷贝操作的
```

Go的对象在内存中是怎样分配的
```
Go的内存分配原则:
    Go在程序启动的时候,会先向操作系统申请一块内存(注意这时还只是一段虚拟的地址空间,并不会真正地分配内存),切成小块后自己进行管理。
    申请到的内存块被分配了三个区域,在X64上分别是512MB，16GB，512GB大小。
    TODO 待补充
```
栈的内存是怎么分配的
```
栈和堆区别：
    栈在高地址,从高地址向低地址增长。
    堆在低地址,从低地址向高地址增长。
栈和堆相比优势:
    栈的内存管理简单,分配比堆上快。
    栈的内存不需要回收,而堆需要,无论是主动free,还是被动的垃圾回收,这都需要花费额外的CPU。
    栈上的内存有更好的局部性,堆上内存访问就不那么友好了
```
堆内存管理怎么分配的
```
    把使用的内存块从链表中取出来,然后标记为未使用,当分配内存块的时候
    可以从未使用内存块中有先查找大小相近的内存块,如果找不到,再从未分配的内存中分配内存。
想要深入了解可以看下这个文章,《Writing a Memory Allocator》.
    TODO: 待补充
```
在Go函数中为什么会发生内存泄露
```
内存泄漏:
    能够预期的能很快被释放的内存由于附着在了长期存活的内存上或生命期意外地被延长
    导致预计能够立即回收的内存而长时间得不到回收
内存泄露的形式:
    1 预期能被快速释放的内存因被根对象引用而没有得到迅速释放.
    2 当有一个全局对象时,可能不经意间将某个变量附着在其上,且忽略的将其进行释放,
      则该内存永远不会得到释放。
```
GC的触发条件
```
主动触发:
    通过调用runtime.GC来触发GC,此调用阻塞式的等待当前GC运行完毕
被动触发:
    使用监控系统,超过2分钟没有产生任何GC时,强制触发GC
    使用步调算法,核心思想就是控制内存的增长的比例,当前内存分配达到一定比例则触发
toDO: 什么时步调算法
```

golang中堆和栈的区别
```
如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销
```
#### 内存对齐
```
用空间换时间,希望读取一次能够取出数据
类型对齐边界:
    所有成员中的最大值
结构体对齐:
    每个成员起始地址必须能被长度整除
    结构体的总长度必须类型对齐的倍数
```
go栈扩容和栈缩容，连续栈的缺点
```
Go 语言设计与实现 中关于栈空间的描述
多数架构上默认栈大小都在 2 ~ 4 MB 左右，极少数架构会使用 32 MB 作为默认大小。用户程序可以在分配的栈上存储函数参数和局部变量。

Go 语言的逃逸分析遵循以下两个不变性
1.指向栈对象的指针不能存在于堆中；
2.指向栈对象的指针不能在栈对象回收后存活；

栈内存空间
Go 语言使用用户态线程 Goroutine 作为执行上下文，它的额外开销和默认栈大小都比线程小很多，然而 Goroutine 的栈内存空间和栈结构也在早期几个版本中发生过一些变化：
v1.0 ~ v1.1 — 最小栈内存空间为 4KB；
v1.2 — 将最小栈内存提升到了 8KB；
v1.3 — 使用连续栈替换之前版本的分段栈；
v1.4 — 将最小栈内存降低到了 2KB；
Goroutine 的初始栈内存在最初的几个版本中多次修改，从 4KB 提升到 8KB 是临时的解决方案，其目的是为了减轻分段栈的栈分裂问题对程序造成的性能影响；在 v1.3 版本引入连续栈之后，Goroutine 的初始栈大小降低到了 2KB，进一步减少了 Goroutine 占用的内存空间。

分段栈
当 Goroutine 调用的函数层级或者局部变量需要的越来越多时，运行时会调用 runtime.morestack#go1.2 和 runtime.newstack#go1.2 创建一个新的栈空间，这些栈空间虽然不连续，但是当前 Goroutine 的多个栈空间会以链表的形式串联起来，运行时会通过指针找到连续的栈片段：
分段栈机制虽然能够按需为当前 Goroutine 分配内存并且及时减少内存的占用，但是它也存在两个比较大的问题：
1.如果当前 Goroutine 的栈几乎充满，那么任意的函数调用都会触发栈的扩容，当函数返回后又会触发栈的收缩，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）；
2.一旦 Goroutine 使用的内存越过了分段栈的扩缩容阈值，运行时就会触发栈的扩容和缩容，带来额外的工作量；

连续栈
连续栈可以解决分段栈中存在的两个问题，其核心原理就是每当程序的栈空间不足时，初始化一片更大的栈空间并将原栈中的所有值都迁移到新的栈中，新的局部变量或者函数调用就有了充足的内存空间。使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：
1.在内存空间中分配更大的栈内存空间；
2.将旧栈中的所有内容复制到新的栈中；
3.将指向旧栈对应变量的指针重新指向新栈；
4.销毁并回收旧栈的内存空间；
因为需要拷贝变量和调整指针，连续栈增加了栈扩容时的额外开销，但是通过合理栈缩容机制就能避免热分裂带来的性能问题，在 GC 期间如果 Goroutine 使用了栈内存的四分之一，那就将其内存减少一半，这样在栈内存几乎充满时也只会扩容一次，不会因为函数调用频繁扩缩容。
```
#### GO调度相关

goroutine泄漏
```
定义:
    Goroutine作为一种逻辑上理解的轻量级线程,需要维护执行用户代码的上下文信息
    在运行过程中也需要消耗一定的内存来保存这类信息,而这些内存在目前版本的Go中是不会被释放的。
    如果一个程序持续不断地产生新的 goroutine且不结束已经创建的goroutine并复用这部分内存
    就会造成内存泄漏的现象.
```

G0的作用
```
g0作为一个特殊的goroutine,为scheduler执行调度循环提供了场地(栈)
对于一个线程来说,g0总是它第一个创建的goroutine
之后,它会不断地寻找其他普通的goroutine来执行,直到进程退出。
当需要执行一些任务,且不想扩栈时,就可以用到 g0了,因为 g0 的栈比较大。
g0 其他的一些“职责”有:
    创建 goroutine
    deferproc 函数里新建 _defer
    垃圾回收相关的工作（例如 stw、扫描 goroutine 的执行栈、一些标识清扫的工作、栈增长）等等。
```
GO的GMP如何调度
```
G: goroutine协程
M:  thread线程
P: processor处理器,包含了运行goroutine的资源及可运行的G队列
全局队列: 
    存放等待运行的G
P的本地队列: 
    同全局队列类似,存放的也是等待运行的G,不超过256个
P列表:
    所有的P都在程序启动时创建,并保存在数组中,最多有GOMAXPROCS个
M: 线程想运行任务就要获得P,从P的本地队列获取G,P队列为空时,M也会
   尝试从全局队列拿一批G放到P的本地队列,或者从其他P的本地队列偷一半
   放到自己的P的本地队列,M运行G,G执行后,M从P获取下一个G,不断重复
数量问题:
    P 的数量由环境变量GOMAXPROCS或者runtime的方法GOMAXPROCS()决定
    M 的数量:
     go程序启动时设置最大数量,默认1000,但是内核很难支持这么多,可以忽略
     runtime/debug中的SetMaxThreads函数,设置M的最大数量
     一个M阻塞了,会创建新的M
何时创建:
    P: 在确定了P的最大数量n后,运行时系统会根据这个数量创建n个P
    M: 没有足够的M来关联P并运行其中的可运行的G
调度器的设计策略:
    复用线程: 避免频繁创建 销毁线程,而是对线程的复用
        work stealing机制: 当本线程无可运行的G时,尝试从其他线程绑定的P偷取G,而不是销毁线程
        hand off机制: 当本线程因为G进行系统调用阻塞时,线程释放绑定的P,把P转移给其他的空闲线程执行
    利用并行:
          充分利用CPU核数
    全局G队列:
        当M无法从其他P偷取G时,可以从全局队列获取G
调度流程:
    1 通过go func创建一个goroutine
    2 G 会先保存在P的本地队列,如果P的本地队列满了,会保存在全局队列
    3 判断空闲的M是否存在,不存在创建; M会从绑定的P获取G来执行,如果
      P的本地队列为空,就会从其他MP组合偷取G;如果偷取不到,会从全局队列
      获取G
    4 一个M调度G执行的过程是一个循环机制
    5 当M执行某一个G阻塞时,runtime会把这个M从P摘除,创建一个新的线程或者复用
      空闲线程服务P
M0:
    启动程序后编号为0的主线程,对于全局变量runtime.m0,不需要再heap上分配;
    负责执行初始化操作核启动第一个G,在之后M0就和其他的M一样了
G0:
    每次启动一个M都会第一个创建的goroutine,Go仅负责调度,不执行函数;
    每个M都有自己的G0
可视化GMP编程:
    go tool bin bin.out
```
GMP调度模型
```
    在Go中,线程是运行goroutine的实体,调度器的功能是把可运行的的goroutine分配到工作线程上
定义:
    全局队列: 
        存放等待运行的G
    P的本地队列:
        存放等待运行的G,存的数量有限,不超过 256 个
        新建 G’时,G’优先加入到 P 的本地队列,如果队列满了,则会把本地队列中一半的G移动到全局队列 
    P:
        调度器的核心处理器,通常表示执行上下文,用于匹配M和G.
        P的数量不能超过GOMAXPROCS配置数量;通常一个P可以与多个M对应,
        但是同一刻P只能与一个M发生绑定关系;M创建后需要自行在P的free list找到P进行绑定;
        没有绑定P的M会进入阻塞态
    M: 
        就是OS线程本身,数量可配置
    G:
        Goroutine,go的用户线程,即协程,真正携带代码执行逻辑的部分;由go func(){...}直接生成
    G0: 比较特殊的G,主要用于调度G
        有1/61的机会从全局队列获取G,其他时间从其他本地队列回去G

    本地队列:
        本地时相对P而言的本地,每个P维护一个本地队列
        生成的G一般会放到P的本地队列,只有本地队列满了的时候,
        才会截取本地队列的一半放入全局队列
    全局队列:
        承载本地队列溢出的G,为了保证调度的公平性,schedule过程中有1/61的几率优先检查全局队列
        否则本地队列一直满载的情况下,全局队列中的G将永远无法被调度到
    窃取(stealing):
        随机从其他P的本地队列窃取一半的G
    线程自旋:
        线程自旋是相对于线程阻塞而言的;一直循环获取G,避免了M的上下文切换
        自旋的线程不会超过GOMAXPROCS,因为一个P在同一时刻只能绑定一个M,
        P的数量不好超过GOMAXPROCS
调度流程:
    1 1/61的几率在全局队列中找G,60/61的几率在本地队列找G;
    2 如果在全局队列找不到G,从P的本地队列找G
    3 如果找不到,从其他P的本地队列中窃取G
    4 如果找不到,则从全局队列中拿取一部分G到本地队列,数量需要满足公式:
        n = min(len(GQ)/GOMAXPROCS+1,len(GQ/2))
    5 如果找不到,从网络中poll G 
    6 只要找到G,就会立马丢给M执行
go func调用:
    1 通过go func()创建一个goroutine
    2 新建的G优先保存在P的本地队列,如果本地队列满了,就保存在全局的队列中
    3 M会从P的本地队列获取一个可执行状态的G执行,如果本地为空,1/61的概率从
        全局队列获取,其他情况从其他MP获取
    4 M循环调度G
    5 如果M发生syscall或其余阻塞操作,M会阻塞;
        如果还有G执行,runtime会把这个线程M从P中摘除,然后创建一个新的操作系统的线程
        来服务这个P
    6  M调用结束,G会尝试获取一个空闲的P执行,并放入这个P的本地队列;
        如果获取不到,M会变成休眠状态,加入到空闲线程中,然后这个G被放入全局队列
------------------------------------------------------------------------------------------------------------
 Goroutine调度器和OS调度器是通过M结合起来的,每个M都代表了1个内核线程,OS 调度器负责把内核线程分配到 CPU 的核上执行 
 
 P和M的数量问题:
    P的数量由GOMAXPROCS或者runtime调用GOMAXPROCS()决定
    M的数量默认1000,但是一般达不到; 可以通过runtime/debug中的SetMaxThreads函数设置最大数量;
        一个M阻塞了会创建新的M
P和M何时被创建:
    确定了P的最大数量后系统就会根据P的数量创建
    没有足够的M来关联P并运行其中的可运行的G的时候创建
调度器设计策略:
    线程复用: 避免频繁的创建销毁线程
        1 work Stealing机制: 本线程无G可用时,尝试从其他线程绑定的P偷取线程
        2 hand off机制 本线程因为G进行系统调用阻塞时,线程释放绑定的P,把P转移给其他空闲的线程执行
    利用并行: 可用使用GoMAXPROCS设置P的数量
    抢占: 
        一个goroution最多占用CPU10ms,防止其他goroutuin被饿死
        协调式是指goroutine执行完才能被其他使用
    全局G队列: 只有在M从其他P偷不到G的时候才会从全局获取G
M0和G0:
    M0是启动程序后的编号为0的主线程,这个M对应的实例会在全局变量 runtime.m0 中,不需要在 heap 上分配,M0 负责执行初始化操作和启动第一个 G,
    在之后 M0 就和其他的 M 一样了
    G0是每次启动一个M都会第一个创建的goroutine,G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，
    每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0
GMP场景:
    场景一:
        P创建G后优先加入本地队列(局部性原理)
    场景二:
        G1完成后,M运行的goroutine切换为G0,G0负责调度协程的切换;
        从本地队列获取G2,从G0切换到G2并执行,实现M的复用
    场景三:
        本地队列满了后本地队列的一半转移到全局队列,并且新创建的G转移到全局队列
    场景四:
        创建G时,运行的G会尝试唤醒其他空闲的P和M组合执行
    场景五:
        本地没有G的话,从全局队列取一批G放到本地队列
        取的数量是n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))
        至少取一个,从全局队列到P本地队列的负载均衡
    场景六:
        本地和全局队列都没有G,从其他有G的P偷一半过来
    场景七:
        本地队列为空,全局队列为空,M陷入自旋状态
    
```

抢占式goroutine
```
 协作式调度依靠被调度方主动弃权
 抢占式调度则依靠调度器强制将被调度方被动中断
```
#### GO并发相关

#### goroutine相关

#### 协程泄漏问题
```
协程泄露是指协程创建后,长时间得不到释放,并且还在不断地创建新的协程,最终导致内存耗尽,程序崩溃。
原因:
    1 缺少接收器，导致发送阻塞
    2 死锁
    3 无限死循环
造成的后果:
    1 CPU 使用率浮动上涨
    2 内存占用不断上涨
    3 主进程崩溃
```
死锁的理解
```
```
限制goroutine数量的手段
```
1. 通过channel限制
    设置带缓存的channel,缓存满了的时候阻塞主goroutine
    同时在子goroutine执行完成时释放channel缓存
2. 使用sync同步机制
    使用sync.group设置goroutine数量,子goroutine执行完成后是否数量
    单纯的使用sync.group无法限制,因为创建goroutine的速度大于释放
    goroutine的速度,依然会导致goroutine泄漏
3.  channel和sync一起使用
4.  利用无缓冲的channel与认为发送/执行分离模式
    实际就是主goroutine使用sync同步,使用channel作为消息队列进行同步
总结:
    总的来说还是使用channel来限制goroutine的创建,避免goroutine无限创建
```
goroutine退出
```
1. 正常goroutine执行完成就会退出
2. 阻塞的goroutine会一直不退出,可以解除阻塞使其退出
   如关闭channel，信号量通知等
3. 可以设置定时器,超时即退出
4. context也可以超时退出
```

select相关
```
执行原理:
    1. 每一个case对应的channel都会被封装到一个结构体中
    2. 首次执行select时,会锁住channel,打乱case结构体的顺序
    3. 监听信号,就绪时执行对应的case,之后跳出select
    4. 没有就绪的代码段,但是有default时,执行default代码段,之后跳出select
    5. 没有default,将当前goroutine加入所有channel对应等待队列
    6. 当某个等待队列就绪时,再次锁住所有channel
```
Context相关
```
Context 使用原则:
    1 不要把Context放在结构体中,要以参数的方式传递。
    2 以Context作为参数的函数方法,应该把Context作为第一个参数,放在第一位。
    3 给一个函数方法传递Context的时候,不要传递nil,默认使用context.TODO。
    4 Context的Value相关方法应该传递必须的数据,不要什么数据都使用这个传递。
    5 Context是线程安全的，可以放心的在多个goroutine中传递。
note:
    Context中的方法是协程安全的,所以在父routine中创建的context
    可以传递给任意数量的routine并让他们同时访问。
Context中的方法:
    Done:
        会返回一个channel,当该context被取消的时候,该channel会被关闭,
        同时对应的使用该context的routine也应该结束并返回
    Deadline:
        会返回一个超时时间,routine获得了超时时间后,可以对某些io操作设定超时时间。
```
sync.WaitGroup相关
```
WaitGroup用来等待一组操作完成的,WaitGroup内部实现了一个计数器,用来记录未完成的操作个数.
它提供了三个方法:
    Add()用来添加计数,Done()用来在操作结束时调用使计数减一
    Wait()用来等待所有的操作结束即计数变为0,该函数会在计数不为0时等待
    在计数为0时立即返回。
```
CAS相关
```
CAS算法(Compare And Swap),是原子操作的一种,CAS算法是一种有名的无锁算法
无锁编程:
    即不使用锁的情况下实现多线程之间的变量同步,也叫非阻塞同步(Non-blocking Synchronization)。
    可用于在多线程编程中实现不被打断的数据交换操作,从而避免多线程同时改写某一数据时由于
    执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。
    该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。
Go中的CAS操作:
    借用CPU提供的原子性指令来实现
    CAS操作修改共享变量时候不需要对共享变量加锁,
    而是通过类似乐观锁的方式进行检查,
    本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）。
```

#### GO优化
##### pprof

### 其他面试题




##### 相关
rune类型
```
unicode在golang中的类型,是int32类型的别名,包含世界上书写系统总存在
的所有字符的标准编号
GO语言中,字符串底层表示是byte(8 bit)序列,而非rune(32 bit)序列

rune: Unicode编码,对应uinit32
byte: ASCII编码,对应uinit8
一个英文字符对应一个byte,一个中文字符对应三个byte
一个rune对应一个UTF-8字符,所以一个中文字符对应一个rune
len:
    计算的是byte长度
range:
    是按照rune处理的
```
make和new的区别
```
1. make 只用于slice,map,channel，返回的是初始化之后的T类型的值，
    这个值是经过初始化之后的T的引用，作为函数传参之后在函数内部修改
    将影响函数外部的值;
2. new返回的T的指针*T并指向T的零值
```
defer,recover和panic
```
defer:
    1. 在defer表达式确定的时候,defer修饰的函数（defered函数）的参数也就确定了
    2. 函数内可以有多个defered函数,但是这些defered函数在返回时遵守先进后厨的原则
    3. 函数命名的返回值跟deferd函数一起使用
    note:
    1. 函数renturn前,会按照先进后出的顺序执行
    2. defer函数定义时,对外部变量的引用有2种方式,分别时函数参数和作为闭包引用
       函数参数时,则在defer定义时就把值传递给defer,并缓存起来
        因此如果时“值”,那么和定义的时候一致,如果是引用,那么就可能和定义的时候不一致
       闭包引用时,则会在defer函数真正调用时根据整个上下文确定当前的值
       
panic:
    panic其实就是c++中的throw exception
    panic是内建函数,会中断函数f的正常执行流程,从函数f中跳出来,跳回到函数f的使用者
    对于调用者来说,f看起来就是一个panic,所以调用者会继续向上跳出，知道当前goroutine返回
    在跳出的过程中,进程会保持这个函数栈，当goroutine退出时，程序会crash
recover:
    recover就是c++中的catch
    1. recover如果想起作用的话，就必须在defered函数中使用
    2. 在正常函数执行过程中,调用revocer没有任何作用
    3. 如果当前的goroutine panic了，那么recover将会捕获这个panic的值
        并让程序正常执行下去,不会让程序crash。
TODO: recover需要练习下
```

进程,线程,协程的异同
```
进程: 
    分配资源的最小单位,可执行程序运行中形成的一个独立的内存体

线程:
    系统调度的最小单位,每个线程拥有各自的栈空间,其他的与内存空间一起共享
协程:
    用户态的轻量级线程,调度完全由用户控制.
    协程拥有自己的寄存器上下文和栈

协程切换成本：
    保存当前cpu寄存器的状态,加载需要切换的协程的CPU寄存器状态,完全在用户态进行
    一般来说一次协程上下文切换最多就是几十ns这个量级。
线程切换成本：
   1. 需要从用户态切换到内核态才能进行线程切换
   2. 除了CPU上下文,还需要保存切换线程私有的栈和寄存器

协程切换比线程切换快主要有两点：
 1 协程切换完全在用户空间进行;线程切换涉及特权模式切换，需要在内核空间完成；
 2 协程切换相比线程切换做的事情更少;线程需要有内核和用户态的切换,系统调用过程。
```
Goroutine和线程的区别
```
1 从调度上看,goroutine的调度开销远远小于线程调度开销。
    OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。
    这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，
    再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：
    即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。
    某种意义上，这种操作还是很慢的。
    Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，
    m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，
    而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。
2 从栈空间上，goroutine的栈空间更加动态灵活。
    每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。
    这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB,
    在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000=200MB）。
    而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB。
3 goroutine没有一个特定的标识。
    在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，
    本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰。
    goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，
    即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。
```

变量的重声明
```
定义:
 已经声明的变量再次被声明赋值
前提:
    1、 变量再次声明时必须与其原本的类型相同,否则会产生编译错误
    2、 变量的重声明只能发生在某一个代码块中。
    3、 变量的重声明只有在使用短变量声明时才会发生,否则无法通过编译
    4、 被"声明并赋值"的变量必须时多个,且至少有一个是新变量，
        这时我们才可以说对其中的旧变量进行了重声明
```
类型转换
```
整数类型转换:
    小范围向大范围的数值可以正常转换;
    大范围向小范围的数值转换时,
    只需要在补码形式下截掉一定数量的高位二进制数即可
浮点型转整型:
    当把一个浮点型转为整型时,前者的小数部分会被全部截掉
整数转string类型:
    被转换的整数值应该可以代表一个有效的 Unicode 代码点，
    否则转换的结果将会是"�"（仅由高亮的问号组成的字符串值）
```
高效的拼接字符串
```
    Go语言中,字符串是只读的,也意味着每次修改操作都会创建一个新的字符串,
    如果需要拼接多次,应使用strings.Builder，最小化内存拷贝次数
```

GO支持默认参数或者可选参数吗
```
可选参数:
    参数可以是非必须的,可以指定传递非必须的参数
Go语言不支持可选参数,也不支持方法重载
```
go语言tag的用处
```
    tag是struct的一部分,主要用于反射场景; 
    反射包中拥有tag的处理方式
```
字符串切片相等判断
```
    1 使用reflect.DeepEqual(a,b)判断  影响性能(需要进行反射判断)
    2 使用遍历的方式比较
```
空strct{}的用途
```
1 空结构体也是结构体,只是 size 为0的类型而已；
2 所有的空结构体都有一个共同的地址：zerobase 的地址；
3 空结构体可以作为 receiver,receiver是空结构体作为值的时候，
  编译器其实直接忽略了第一个参数的传递，编译器在编译期间就能确认生成对应的代码；
4 map 和 struct{} 结合使用常常用来节省一点点内存，使用的场景一般用来判断 key 存在于 map；
5 chan 和 struct{} 结合使用是一般用于信号同步的场景，用意并不是节省内存，而是我们真的并不关心 chan 元素的值；
6 slice 和 struct{} 结合好像真的没啥用
总结: struct{}就是一个标志
```
go程序运行顺序
```
1 初始化导入的包,按照依赖顺序初始化,优先初始化没有依赖的包
2 初始化常量
3 初始化变量
4 init函数 
  不同文件中的 init方法的执行按照文件名先后执行各个文件中的 init 方法
  同一个文件中的多个init方法,按照在代码中编写的顺序依次执行不同的 init 方法
5 main函数
一句话总结: import->const->var->init()->main()
```
golang使用类型推断有什么好处
```
go语言的类型推断可以明显提升程序的灵活性,使得代码重构变得更加容易,
同时又不会给代码维护带来额外负担，也不会损失程序运行的效率
note: 类型推断可以单独修改定义的部分，其他由编译器推断，不用每个地方都修改
```

字符串转成byte数组，会发生内存拷贝吗？
```
字符串转成切片会发生拷贝;严格的说,只要发生类型的强转都会发生内存拷贝;
有什么办法可以不拷贝吗?
1. unsafe.Pointer(&a) 方法可以得到变量a的地址。
2. (*reflect.StringHeader)(unsafe.Pointer(&a)) 可以把字符串a转成底层结构的形式。
3. (*[]byte)(unsafe.Pointer(&ssh)) 可以把ssh底层结构体转成byte的切⽚的指针。
4. 再通过  * 转为指针指向的实际内容。
```
struct能不能比较
```
因为是强类型语言，所以不同类型的结构不能作比较，
但是同一类型的实例值是可以比较的，实例不可以比较，因为是指针类型
```


明白channel是通过注册相关goroutine id实现消息通知的。

为什么Go Scheduler需要实现M:N的方案
```
    1 创建线程开销大,需要提高效率减少线程的创建
    2 减少GO垃圾回收的复杂度
```
并发
```
并发就是可同时发起执行的程序，指程序的逻辑结构；并行就是可以在支持并行的硬件上执行的并发程序，指程序的运⾏状态
并发级别:
    阻塞：阻塞是指一个线程进入临界区后，其它线程就必须在临界区外等待，待进去的线程执行完任务离开临界区后，其它线程才能再进去。

    无饥饿：线程排队先来后到，不管优先级大小，先来先执行，就不会产生饥饿等待资源，也即公平锁；
            相反非公平锁则是根据优先级来执行，有可能排在前面的低优先级线程被后面的高优先级线程插队，就形成饥饿

    无障碍：共享资源不加锁，每个线程都可以自有读写，单监测到被其他线程修改过则回滚操作，重试直到单独操作成功；
            风险就是如果多个线程发现彼此修改了，所有线程都需要回滚，就会导致死循环的回滚中，造成死锁

    无锁：无锁是无障碍的加强版，无锁级别保证至少有一个线程在有限操作步骤内成功退出，不管是否修改成功，
            这样保证了多个线程回滚不至于导致死循环

    无等待：无等待是无锁的升级版，并发编程的最高境界，无锁只保证有线程能成功退出，但存在低级别的线程一直处于饥饿状态，
            无等待则要求所有线程必须在有限步骤内完成退出，让低级别的线程有机会执行，从而保证所有线程都能运行，提高并发度。
```

翻转含有中文、数字、英文字母的字符串
```
使用rune关键字,rune对应UTF编码，可以实现翻转
TODO
```
拷贝大切片一定比小切片代价大吗？
```
并不是,所有切片的大小相同,三个字段（一个 uintptr，两个int）。
切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，
第二个字段是切片的长度，第三个字段是容量。
将一个 slice 变量分配给另一个变量只会复制三个机器字。
所以 拷贝大切片跟小切片的代价应该是一样的。
```
slice深拷贝和浅拷贝
```
浅拷贝#
目的切片和源切片指向同一个底层数组，任何一个数组元素改变，都会同时影响两个数组。
深拷贝
目的切片和源切片指向不同的底层数组，任何一个数组元素改变都不影响另外一个。

主要看是否重新分配内存
```

map不初始化使用会怎么样
```
读返回空,写崩溃
```

字符串不能改，那转成数组能改吗，怎么改
```
Go 语言的字符串是不可变的。
修改字符串时，可以将字符串转换为 []byte 进行修改。
[]byte 和 string 可以通过强制类型转换互转。
```
普通map如何不用锁解决协程安全问题
```
使用sync.map
```
你一定会遇到的内存回收策略导致的疑似内存泄漏的问题
```
go 1.12更改了内存回收策略，CG后内核不会立即回收内存，
方便再次申请的时候使用，会导致占用内存较高，类似内存泄漏
```

能说说uintptr和unsafe.Pointer的区别吗？

golang怎么做代码优化
昨天那个在for循环里append元素的同事，今天还在么？
```
主要关注slice会扩容，如果循环是确定slice长度就不会死循环；
如果slice长度随着appled变动就会死循环
```
