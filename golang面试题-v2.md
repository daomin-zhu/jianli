#### 基础
------------------------------------------------------
进程,线程及协程的区别
```
进程:
    具有独立的地址空间,操作系统分配资源的基本单位
线程:
    操作系统调度的最小单位,多个线程共享一个进程的地址空间;
    线程拥有自己的栈,其他内存空间共享进程的地址空间;
协程:
    用户态的轻量级线程,调度完全由用户控制;
    拥有自己的寄存器上下文和栈,协程切换时不需要切换内核态和用户态;
协程切换比进程切换快的原因:
1. 协程完全在用户态进行切换,进程切换设计特权模式切换,需要在内核空间完成
协程切换成本:
    把当前协程的CPU寄存器状态保存起来,加载需要切换的协程的CPU寄存器状态;
    一般在几十ns的量级
线程切换成本:
    用户态与内核态之间的切换,处理CPU寄存器保存的状态,还包含线程私有的栈和寄存器;
进程与线程的区别:
1. 地址空间: 线程需要共享所属进程的地址空间;进程拥有独立的进程空间;
2. 资源拥有: 进程拥有自己独立的资源,线程共享进程的资源
线程与协程的区别:
1. 调度上看,goroutine的调度开销远远小于线程调度开销
    线程需要内核态与用户态切换
2. 栈空间看,goroutine的栈空间更加动态灵活
    线程栈空间固定大小,通常2MB;
    goroutine非固定大小,通常2KB,最大可以1GB
3. goroutine没有特定标识
    线程有个标识,通常是个整数或者指针
```
高效拼接字符串
```
使用strings.builder,最小化拷贝内存次数
```
rune类型
```
int32类型的别名,对应UTF编码
字符串底层时byte(8 bit),使用range时string转换为rune类型
```
defer
```
TODO:幼林
遵循后进显出原则,包含运算时,使用的时运算结果;
底层原理:
    在非循环和递归语句中,编译时直接填充代码;
    其他情况下,defer语句保存在链表中,采用头插法模式,
    所以遍历时时先进后出的效果;
```
tag的用处
```
是struct的一部分,主要用于反射场景;
```
空struct{}的用处
```
1. 空结构体也是结构体,size为0
2. 所有空结构体指向一个共同地址,zerobase
3. 空结构体作为接收者时,编译器忽略第一个参数,与普通函数一样
4. map的值可以使用空结构体,退化成set,节省点内存
5. chan的值使用空结构体,主要用于信号同步
```
golang运行顺序
```
1. 初始化导入的包,先初始化没有依赖的包
2. 初始化常量
3. 初始化变量
4. init函数,不同文件的init方法按照文件名顺序执行init方法;
    同一个文件中多个init方法,按照代码中的顺序执行
5. main函数
import->const->var->init()->main()
```
内存逃逸
```
定义: 检测变量的生命周期是否完全可知,不可知的变量就称为内存逃逸,
      在堆上进行内存分配
内存逃逸的物种情况:
1. 发送指针的指针获知存储在channel中,无法确定作用域
2. silice中的值时指针或包含指针的字段
3. slice扩容导致内存重新分配
4. inerface上调用方法,interface上调用的方法是动态调度的,不可预测
5. 返回局部变量的引用,生命周期大于栈,导致内存逃逸
避免的方法:
    小变量使用值传递
    尽量使用长度固定的slice
```
interface比较
```
interface 包含类型T和V,需要同时比较interface的值和类型
```
2个nil可能不相等
```
接口值的比较需要转换为接口类型进行比较,会先比较T,2个nil值有可能会T不同
	var p *int = nil
	var i interface{} = p
	fmt.Println(i == p) // true
	fmt.Println(p == nil) // true
	fmt.Println(i == nil) // false
```
接收者T的都能够调用*T的函数吗
```
实现了接收者是值类型的方法,相当于自动实现了接收者是指针类型的方法
而实现了接收者是指针类型的方法,不会自动生成对应接收者是值类型的方法
如果方法的接收者是值类型,无论调用者是对象还是对象指针,修改的都是对象的副本.
不影响调用者,如果方法的接收者是指针类型,则调用者修改的是指针指向的对象本身。
```
协程泄露
```
协程创建后长时间得不到释放,并且还在不断的创建新协程,导致内存耗尽,程序崩溃
```
golang并发模型
```
channel
sync包中的waitgroup
```
切片扩容规则
```
1. 原容量扩容后仍小于需要扩容的容易,扩容容量就是需要扩容的长度
2. 大于需要扩容的时候,如果原容量小于1024,预估容量时扩容前的2倍;
    如果原容量大于1024,预估容量时扩容前容量的1.25倍
3. 同时存储单元的容量也有关,因为内存时类似内存池分配的,不是准确分配的
```
slice深拷贝和浅拷贝
```
浅拷贝#
目的切片和源切片指向同一个底层数组，任何一个数组元素改变，都会同时影响两个数组。
深拷贝
目的切片和源切片指向不同的底层数组，任何一个数组元素改变都不影响另外一个。
主要看是否重新分配内存
```
怎么限制goroutine的数量
```
使用channel限定数量,超了就阻塞
```
Channel是同步的还是异步的
```
Channel是异步进行的
channel存在3种状态：
    nil，未初始化的状态，只进行了声明，或者手动赋值为nil
    active，正常的channel，可读或者可写
    closed，已关闭，千万不要误认为关闭channel后，channel的值是nil
```
| 操作 | 一个零值nil通道 | 一个非零值但已关闭的通道 | 一个非零值且尚未关闭的通道 |
| - | - | - | - |
| 关闭 | 产生恐慌 | 产生恐慌 | 成功关闭 |
| 发送数据 | 永久阻塞 | 产生恐慌 | 阻塞或者成功发送 |
| 接收数据 | 永久阻塞 | 永不阻塞 | 阻塞或者成功接收 |

channel如何实现消息通知的
```
channel应用场景:
    数据交流:
        当作并发的buffer或者queue,解决生产者消费者问题
        多个goroutine可以并发当作生产者（Producer）和消费者（Consumer）。
    数据传递:
        一个goroutine将数据交给另一个goroutine,相当于把数据的拥有权托付出去。
    信号通知:
        一个goroutine可以将信号(closing，closed，data ready等)传递给另一个或者另一组goroutine。
    任务编排:
        可以让一组goroutine按照一定的顺序并发或者串行的执行，这就是编排功能。
    锁机制:
        利用channel实现互斥机制。
channel注意事项:
    向已经关闭的channel中写入数据会发生Panic
    关闭已经关闭的channel会发生Panic
    关闭值为nil的channel会发生Panic

nil是chan的零值,是一种特殊的 chan,对值是nil的chan的发送接收调用者总是会阻塞。
```
对已经关闭的的 chan 进⾏读写，会怎么样？为什么？
```
读已关闭的chan能一直读到东西,但是读到的内容根据通道内关闭前是否有内容而不同
	如果chan关闭前,buff内有元素还未读,会正确读到chan内的值,且返回的第二个值(是否读成功)为true
	如果chan关闭前,buff内所有元素已经呗读完,chan内无值,接下来所有的接收的值都会非阻塞直接成功,返回channel元素的零值,
	但是第二个bool值一直为false
写已经关闭的chan会panic,因为包里面会校验,不允许写已经关闭的chan
```
map如何顺序读取
```
map不能顺序读取，是因为他是无序的，想要有序读取，首先的解决的问题就是，
把key变为有序,所以可以把key放入切片,对切片进行排序，遍历切片，通过key取值。
```
Go中CAS是怎么回事
```
CAS算法(Compare And Swap),是原子操作的一种,CAS算法是一种有名的无锁算法
无锁编程:
    即不使用锁的情况下实现多线程之间的变量同步,也叫非阻塞同步(Non-blocking Synchronization)。
    可用于在多线程编程中实现不被打断的数据交换操作,
    从而避免多线程同时改写某一数据时由于执行顺序不确定性以及中断的不可预知性产生的数据不一致问题。
    该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。
Go中的CAS操作:
    借用CPU提供的原子性指令来实现
    CAS操作修改共享变量时候不需要对共享变量加锁,
    而是通过类似乐观锁的方式进行检查,
    本质还是不断的占用CPU 资源换取加锁带来的开销（比如上下文切换开销）。
```

Context包的用途
```
Context中的方法是协程安全的,所以在父routine中创建的context
可以传递给任意数量的routine并让他们同时访问。
------------------------------------------------------------------------------------
Context中的方法:
    Done:
        会返回一个channel,当该context被取消的时候,该channel会被关闭,
        同时对应的使用该context的routine也应该结束并返回
    Deadline:
        会返回一个超时时间,routine获得了超时时间后,可以对某些io操作设定超时时间。
Context 使用原则:
    1 不要把Context放在结构体中,要以参数的方式传递。
    2 以Context作为参数的函数方法,应该把Context作为第一个参数,放在第一位。
    3 给一个函数方法传递Context的时候,不要传递nil,
        如果不知道传递什么,就使用context.TODO。
    4 Context的Value相关方法应该传递必须的数据,不要什么数据都使用这个传递。
    5 Context是线程安全的，可以放心的在多个goroutine中传递。
```

#### 运行时
---------------------------------------------------------------------------------
垃圾回收
```
golang使用三色标记法+混合写屏障技术
三色标记法:
    所有对象分为黑色,白色和灰色,
    白色: 需要回收的对象,
    灰色: 存活对象,子对象待处理
    黑色: 存活对象
    1. 所有对象加入白色集合
    2. 跟对象标记为灰色,加入灰色集合
    3. 取出一个灰色对象,标记为黑色.其指向的对象标记为灰色
    4. 重复3的过程,直到灰色集合为空
强-弱三色不变式:
    强三色不变式: 不存在黑色对象引用到白色对象的指针
    弱三色不变式: 所有被黑色对象引用的白色对象都处于灰色保护状态
插入屏障:
    具体操作: 在A对象引用B对象的时候,B对象被标记为灰色
    满足: 强三色不变式
    缺点: 结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活
删除屏障:
    具体操作: 被删除的对象,如果自身为灰色和白色,那么被标记为灰色
    满足: 弱三色不变式(保护灰色对象到白色对象的路径不会断)
    缺点:
        回收精度低，GC开始时STW扫描堆栈来记录初始快照
        这个过程会保护开始时刻的所有存活对象
具体流程:
    1. GC开始栈上对象全部标记为黑色
    2. GC期间,任何在栈上创建的新对象标记为黑色
    3. 被删除的对象标记为灰色
    4. 被添加的对象标记为灰色
    5. 栈中的对象在栈回收的适合销毁
```
GC触发的条件
```
主动触发:
    通过runtime.GC触发,会阻塞等待当前GC执行完毕
被动触发:
    使用监控系统,超过2分钟没有GC会强制触发一次
    当内存分配达到一定比例的时候触发
```
golang栈空间
```
go 1.3之前:
    使用分段栈, 当栈空间不足的时候,会申请一段新的空间,并通过指针与原本的栈链接
    分段栈的好处:
        可以按需增长，空间利用率比较高
    分段栈的坏处:
        当一个段即将用尽，这时使用for循环执行一个比较耗空间的函数，会导致函数执行时goroutine进行段的分配，
        而执行完成返回时，进行段的销毁，这样就会导致在循环中出现多次栈的扩容和收缩，造成很大的性能损失，
        这种情况被称作栈分裂
1.3及之后:
    使用连续栈
    当栈空间不够时，直接new一个2倍大的栈空间，并将原先栈空间中的数据拷贝到新的栈空间中，而后销毁旧栈
总结:
    相比于分段栈，连续栈避免了某些场景下栈空间的的频繁伸缩。有一点需要注意的是，连续栈的收缩也是需要重新申请一段空间（原先的1/2大小），并进行栈拷贝操作的
```
Go内存管理
```
Go的内存分配原则:
    Go在程序启动的时候,会先向操作系统申请一块内存(注意这时还只是一段虚拟的地址空间,并不会真正地分配内存),切成小块后自己进行管理。
    申请到的内存块被分配了三个区域,在X64上分别是512MB，16GB，512GB大小。
    TODO 待补充
```
栈的内存是怎么分配的
```
栈和堆区别：
    栈在高地址,从高地址向低地址增长。
    堆在低地址,从低地址向高地址增长。
栈和堆相比优势:
    栈的内存管理简单,分配比堆上快。
    栈的内存不需要回收,而堆需要,无论是主动free,还是被动的垃圾回收,这都需要花费额外的CPU。
    栈上的内存有更好的局部性,堆上内存访问就不那么友好了
```
堆内存管理怎么分配的
```
    把使用的内存块从链表中取出来,然后标记为未使用,当分配内存块的时候
    可以从未使用内存块中有先查找大小相近的内存块,如果找不到,再从未分配的内存中分配内存。
想要深入了解可以看下这个文章,《Writing a Memory Allocator》.
    TODO: 待补充
```
在Go函数中为什么会发生内存泄露
```
内存泄漏:
    能够预期的能很快被释放的内存由于附着在了长期存活的内存上或生命期意外地被延长
    导致预计能够立即回收的内存而长时间得不到回收
内存泄露的形式:
    1 预期能被快速释放的内存因被根对象引用而没有得到迅速释放.
    2 当有一个全局对象时,可能不经意间将某个变量附着在其上,且忽略的将其进行释放,
      则该内存永远不会得到释放。
```

并发级别
```
阻塞:
    阻塞是指一个线程进入临界区后,其它线程就必须在临界区外等待,
    待进去的线程执行完任务离开临界区后，其它线程才能再进去。
无饥饿:
    线程排队先来后到,不管优先级大小,先来先执行,就不会产生饥饿等待资源,也即公平锁;
    相反非公平锁则是根据优先级来执行,有可能排在前面的低优先级线程被后面的高优先级线程插队，就形成饥饿
无障碍:
    共享资源不加锁,每个线程都可以自有读写,单监测到被其他线程修改过则回滚操作,
    重试直到单独操作成功；
    风险就是如果多个线程发现彼此修改了,所有线程都需要回滚,就会导致死循环的回滚中,
    造成死锁
无锁:
    无锁是无障碍的加强版,无锁级别保证至少有一个线程在有限操作步骤内成功退出,
    不管是否修改成功,这样保证了多个线程回滚不至于导致死循环

无等待:
    无等待是无锁的升级版,并发编程的最高境界,无锁只保证有线程能成功退出,
    但存在低级别的线程一直处于饥饿状态,无等待则要求所有线程必须在有限步骤内完成退出,
    让低级别的线程有机会执行,从而保证所有线程都能运行，提高并发度。
```
字符串转成byte数组，会发生内存拷贝吗？
```
只要是发生类型强转都会发生内存拷贝
```
golang小对象过多为什么会消耗CPU
```
三色法遍历多
```
GMP调度
```
定义:
    G: goroutine
    M: 系统线程
    P: processor处理器,包含goroutine资源及可运行的G队列
    M0: 启动程序后编号为0的主线程,对于全局runtime.m0,不需要在heap上分配
        负责执行初始化操作
流程:
    具有一个全局队列和多个本地队列来保存G
    1. 通过go func创建goroutine,G会保存到本地队列
       如果本地队列满了,G会保存到全局队列
    2. 判断M释放存在,M不存在就创建;M会从绑定的P获取G来执行
       如果P的本地队列为空,会从其他MP组合获取G,如果获取不到,
       会从全局队列获取G;大概由1/61的概率从全局队列获取
    3. M调度G的过程时循环获取的
    4. 当M执行一个G阻塞时,runtime会把M从P摘除,创建一个新的线程,
       或者复用空闲线程来服务P
策略:
    work stealing机制: 本线程无可用的G时,尝试从其他线程绑定的P偷取G,而不是销毁线程;
                    有1/61的几率从全局队列获取
    hand off机制: 本线程阻塞时,线程释放绑定的P,把P转移给其他空闲的线程;
M0和G0:
    M0是启动程序后的编号为0的主线程,这个M对应的实例会在全局变量 runtime.m0 中,不需要在 heap 上分配,M0 负责执行初始化操作和启动第一个 G,
    在之后 M0 就和其他的 M 一样了
    G0是每次启动一个M都会第一个创建的goroutine,G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，
    每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0
GMP场景:
    场景一:
        P创建G后优先加入本地队列(局部性原理)
    场景二:
        G1完成后,M运行的goroutine切换为G0,G0负责调度协程的切换;
        从本地队列获取G2,从G0切换到G2并执行,实现M的复用
    场景三:
        本地队列满了后本地队列的一半转移到全局队列,并且新创建的G转移到全局队列
    场景四:
        创建G时,运行的G会尝试唤醒其他空闲的P和M组合执行
    场景五:
        本地没有G的话,从全局队列取一批G放到本地队列
        取的数量是n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))
        至少取一个,从全局队列到P本地队列的负载均衡
    场景六:
        本地和全局队列都没有G,从其他有G的P偷一半过来
    场景七:
        本地队列为空,全局队列为空,M陷入自旋状态
```
G0的作用
```
g0作为一个特殊的goroutine,为scheduler执行调度循环提供了场地(栈)
对于一个线程来说,g0总是它第一个创建的goroutine
之后,它会不断地寻找其他普通的goroutine来执行,直到进程退出。
当需要执行一些任务,且不想扩栈时,就可以用到 g0了,因为 g0 的栈比较大。
g0 其他的一些“职责”有:
    创建 goroutine
    deferproc 函数里新建 _defer
    垃圾回收相关的工作（例如 stw、扫描 goroutine 的执行栈、一些标识清扫的工作、栈增长）等等。
```
Go中new和make的区别
```
new该方法的参数要求传入一个类型,而不是一个值,它会申请一个该类型大小的内存空间,并会初始化为对应的零值,返回指向该内存空间的一个指针。
make也是用于内存分配,但是和new不同.只用来引用对象slice、map和channel的内存创建,它返回的类型就是类型本身,而不是它们的指针类型。
```
抢占式goroutine
```
 协作式调度依靠被调度方主动弃权
 抢占式调度则依靠调度器强制将被调度方被动中断
```
golang的内存模型
```
内存一致模型:
    或称内存模型,是一份语言用户与语言自身,语言自身与所在的操作系统平台,所在操作系统平台与硬件平台之间的契约;
    它定义了并行状态下拥有确定读取和写入的时序的条件.并回答了一个共享变量是否具有足够的同步机制来保障
    一个线程的写入能否发生在另一个线程的读取之前这个问题
Go语言的内存模型规定了一个goroutine可以看到另外一个goroutine修改同一个变量的值的条件
为了保证多goroutine下读取共享数据的正确性，go中引入happens before原则，即在go程序中定义了多个内存操作执行的一种偏序关系。如果操作e1先于e2发生，我们说e2 happens after e1,如果e1操作既不先于e2发生又不晚于e2发生，我们说e1操作与e2操作并发发生

```
#### grpc
------------------------------------------------------------------------------------
grpc
```
gRPC: RPC框架中的一种,RPC是一种设计理念，而gRPC是基于此种设计理念设计的真实框架。
rest: 描述的是在网络中client和server的一种交互形式；
        一个架构样式的网络系统，指的是一组架构约束条件和原则。
```
grpc相对于rest的优势
```
gRPC 对接口有严格的约束条件，安全性更高，对于高并发的场景更适用
```
为什么选择grpc
```
grpc有明确的接口规范和对于流的支持；
RPC 效率更高。RPC使用自定义的 TCP 协议，可以让请求报文体积更小，或者使用 HTTP2 协议，也可以很好的减少报文的体积，提高传输效率。
```
3、golang里面常用到的技术栈有哪些？
协程、通道、web框架、密码学等

4、gin框架的好处是什么？
```
快速：基于Radix树的路由,性能非常强大。
支持中间件：内置许多中间件，如Logger,Gzip,Authorization等。
崩溃恢复：可以捕捉panic引发的程序崩溃，使Web服务可以一直运行。
JSON验证：可以验证请求中JSON数据格式。
多种数据渲染方式：支持HTML、JSON、YAML、XML等数据格式的响应。
扩展性：非常简单扩展中间件。
```

##### 优化
Google代码性能优化
```
```
channel实现
```
```
