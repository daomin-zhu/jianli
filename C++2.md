
### C++基础
extern 关键字的作用

```
    extern声明变量在外部的定义？
        1、 全局变量如果不在文件开始定义,则其作用域有效区域为定义部分到文件结尾,之前的部分如果需要使用全局变量,需要使用extern声明
        2、 如果多个文件公用一个全局变量,在非定义文件中需要使用extern声明
    extern 修饰函数？
        与修饰变量作用类似,如果在一个文件中定义了函数func1，在另一个文件中可以使用extern声明这个函数，然后直接调用;不需要包含头文件；一般使用在较小的文件中，较大的文件通过头文件来使用；
    extern C的作用
        为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后,会指示编译器这部分代码按C语言的方式进行编译。由于C++支持函数重载,因此编译器编译函数的过程中会将函数的参数类型加到编译后的代码中,而不仅仅是函数名;而C语言不支持函数重载,因此编译C语言代码不会带上函数的参数类型,一般只包含函数名；
```

为什么要使用字节对齐
```
字节对齐是C/C++编译器的一种技术手段，主要是在可接受空间浪费的前提下，尽可能地提高对相同元素过程的快速处理。
（比如32位系统，4字节对齐能使CPU访问速度提高）
需要字节对齐的根本原因在于CPU访问数据的效率问题。
    因为现代计算机都使用了Cache。Cache可以看成一些可以用非常快的速度进行访问的临时内存。但是Cache的容量不大，CPU访问内存非常慢，
    所以硬件会将平时经常使用的内容存放到Cache里面。Cache是通过一些Cache Line来组织的，每一条Cache Line一般包含16个字节，32个字节或64个字节等。 
    比如某个计算机一级Cache的Cache Line长度是32个字节，那么每段Cache Line总是会包含32个字节对齐的一段内存。
    现在有一个4字节的整数，如果它的地址不是4字节对齐的，那么就有可能访问它的时候，需要使用两条Cache Line,这增加了总线通讯量，而且增加了对Cache的使用量，
    而且使用的数据没有在Cache里面（这时需要将数据从内存调入Cache,会非常慢）的机会会增加，这些都降低了程序的速度。
字节对齐的原则
    从0位置开始存储；
    变量存储的起始位置是该变量大小的整数倍；
    结构体总的大小是其最大元素的整数倍，不足的后面要补齐；
    结构体中包含结构体，从结构体中最大元素的整数倍开始存；
    如果加入pragma pack(n) ，取n和变量自身大小较小的一个。
```
C++11有哪些新特性
```
    1）关键字及新语法：auto、nullptr、for
    2）STL容器：std::array、std::forward_list、std::unordered_map、std::unordered_set
    3）多线程：std::thread、std::atomic、std::condition_variable
    4）智能指针内存管理：std::shared_ptr、std::weak_ptr
    5）其他：std::function、std::bind和lamda表达式
```
引用和指针的区别？
```
1) 指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。
2) 引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）
3) 有多级指针，但是没有多级引用，只能有一级引用。
4) 指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）
5) sizeof 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。
6) 引用访问一个变量是直接访问，而指针访问一个变量是间接访问。
7) 使用指针前最好做类型检查，防止野指针的出现；
8) 引用底层是通过指针实现的；
9) 作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。
```

指针与数组千丝万缕的联系
```
    一个一维int数组的数组名实际上是一个int* const 类型；
    一个二维int数组的数组名实际上是一个int (*const p)[n];
    数组名做参数会退化为指针，除了sizeof
```
静态变量什么时候初始化
```
1) 初始化只有一次，但是可以多次赋值，在主程序之前，编译器已经为其分配好了内存。
2) 静态局部变量和全局变量一样，数据都存放在全局区域，所以在主程序之前，编译器已经为其分配好了内存，但在C和C++中静态局部变量的初始化节点又有点不太一样。
    在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，
    变量所处的全局内存会被全部回收。
    在C++中，初始化时在执行相关代码时才会进行初始化，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，
    在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，
    并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。
    所以在C++中是可以使用变量对静态局部变量进行初始化的。
```
指针和const的用法
```
1) 当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。
2) int const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过p2读写这个变量的值。顶层指针表示指针本身是一个常量
3) int const *p1或者const int p1两种情况中const修饰p1，所以理解为p1的值不可以改变，即不可以给p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。底层指针表示指针所指向的变量是一个常量。
4) int const *const p;
```
5. C++中的指针参数传递和引用参数传递
```
1) 指针参数传递本质上是值传递，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。
2) 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。
3) 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。
4) 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。
```
6. 形参与实参的区别？
```
1) 形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。
2) 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。
3) 实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。
4) 函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。
5) 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。
    1) 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象  或是大的结构体对象，将耗费一定的时间和空间。（传值）
    2) 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）
    3) 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）
    4) 效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。
```
7. static的用法和作用？
```
1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。
2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。
    共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。
3.static的第三个作用是默认初始化为0（static变量）其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。
    在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。
4.static的第四个作用：
    C++中的类成员声明static
        1) 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值； 
        2) 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；  
        3) 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；  
        4) 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；  
        5) 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。类内：
        6) static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；
        7) 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，
            所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；
        8) static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，
            虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function

-----------------------------------------------------------------------------------------------------------------------------------------------
    static 修饰全局变量
        限定变量使用范围只能在本文件中使用,即使使用extern外部声明也不可以在其他文件内使用；
    static 修饰普通函数
        限定使用范围,这个函数只能在本文件内使用,不能被其他文件调用.
    static 修饰成员变量
        static成员变量属于类,不属于某个具体的对象,即使创建多个对象,所有对象使用的都是这份内存中的数据,当某个对象修改这个变量,其他对象也会影响其他对象
        static成员变量必须在类声明的外部初始化,具体形式为:  type class::name = value
        静态成员变量初始化时不能再加static 但必须要有数据类型
        static成员变量的内存既不是在声明类时分配,也不是在创建对象时分配,而是在初始化时分配；
        static既可以通过类直接访问 Class::static 也可以通过Object.static访问,也可以Point->static访问
        这三种方式等效
        static成员变量不占用对象的内存,而是在所有对象之外开辟内存,即使不创建对象也可以访问

    static 修饰成员函数
        1. static成员函数不包含this指针，所以static成员函数不能访问非static类成员,只能访问static修饰的类成员
        2.static成员函数不能定义为const的，static函数不能访问非静态成员变量(备注:编译错误 static member function  cannot have cv-qualifier)   
引用:
    2.1 总的来说
    （1）在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。
    （2）static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。
    （3）static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。
    （4）不想被释放的时候，可以使用static修饰。比如修饰函数中存放在栈空间的数组。如果不想让这个数组在函数调用结束释放可以使用 static 修饰。
    （5）考虑到数据安全性（当程序想要使用全局变量的时候应该先考虑使用 static）。
    2.2 静态变量与普通变量
    静态全局变量有以下特点：

    （1）静态变量都在全局数据区分配内存，包括后面将要提到的静态局部变量;
    （2）未经初始化的静态全局变量会被程序自动初始化为0（在函数体内声明的自动变量的值是随机的，除非它被显式初始化，而在函数体外被声明的自动变量也会被初始化为 0）；
    （3）静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的。
    优点：静态全局变量不能被其它文件所用；其它文件中可以定义相同名字的变量，不会发生冲突。

    （1）全局变量和全局静态变量的区别
    1）全局变量是不显式用 static 修饰的全局变量，全局变量默认是有外部链接性的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过 extern 全局变量名的声明，就可以使用全局变量。
    2）全局静态变量是显式用 static 修饰的全局变量，作用域是声明此变量所在的文件，其他的文件即使用 extern 声明也不能使用。
    2.3 静态局部变量有以下特点：
    （1）该变量在全局数据区分配内存；
    （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；
    （3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为 0；
    （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，当定义它的函数或语句块结束时，其作用域随之结束。
    一般程序把新产生的动态数据存放在堆区，函数内部的自动变量存放在栈区。自动变量一般会随着函数的退出而释放空间，静态数据（即使是函数内部的静态局部变量）也存放在全局数据区。全局数据区的数据并不会因为函数的退出而释放空间。


    static 修饰局部变量 
        存储区: 由栈变为静态存储区,生存期为整个源程序,只能在定义该变量的函数内使用.退出该函数后,尽管变量还继续存在,但不能使用他；
        作用域: 作用域仍为局部作用域,当定义它的函数或者语句块结束的时候,作用域随之结束.
    static 修饰对象,如果类生命了构造函数,则会调用类的构造函数来初始化对象,如果没有的话,不会合成默认构造函数,但是依然会初始化,类的内置类型成员与普通内置类型初始化相同； 
```
8. volatile的作用是什么
```
        1. 访问寄存器要比访问内存快,因此CPU会优先访问该数据在寄存器中的存储效果,但是内存中的数据可能已经发生改变,而寄存器中还保留着原来的结果.为了避免这种情况的发生,将该变量声明为volatile,告诉cpu每次都从内存去读取数据.
        2. 一个参数可以即是const又是volatile的吗？ 可以
```    
9. const的作用: 
```
        1. const 修饰全局变量
        2. const 修饰局部变量
        3. const 修饰指针const int *;
        5. const 修饰指针指向的对象 int * const
        6. const 修饰成员变量,必须在构造函数列表中初始化
        7. const 修饰成员函数,说明该函数不应该修改非静态成员,但是这并不十分可靠,指针所指的非静态成员可能会被改变
 ```   
10. new与malloc的区别: 验证下 operator new delete 与 delete new的效果
```
        1. new分配内存按照数据类型进行分配,malloc分配内存按照大下分配；
        2. new不仅分配一段内存,而且会调用构造函数,但是malloc不会；
            解析:
            new实现的原理:  
                调用operator new 函数申请空间
                在申请的空间上执行构造函数,完成对象的构造
            delete的原理:
                在空间上执行析构函数,完成对象中资源的清理工作在空间上执行析构函数,完成对象中资源的清理工作
            new T[N]的原理:
                调用operator new[]函数,在operator new[]中实际调用operator new函数完成N个对象的申请
                在申请的空间上执行N次构造函数
            delete[]的原理;
                在是否的对象空间上执行N次析构函数,完成N个对象中的资源的清理
                调用operator delete[]释放空间,实际在operator delete[]中调用operator delete来释放空间

        3. new返回的是指定对象的指针,而malloc返回的是void*
        4. new是一个操作符可以重载,malloc是一个库函数
        5. new分配的内存要用delete销毁,malloc要用free来销毁;delete销毁的时候会调用对象的析构函数,而free不会
        6. malloc分配的内不够的时候,可以用realloc扩容(扩容的原理？) new没有这样的操作
        7. new如果分配失败了会抛出bad_malloc的异常,而malloc失败了会返回NULL。因此对于new，正确的字试是采用try...catch语法,而malloc则应该判断指针的返回值,为了兼容很多c语言程序员的习惯,c++也可以采用new nothrow的方法禁止抛出异常返回NULL;
        8. new和new[] 的区别,new[]一次分配所有内存,多次调用构造函数;分别搭配使用delete和delete[].
        9. 谈谈new和malloc的实现,空闲链表,分配方法(首次适配原则,最佳视频原则,最差适配原则,快速适配原则)。delete和free实现原理；free为什么知道销毁多大的空间;

    malloc的实现方案：
        1）malloc 函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。
        2）调用 malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。
        3）调用 free 函数时，它将用户释放的内存块连接到空闲链表上。
        4）到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。

    brk和mmap：从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。
        1、brk是将数据段(.data)的最高地址指针_edata往高地址推；
        2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk，mmap，munmap这些系统调用实现的。
    申请后系统的响应
        栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
        堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲 结点链表中删除，
            并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。
            另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。
    申请大小的限制及生长方向
        栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，
            栈的大小是2M（也可能是1M，它是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。
            因此，能从栈获得的空间较小 。
        堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。
            堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
    申请效率的比较：
        栈由系统自动分配，速度较快。但程序员是无法控制的。
        堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
    堆和栈中的存储内容
    栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，
        参数是由右往左入栈的，然后是函数中的局部变量。
        注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
```
11. sizeof和strlen的区别
```
1 sizeof是运算符，而strlen是函数；
2 sizeof的用法是sizeof(参数)，这个参数可以是数组，指针，类型，对象，甚至是函数，其值在编译的时候就计算好了，而strlen的参数必须是字符型指针（char*）,
    其值必须在函数运行的时候才能计算出来；
3 sizeof的功能是获得保证能容纳实现的建立的最大对象的字节的大小，而strlen的功能是返回字符串的长度，切记这里的字符串的长度是包括结束符的；
4 当数组作为参数传递给函数的时候，传的是指针，而不是数组，传递数组的首地址；
```

12. C++多态性和虚函数表
```
       多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现,在编译的时候确定。
       动态多态通过虚函数和继承关系实现,执行动态绑定,在运行的时候确定。
       动态多态实现有几个条件:
        1. 虚函数
        2. 一个基类的指针或引用指向派生类的对象

            基类指针在调用成员函数(虚函数)时,就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地址。
            查找该虚函数表中该函数的指针进行调用。每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，
            该类的对象的都指向这同一个虚函数表。虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，
            虚函数表直接从基类也继承过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该调用哪个函数。
        虚函数实现原理：
            虚函数表和虚函数指针。纯虚函数： virtual int fun() = 0;函数的运行版本由实参决定，在运行时选择函数的版本，所以动态绑定又称为运行时绑定。当编译器遇到一个模板定义时，它并不生成代码。只有当实例化出模板的一个特定版本时，编译器才会生成代码。
```
13. 虚函数可以声明为inline吗?
```
1)  虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。
    而内联函数用于提高效率。内联函数的原理是，在编译期间，对调用内联函数的地方的代码替换成函数代码。
    内联函数对于程序中需要频繁使用和调用的小函数非常有用。
2)  虚函数要求在运行时进行类型确定，而内敛函数要求在编译期完成相关的函数替换；
```

50. 虚函数的作用？
```
    虚函数用于实现多态，这点大家都能答上来
    但是虚函数在设计上还具有封装和抽象的作用。比如抽象工厂模式。(实现下)
    动态绑定是如何实现的？
    第一个问题中基本回答了，主要都是结合虚函数表来答就行。
    静态多态和动态多态。静态多态是指通过模板技术或者函数重载技术实现的多态，其在编译器确定行为。动态多态是指通过虚函数技术实现在运行期动态绑定的技术。

    虚函数表
        虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？
        编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。
    纯虚函数如何定义，为什么对于存在虚函数的类中析构函数要定义成虚函数
        为了实现多态进行动态绑定，将派生类对象指针绑定到基类指针上，对象销毁时，如果析构函数没有定义为析构函数，
        则会调用基类的析构函数，显然只能销毁部分数据。
        如果要调用对象的析构函数，就需要将该对象的析构函数定义为虚函数，销毁时通过虚函数表找到对应的析构函数。
        纯虚函数定义
        virtual ~myClass() = 0;
```

51. 析构函数能抛出异常吗
```
    答案肯定是不能。 
    C++标准指明析构函数不能、也不应该抛出异常。
    C++异常处理模型最大的特点和优势就是对C++中的面向对象提供了最强大的无缝支持。
    那么如果对象在运行期间出现了异常，C++异常处理模型有责任清除那些由于出现异常所导致的已经失效了的对象(也即对象超出了它原来的作用域)，
    并释放对象原来所分配的资源， 这就是调用这些对象的析构函数来完成释放资源的任务，
    所以从这个意义上说，析构函数已经变成了异常处理的一部分。
    (1) 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，
        则这些动作不会执行，会造成诸如资源泄漏的问题。
    (2) 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，
        则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。
```

14. 类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？
```
1)  赋值初始化，通过在函数体内进行赋值初始化；
    列表初始化，在冒号后使用初始化列表进行初始化。
    这两种方式的主要区别在于：
        对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。
        列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),
        那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。 
2)  一个派生类构造函数的执行顺序如下：
    ① 虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。
    ② 基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。
    ③ 类类型的成员对象的构造函数（按照初始化顺序）
    ④ 派生类自己的构造函数。
3) 方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。
    我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。
```
15. 成员列表初始化？
```
1) 必须使用成员初始化的四种情况
    ① 当初始化一个引用成员时；
    ② 当初始化一个常量成员时；
    ③ 当调用一个基类的构造函数，而它拥有一组参数时；
    ④ 当调用一个成员类的构造函数，而它拥有一组参数时；
2) 成员初始化列表做了什么
    ① 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；
    ② list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；
```

16. 必须在构造函数初始化式里进行初始化的数据成员有哪些
```
    (1) 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
    (2) 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
    (3) 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化
```

17. 构造函数为什么不能为虚函数？析构函数为什么要虚函数？
```
1.  从存储空间角度，虚函数相应一个指向vtable虚函数表的指针，这大家都知道，但是这个指向vtable的指针事实上是存储在对象的内存空间的。
    问题出来了，假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？
    所以构造函数不能是虚函数。 
2.  从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。
    构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。
    虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。
    而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。 
3.  构造函数不须要是虚函数，也不同意是虚函数，由于创建一个对象时我们总是要明白指定对象的类型，
    虽然我们可能通过实验室的基类的指针或引用去訪问它但析构却不一定，我们往往通过基类的指针来销毁对象。
    这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。 
4.  从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数从实际含义上看，
    在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；
    并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。 
5.  当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR。
    因此，它仅仅能知道它是“当前”类的，而全然忽视这个对象后面是否还有继承者。
    当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（由于类不知道谁继承它）。
    所以它使用的VPTR必须是对于这个类的VTABLE。并且，仅仅要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE,
    但假设接着另一个更晚派生的构造函数被调用，这个构造函数又将设置VPTR指向它的 VTABLE，等.直到最后的构造函数结束。
    VPTR的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的还有一个理由。
    可是，当这一系列构造函数调用正发生时，每一个构造函数都已经设置VPTR指向它自己的VTABLE。
    假设函数调用使用虚机制，它将仅仅产生通过它自己的VTABLE的调用，而不是最后的VTABLE（全部构造函数被调用后才会有最后的VTABLE）。
    因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。
    另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。
    直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
    假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。
    那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。
```
18. 析构函数的作用，如何起作用？
 ```
1)  构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。
    规则，只要你一实例化对象，系统自动回调用一个构造函数，就是你不写，编译器也自动调用一次。
2)  析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；
    特点：析构函数与构造函数同名，但该函数前面加~。 析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。 
    当撤销对象时，编译器也会自动调用析构函数。 每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。
    一般析构函数定义为类的公有成员。
 ```
19. 构造函数和析构函数可以调用虚函数吗，为什么
```
1) 在C++中，提倡不在构造函数和析构函数中调用虚函数；
2) 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；
3) 因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；
4) 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，
    派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。
```

20. 构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？
```
1) 构造函数顺序
    ① 基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。
    ② 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。
    ③ 派生类构造函数。
2) 析构函数顺序
    ① 调用派生类的析构函数；
    ② 调用成员类对象的析构函数；
    ③ 调用基类的析构函数。
```

21. 虚析构函数的作用，父类的析构函数是否要设置为虚函数？
```
1) C++中基类采用virtual虚析构函数是为了防止内存泄漏。
    具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。
    假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。
    那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。
    所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。
2)  纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。
    因此，缺乏任何一个基类析构函数的定义，就会导致链接失败。因此，最好不要把虚析构函数定义为纯虚析构函数。
```
22. 构造函数析构函数可以调用虚函数吗？
```
1) 在构造函数和析构函数中最好不要调用虚函数；
2) 构造函数或者析构函数调用虚函数并不会发挥虚函数动态绑定的特性，跟普通函数没区别；
3) 即使构造函数或者析构函数如果能成功调用虚函数， 程序的运行结果也是不可控的。
```

23. 构造函数析构函数可否抛出异常
```
1)  C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。
    因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。
2)  用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；
3)  如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；
4)  如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。
```
24. 在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？
```
父构造函数 子构造函数 子析构函数 父析构函数
```
25. 在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？
```
    构造函数不能够声明为虚函数:
        1. 构造一个对象需要先确定对象的类型,而虚函数是在运行时确定的，虚构造函数无法在构造对象的时候确定所构造的对象类型;
        2. 虚函数的执行需要依赖于虚函数表。而虚函数表在构造函数中进行初始化工作,即初始化vptr，让它指向正确的虚函数表。而在构造
            对象期间,虚函数表还没有被初始化,将无法进行。
    析构函数可以被声明为虚函数,且在某些情况下必须声明为虚函数:
        1. 在类的继承中,如果有积累指针执行派生类,那么用基类指针delete是时,如果不定义为虚函数,派生类中派生的那部分无法析构;
    构造函数析构函数是否能够调用虚函数:
    １.　从语法上讲，调用完全没有问题。
    ２.　但是从效果上看，往往不能达到需要的目的。
    Effective 的解释是：
        派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。
        同样，进入基类析构函数时，对象也是基类类型。
        所以，虚函数始终仅仅调用基类的虚函数（如果是基类调用虚函数），不能达到多态的效果，所以放在构造函数中是没有意义的，而且往往不能达到本来想要的效果。
```
26. 什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？
```
    虚表:  虚函数的地址表,按照虚函数声明的顺序存储,如果子类覆盖父类函数,虚函数表中同样会覆盖;
```

33. mutable
```
1) 如果需要在const成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为mutable。即用mutable修饰的成员变量不受const成员方法的限制;
2) 可以认为mutable的变量是类的辅助状态，但是只是起到类的一些方面表述的功能，修改他的内容我们可以认为对象的状态本身并没有改变的。实际上由于const_cast的存在，这个概念很多时候用处不是很到了。
```
34. 深拷贝与浅拷贝？
```
1) 浅复制 —-只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。深复制 —-在计算机中开辟了一块新的内存地址用于存放复制的对象。
2) 在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。
```
35. C++模板是什么，底层怎么实现的？
```
1) 编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。
2) 这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。
```
36. C语言struct和C++struct区别
```
1) C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）。
2) C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数。
3) C++中，struct的成员默认访问说明符为public（为了与C兼容），class中的默认访问限定符为private，struct增加了访问权限，且可以和类一样有成员函数。
4) struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名
```
37. 类如何实现只能静态分配和只能动态分配
```
1) 前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建
2) 建立类的对象有两种方式：① 静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；② 动态建立，A *p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；
3) 只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有。
```
38. 如果想将某个类用作基类，为什么该类必须定义而非声明？
```
1) 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。
```
39. 什么情况会自动生成默认构造函数？
```
1) 带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。不过这个合成操作只有在构造函数真正被需要的时候才会发生；如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；
2) 带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；
3) 带有一个虚函数的类
4) 带有一个虚基类的类
5) 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。
```
40. 什么是类的继承？
```
1) 类与类之间的关系has-A包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；is-A，继承关系，关系具有传递性；
2) 继承的相关概念所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；
3) 继承的特点子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；
4) 继承中的访问控制public、protected、private
5) 继承中的构造和析构函数
6) 继承中的兼容性原则
```
41. 什么是组合？
```
1) 一个类里面的数据成员是另一个类的对象，即内嵌其他类的对象作为自己的成员；创建组合类的对象：首先创建各个内嵌对象，难点在于构造函数的设计。创建对象时既要对基本类型的成员进行初始化，又要对内嵌对象进行初始化。
2) 创建组合类对象，构造函数的执行顺序：先调用内嵌对象的构造函数，然后按照内嵌对象成员在组合类中的定义顺序，与组合类构造函数的初始化列表顺序无关。然后执行组合类构造函数的函数体，析构函数调用顺序相反。
```
42. 抽象基类为什么不能创建对象？
```
抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。
（1）抽象类的定义：   称带有纯虚函数的类为抽象类。
（2）抽象类的作用：   抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。
（3）使用抽象类时注意：  抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。
    一、纯虚函数定义 　纯虚函数是一种特殊的虚函数，它的一般格式如下： 　　class <类名> 　　{ 　　virtual <类型><函数名>(<参数表>)=0; 　　… 　　}; 　在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。 　　
    纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象。
    二、纯虚函数引入原因 　 
        1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 　 
        2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。 　　
        为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;）。
        若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。
        这样就很好地解决了上述两个问题。 例如，绘画程序中，shape作为一个基类可以派生出圆形、矩形、正方形、梯形等， 如果我要求面积总和的话，那么会可以使用一个 shape * 的数组，只要依次调用派生类的area()函数了。如果不用接口就没法定义成数组，因为既可以是circle ,也可以是square ,而且以后还可能加上rectangle，等等.三、相似概念 1、多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。
        C++支持两种多态性：编译时多态性，运行时多态性。 　　
            a.编译时多态性：通过重载函数实现 　　
            b.运行时多态性：通过虚函数实现。 2、虚函数 　　虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。 
    3、抽象类 　　包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象。
```

43. 类什么时候会析构？
```
1) 对象生命周期结束，被销毁时；
2) delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；
3) 对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。
```
44. 为什么友元函数必须在类内部声明？
```
1) 因为编译器必须能够读取这个结构的声明以理解这个数据类型的大、行为等方面的所有规则。有一条规则在任何关系中都很重要，那就是谁可以访问我的私有部分
```

46. 继承机制中对象之间如何转换？
```
指针和引用之间如何转换？
1) 向上类型转换将派生类指针或引用转换为基类的指针或引用被称为向上类型转换，向上类型转换会自动进行，而且向上类型转换是安全的。
2) 向下类型转换将基类指针或引用转换为派生类指针或引用被称为向下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类，所以在向下类型转换时必须加动态类型识别技术。RTTI技术，用dynamic_cast进行向下类型转换。
```
47. 组合与继承优缺点？
```
一：继承继承是Is a 的关系，比如说Student继承Person,则说明Student is a Person。
    继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。
    继承的缺点有以下几点：
        ①：父类的内部细节对子类是可见的。
        ②：子类从父类继承的方法在编译时就确定下来了，所以无法在运行期间改变从父类继承的方法的行为。
        ③：如果对父类的方法做了修改的话（比如增加了一个参数），则子类的方法必须做出相应的修改。
        所以说子类与父类是一种高耦合，违背了面向对象思想。
二：组合组合也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。
    组合的优点：
        ①：当前对象只能通过所包含的那个对象去调用其方法，所以所包含的对象的内部细节对当前对象时不可见的。
        ②：当前对象与包含的对象是一个低耦合关系，如果修改包含对象的类中代码不需要修改当前对象类的代码。
        ③：当前对象可以在运行时动态的绑定所包含的对象。可以通过set方法给所包含对象赋值。
    组合的缺点：
        ①：容易产生过多的对象。
        ②：为了能组合多个对象，必须仔细对接口进行定义。
```
48. 左值右值
```
1) 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。
    在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。
    举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&a可以获取该变量的地址；
    表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。
2) C++11对C++98中的右值进行了扩充。
    在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。
    其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，
    这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&&的函数返回值、std::move的返回值，或者转换为T&&的类型转换函数的返回值。
    将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。
3) 左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。
4) 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。
```
49. 移动构造函数
```
1) 我们用对象a初始化对象b，后对象a我们就不在使用了，但是对象a的空间还在呀（在析构之前），既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；
2) 拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以我们只要避免第一个指针释放空间就可以了。避免的方法就是将第一个指针（比如a->value）置为NULL，这样在调用析构函数的时候，由于有判断是否为NULL的语句，所以析构a的时候并不会回收a->value指向的空间；
3) 移动构造函数的参数和拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只用用一个右值，或者将亡值初始化另一个对象的时候，才会调用移动构造函数。而那个move语句，就是将一个左值变成一个将亡值。
```
54. 智能指针是怎么实现的？什么时候改变引用计数？
```
    构造函数中计数初始化为1；
    拷贝构造函数中计数值加1；
    赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；
    析构函数中引用计数减一；
    在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象。
    share_prt<T>与weak_ptr<T>的区别？
    //share_ptr可能出现循环引用，从而导致内存泄露
    class A
    {
        public:
        share_ptr<B> p;
    };

    class B
    {
        public:
        share_ptr<A> p;
    }
    int main()
    {
        while(true)
        {
            share_prt<A> pa(new A()); //pa的引用计数初始化为1
            share_prt<B> pb(new B()); //pb的引用计数初始化为1
            pa->p = pb; //pb的引用计数变为2
            pb->p = pa; //pa的引用计数变为2
        }
        //假设pa先离开，引用计数减一变为1，不为0因此不会调用class A的析构函数，因此其成员p也不会被析构，pb的引用计数仍然为2；
        //同理pb离开的时候，引用计数也不能减到0
        return 0;
    }
    /*
    ** weak_ptr是一种弱引用指针，其存在不会影响引用计数，从而解决循环引用的问题
    */
```
55. C++四种类型转换：static_cast, dynamic_cast, const_cast, reinterpret_cast
```
    const_cast用于将const变量转为非const
    static_cast用的最多，对于各种隐式转换，非const转const，void*转指针等, static_cast能用于多态想上转化，如果向下转能成功但是不安全，结果未知；
    dynamic_cast用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。
        只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。
    reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；
    为什么不使用C的强制转换？C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。
```


57. 内联函数有什么优点？内联函数与宏定义的区别？
```
    宏定义在预编译的时候就会进行宏替换；
    内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译。
    内联函数相比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。
    使用宏定义函数要特别注意给所有单元都加上括号，#define MUL(a, b) a b，这很危险，正确写法：#define MUL(a, b) ((a) (b))
```

### STL

59. STL里的内存池实现
```
    STL内存分配分为一级分配器和二级分配器，一级分配器就是采用malloc分配内存，二级分配器采用内存池。
        二级分配器设计的非常巧妙，分别给8k，16k,..., 128k等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。
        需要分配内存时从合适大小的链表中取一块下来。假设需要分配一块10K的内存，那么就找到最小的大于等于10k的块，也就是16K，
        从16K的空闲链表里取出一个用于分配。释放该块内存时，将内存节点归还给链表。
        如果要分配的内存大于128K则直接调用一级分配器。为了节省维持链表的开销，采用了一个union结构体，
        分配器使用union里的next指针来指向下一个节点，而用户则使用union的空指针来表示该节点的地址。
```

60. STL里set和map是基于什么实现的。红黑树的特点？
```
set和map都是基于红黑树实现的。
    红黑树是一种平衡二叉查找树，与AVL树的区别是什么？AVL树是完全平衡的，红黑树基本上是平衡的。
    为什么选用红黑数呢？因为红黑数是平衡二叉树，其插入和删除的效率都是N(logN)，与AVL相比红黑数插入和删除最多只需要3次旋转，
        而AVL树为了维持其完全平衡性，在坏的情况下要旋转的次数太多。
    红黑树的定义：
    (1) 节点是红色或者黑色；
    (2) 父节点是红色的话，子节点就不能为红色；
    (3) 从根节点到每个页子节点路径上黑色节点的数量相同；
    (4) 根是黑色的，NULL节点被认为是黑色的。

STL里的其他数据结构和算法实现也要清楚
这个问题，把STL源码剖析好好看看，不仅面试不慌，自己对STL的使用也会上升一个层次。
```

61. 模板特化
```
    (1) 模板特化分为全特化和偏特化，模板特化的目的就是对于某一种变量类型具有不同的实现，因此需要特化版本。
    例如，在STL里迭代器为了适应原生指针就将原生指针进行特化。
```
容器的区别
```
array 是固定大小的顺序容器，它们保存了一个以严格的线性顺序排列的特定数量的元素。
vector 是表示可以改变大小的数组的序列容器。
deque 容器为一个给定类型的元素进行线性处理，像向量一样，它能够快速地随机访问任一个元素，并且能够高效地插入和删除容器的尾部元素。
    但它又与vector不同，deque支持高效插入和删除容器的头部元素，因此也叫做双端队列。
    deque的中控器: deque是由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。
    deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器结构。
list时双链表，forward_list是单链表，forward_list（单向链表）是序列容器，允许在序列中的任何地方进行恒定的时间插入和擦除操作。
    在链表的任何位置进行插入/删除操作都非常快。
    forward_list只提供钱箱迭代器，因此不支持反向迭代器，比如rbegin()等成员函数。
    forward_list不提供size（）成员函数。
    forward_list没有指向最末元素的锚点，因此不提供back（）、push_back（）和pop_back（）。
    forward_list不提供随机访问，这一点跟list相同。
    插入和删除元素不会造成“指向至其他元素”的指针，引用和迭代器失效。
    list双向链表，是序列容器，允许在序列中的任何地方进行常数时间插入和擦除操作，并在两个方向上进行迭代,可以高效地进行插入删除元素。
stack没有迭代器，是一种容器适配器，用于在LIFO（后进先出）的操作，其中元素仅从容器的一端插入和提取。 
    stack底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
queue 是一种容器适配器，用于在FIFO（先入先出）的操作，其中元素插入到容器的一端并从另一端提取。
    队列不提供迭代器，不实现遍历操作。
优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。

set 是按照特定顺序存储唯一元素的容器。
    set 的 底层数据结构是 红黑树，一种高效的平衡检索二叉树。
    对 set 进行插入删除操作 都不会引起iterator的失效，因为迭代器相当于一个指针指向每一个二叉树的节点，对set的插入删除并不会改变原有内存中节点的改变， 
    但是vector的插入删除操作一般会发生内存移动和内存拷贝，所以会发生迭代器的失效。
    set容器的检索速度很快，因为采用二分查找的方法 。
map 是关联容器，按照特定顺序存储由 key value (键值) 和 mapped value (映射值) 组合形成的元素。
vector中的reserve和resize的区别
    reserve是直接扩充到已经确定的大小，可以减少多次开辟、释放空间的问题（优化push_back），就可以提高效率，其次还可以减少多次要拷贝数据的问题。
    reserve只是保证vector中的空间大小（capacity）最少达到参数所指定的大小n。reserve()只有一个参数。
resize()可以改变有效空间的大小，也有改变默认值的功能。capacity的大小也会随着改变。resize()可以有多个参数

vector中的size和capacity的区别
    size表示当前vector中有多少个元素（finish - start）;
    capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage - start）;
vector中erase方法与algorithn中的remove方法区别
    vector中erase方法真正删除了元素，迭代器不能访问了
    remove只是简单地将元素移到了容器的最后面，迭代器还是可以访问到。因为algorithm通过迭代器进行操作，不知道容器的内部结构，所以无法进行真正的删除
vector迭代器失效的情况
    当插入一个元素到vector中，由于引起了内存重新分配，所以指向原内存的迭代器全部失效。
    当删除容器中一个元素后,该迭代器所指向的元素已经被删除，那么也造成迭代器失效。
    erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要it=vec.erase(it);。
正确释放vector的内存(clear(), swap(), shrink_to_fit())
    vec.clear()：清空内容，但是不释放内存。
    vector<int>().swap(vec)：清空内容，且释放内存，想得到一个全新的vector。
    vec.shrink_to_fit()：请求容器降低其capacity和size匹配。
    vec.clear();vec.shrink_to_fit();：清空内容，且释放内存。

什么情况下用vector，什么情况下用list，什么情况下用deque
    vector:可以随机存储元素（即可以通过公式直接计算出元素地址，而不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数量变化不大，
        随机访问频繁。除非必要，我们尽可能选择使用vector而非deque，因为deque的迭代器比vector迭代器复杂很多。
    list:不支持随机存储，适用于对象大，对象数量变化频繁，插入和删除频繁，比如写多读少的场景。
    deque: 需要从首尾两端进行插入或删除操作的时候需要选择deque。
    priority_queue：优先队列，其底层是用堆来实现的。在优先队列中，队首元素一定是当前队列中优先级最高的那一个。

为何map和set的插入删除效率比其他序列容器高
    因为不需要内存拷贝和内存移动

为何map和set每次Insert之后，以前保存的iterator不会失效？
    因为插入操作只是结点指针换来换去，结点内存没有改变。而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。

map 、set、multiset、multimap的特点
    set和multiset会根据特定的排序准则自动将元素排序，set中元素不允许重复，multiset可以重复。
    map和multimap将key和value组成的pair作为元素，根据key的排序准则自动将元素排序（因为红黑树也是二叉搜索树，所以map默认是按key排序的），
        map中元素的key不允许重复，multimap可以重复。
    map和set的增删改查速度为都是logn，是比较高效的。
为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的iterator不会失效？
    存储的是结点，不需要内存拷贝和内存移动。
    插入操作只是结点指针换来换去，结点内存没有改变。
    而iterator就像指向结点的指针，内存没变，指向内存的指针也不会变。

hash_map与map的区别？什么时候用hash_map，什么时候用map？ 
    构造函数：hash_map需要hash function和等于函数，而map需要比较函数（大于或小于）。
    存储结构：hash_map以hashtable为底层，而map以RB-TREE为底层。
    总的说来，hash_map查找速度比map快，而且查找速度基本和数据量大小无关，属于常数级别。
    而map的查找速度是logn级别。但不一定常数就比log小，而且hash_map还有hash function耗时。
    如果考虑效率，特别当元素达到一定数量级时，用hash_map。
    考虑内存，或者元素数量较少时，用map。

线程不安全的情况:
    在对同一个容器进行多线程的读写、写操作时；
    在每次调用容器的成员函数期间都要锁定该容器；
    在每个容器返回的迭代器（例如通过调用begin或end）的生存期之内都要锁定该容器；
    在每个在容器上调用的算法执行期间锁定该容器。
```
stl

|容器|底层数据结构|时间复杂度|有无序|是否可重复|
|----|-----------|---------|-----|---------|
|array|数组|随机读改O(1)|无序|可重复|
|vector|数组|随机读改,尾部插入，尾部删除O(1)头部插入、头部删除O(n)|无序|可重复|
|dequeue|双端队列|头尾插入、头尾删除O(1)|无序|可重复|
|forward_list|单向链表|插入删除O(1)|无序|可重复|
|list|双向链表|插入删除O(1)|无序|可重复|
|stack|deque/list|顶部插入、顶部删除O(1)|无序|可重复|
|queue|deque/list|尾部插入、头部删除O(1)|无序|可重复|
|priority_quue|vector/max-heap|插入、删除O(logn)|有序|可重复|
|set|红黑树|插入、删除、查找O(logn)|有序|不可重复|

### 编程基础
33. strcat,strcpy,strncpy,memset,memcpy的内部实现？
```
c++11标准增加了全局函数std::to_string可以使用std::stoi/stol/stoll等等函数strcpy拥有返回值，有时候函数原本不需要返回值，但为了增加灵活性如支持链式表达，
```
22. 手写strcpy
```
    char strcpy(char dst, const char src)
    {
    assert(dst);
    assert(src);
    char ret = dst;
    while((dst++ = src++) != '\0');
    return ret;
    }
    //该函数是没有考虑重叠的
    char strcpy(char dst, const char src)
    {
    assert((dst != NULL) && (src != NULL));
    char ret = dst;
    int size = strlen(src) + 1;
    if(dst > src || dst < src + len)
    {
    dst = dst + size - 1;
    src = src + size - 1;
    while(size--)
    {
    dst-- = src--;
    }
    }
    else
    {
    while(size--)
    {
    dst++ = src++;
    }
    }
    return ret;
    }
```


22. 手写memcpy函数
```
void memcpy(void dst, const void src, size_t size)
{
if(dst == NULL || src == NULL)
{
return NULL;
}
void res = dst;
char pdst = (char)dst;
char psrc = (char)src;
if(pdst > psrc && pdst < psrc + size) //重叠

{

pdst = pdst + size - 1;

psrc = pdst + size - 1;

while(size--)

{

*pdst-- = *psrc--;

}

}

else //无重叠

{

while(size--)

{

*dst++ = *src++;

}

}

return ret;

}

```

23. 手写strcat函数
```
char strcat(char dst, const char src)
{
char ret = dst;



while(*dst != '\0')

++dst;



while((*dst++ = *src) != '\0');

return ret;

}
```


24. 手写strcmp函数
```
int strcmp(const char str1, const char str2)
{



while(*str1 == *str2 && *str1 != '\0')

{

++str1;

++str2;

}

return *str1 - *str2;

}
```
- 判断大小端
```
union un
{
int i;
char ch;
};

void fun()
{
union un test;
test.i = 1;
if(ch == 1)
cout << "小端" << endl;
else
cout << "大端" << endl;
}
```
设计模式
单例模式线程安全的写法
STL里的迭代器使用了迭代器模式
1. 有序  查找  如果包含这两个关键字首先要想到的时二分查找法
2. 字符串替换，顺序调整 可以考虑逆序复制
3. 反转字符串 可以考虑先把每个单词逆序,然后整个字符串逆序  负负得正



26.二叉树
```

递归是解决二叉树相关问题的神级方法；
树的各种常见算法题(http://blog.csdn.net/xiajun07061225/article/details/12760493)；
```

27. Trie树(字典树)]
```
每个节点保存一个字符
根节点不保存字符
每个节点最多有n个子节点(n是所有可能出现字符的个数)
查询的复杂父为O(k)，k为查询字符串长度
```

28. 链表
```
链表和插入和删除，单向和双向链表都要会
链表的问题考虑多个指针和递归

```




******************
# 网络与TCP/IP
- [TCP与UDP之间的区别](http://blog.csdn.net/shanghairuoxiao/article/details/68927070)

#### 安全相关



****************
- SQL语言(内外连接，子查询，分组，聚集，嵌套，逻辑)

-





### TCP网络



# Linux



********


### 多线程
### [**死锁**](http://blog.csdn.net/shanghairuoxiao/article/details/70444940)

哈希表的桶个数为什么是质数，合数有何不妥？
3. enable_share_from_this 是做什么的，请举一个场景说明？
```
然后就开始聊多线程编程模式、线程安全等问题。
我觉得这个问题是一个很好的问题，从语言出发，扩展到工程经验和对编程的理解。
而且弱指针确实是c++非常有特色的一个特性
```

 ++i是否是原子操作
明显不是，++i主要有三个步骤，把数据从内存放在寄存器上，在寄存器上进行自增，把数据从寄存器拷贝会内存，每个步骤都可能被中断。


熟悉一下一些算不上多线程设计模式的小技巧，比如传递只读对象可以避免加锁，或者Copy传递以防外部修改之类的（讨论环节被问过）。
另外值得特别一提的一个小细节是，，值得一看（只被问过一次，不过我答挂了，所以印象及其深）。还有可能会问的是一些有趣的小场景让你实现一些功能需要线程安全


### Redis
redis 的网络通信模型、redis 各种数据结构的实现

```
1.Redis 是一个基于内存的高性能key-value数据库。
2.Redis相比memcached有哪些优势：

memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型redis的速度比memcached快很多redis可以持久化其数据
3.Redis是单线程redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销
4.Reids常用5种数据类型string，list，set，sorted set，hash
6.Reids6种淘汰策略：
    noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。大多数写命令都会导致占用更多的内存(有极少数会例外。**allkeys-lru:**所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。
    **volatile-lru:**只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。
    **allkeys-random:**所有key通用; 随机删除一部分 key。volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。
    volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。
```    

7. Redis的并发竞争问题如何解决?
```
单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，利用setnx实现锁。
8.Redis是使用c语言开发的。
```
9.Redis前端启动命令./redis-server
10.Reids支持的语言：java、C、C#、C++、php、Node.js、Go等。
11.Redis 持久化方案：
Rdb 和 Aof

12.Redis 的主从复制持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，

13.Redis是单线程的，但Redis为什么这么快？
1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
4、使用多路I/O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程
5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；
14.为什么Redis是单线程的？
Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。

15.Redis info查看命令：info memory

16.Redis内存模型
    used_memory：Redis分配器分配的内存总量（单位是字节），包括使用的虚拟内存（即swap）；Redis分配器后面会介绍。
    used_memory_human只是显示更友好。
    used_memory_rss**：**Redis进程占据操作系统的内存（单位是字节），与top及ps命令看到的值是一致的；除了分配器分配的内存之外，
    used_memory_rss还包括进程运行本身需要的内存、内存碎片等，但是不包括虚拟内存。
    mem_fragmentation_ratio**：**内存碎片比率，该值是used_memory_rss / used_memory的比值。
    mem_allocator**：**Redis使用的内存分配器，在编译时指定；可以是 libc 、jemalloc或者tcmalloc，默认是jemalloc；截图中使用的便是默认的jemalloc。

17.Redis内存划分数据
    作为数据库，数据是最主要的部分；这部分占用的内存会统计在used_memory中。
    进程本身运行需要的内存Redis主进程本身运行肯定需要占用内存，如代码、常量池等等；
    这部分内存大约几兆，在大多数生产环境中与Redis数据占用的内存相比可以忽略。
    这部分内存不是由jemalloc分配，因此不会统计在used_memory中。缓冲内存缓冲内存包括客户端缓冲区、复制积压缓冲区、AOF缓冲区等；
    其中，客户端缓冲存储客户端连接的输入输出缓冲；复制积压缓冲用于部分复制功能；
    AOF缓冲区用于在进行AOF重写时，保存最近的写入命令。在了解相应功能之前，不需要知道这些缓冲的细节；这部分内存由jemalloc分配，因此会统计在used_memory中。内存碎片内存碎片是Redis在分配、回收物理内存过程中产生的。例如，如果对数据的更改频繁，而且数据之间的大小相差很大，可能导致redis释放的空间在物理内存中并没有释放，但redis又无法有效利用，这就形成了内存碎片。内存碎片不会统计在used_memory中。18.Redis对象有5种类型无论是哪种类型，Redis都不会直接存储，而是通过redisObject对象进行存储。
19.Redis没有直接使用C字符串(即以空字符’\0’结尾的字符数组)作为默认的字符串表示，而是使用了SDS。SDS是简单动态字符串(Simple Dynamic String)的缩写。
20.Reidis的SDS在C字符串的基础上加入了free和len字段
21.Reids主从复制复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。
22.Redis哨兵在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。
23.Reids持久化触发条件RDB持久化的触发分为手动触发和自动触发两种。
24.Redis 开启AOFRedis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：appendonly yes
25.AOF常用配置总结下面是AOF常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。
    appendonly no：是否开启
    AOFappendfilename "appendonly.aof"：AOF文件名
    dir ./：RDB文件和AOF文件所在目录
    appendfsync everysec：fsync持久化策略
    no-appendfsync-on-rewrite no：AOF重写期间是否禁止
    fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡
    auto-aof-rewrite-percentage 100：文件重写触发条件之一
    auto-aof-rewrite-min-size 64mb：文件重写触发提交之一
    aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件
26.RDB和AOF的优缺点
    RDB持久化优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。
        缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。
    AOF持久化与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。
27.持久化策略选择
    （1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。
    （2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。
    （3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。

28.redis缓存被击穿处理机制使用mutex。简单地来说，就是在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法

29.Redis还提供的高级工具像慢查询分析、性能测试、Pipeline、事务、Lua自定义命令、Bitmaps、HyperLogLog、发布/订阅、Geo等个性化功能。

30.Redis常用管理命令
```
# dbsize 返回当前数据库 key 的数量。
# info 返回当前 redis 服务器状态和一些统计信息。
# monitor 实时监听并返回redis服务器接收到的所有请求信息。
# shutdown 把数据同步保存到磁盘上，并关闭redis服务。
# config get parameter 获取一个 redis 配置参数信息。（个别参数可能无法获取）
# config set parameter value 设置一个 redis 配置参数信息。（个别参数可能无法获取）
# config resetstat 重置 info 命令的统计信息。（重置包括：keyspace 命中数、
# keyspace 错误数、 处理命令数，接收连接数、过期 key 数）
# debug object key 获取一个 key 的调试信息。
# debug segfault 制造一次服务器当机。
# flushdb 删除当前数据库中所有 key,此方法不会失败。小心慎用
# flushall 删除全部数据库中所有 key，此方法不会失败。小心慎用
```

31.Reids工具命令
```
#redis-server：Redis 服务器的 daemon 启动程序
#redis-cli：Redis 命令行操作工具。当然，你也可以用 telnet 根据其纯文本协议来操作
#redis-benchmark：Redis 性能测试工具，测试 Redis 在你的系统及你的配置下的读写性能
$redis-benchmark -n 100000 –c 50
#模拟同时由 50 个客户端发送 100000 个 SETs/GETs 查询
#redis-check-aof：更新日志检查
#redis-check-dump：本地数据库检查
```

32.为什么需要持久化？
```
由于Redis是一种内存型数据库，即服务器在运行时，系统为其分配了一部分内存存储数据，一旦服务器挂了，或者突然宕机了，那么数据库里面的数据将会丢失，为了使服务器即使突然关机也能保存数据，必须通过持久化的方式将数据从内存保存到磁盘中。33.判断key是否存在exists key +key名字
```

34.删除keydel key1 key2 ...

35.缓存和数据库间数据一致性问题分布式环境下（单机就不用说了）

非常容易出现缓存和数据库间的数据一致性问题，针对这一点的话，只能说，如果你的项目对缓存的要求是强一致性的，那么请不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括 合适的缓存更新策略，更新数据库后要及时更新缓存、缓存失败时增加重试机制，例如MQ模式的消息队列。

36.布隆过滤器bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小

37.缓存雪崩问题存在同一时间内大量键过期（失效），接着来的一大波请求瞬间都落在了数据库中导致连接异常。
```
    解决方案：1、也是像解决缓存穿透一样加锁排队。
                2、建立备份缓存，缓存A和缓存B，A设置超时时间，B不设值超时时间，先从A读缓存，A没有读B，并且更新A缓存和B缓存;
```

38.缓存并发问题
    这里的并发指的是多个redis的client同时set key引起的并发问题。比较有效的解决方案就是把redis.set操作放在队列中使其串行化，必须的一个一个执行，具体的代码就不上了，当然加锁也是可以的，至于为什么不用redis中的事务，留给各位看官自己思考探究。
39.Redis分布式redis支持主从的模式。
    原则：Master会将数据同步到slave，而slave不会将数据同步到master。Slave启动时会连接master来同步数据。这是一个典型的分布式读写分离模型。
    我们可以利用master来插入数据，slave提供检索服务。这样可以有效减少单个机器的并发访问数量
40.读写分离模型通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。

41.数据分片模型为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。可以将每个节点看成都是独立的master，然后通过业务实现数据分片。结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。

42. redis常见性能问题和解决方案：
```
    Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内尽量避免在压力很大的主库上增加从库
```
43. redis通讯协议RESP 是redis客户端和服务端之前使用的一种通讯协议；
```
    RESP 的特点：实现简单、快速解析、可读性好
```
44. Redis分布式锁实现先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。

请你来说一说Redis的定时机制怎么实现的
```
Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：
文件事件（服务器对套接字操作的抽象）和时间事件（服务器对定时操作的抽象）。Redis的定时机制就是借助时间事件实现的。
一个时间事件主要由以下三个属性组成：
id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。
一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件
一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件。
```
请你来说一说Redis是单线程的，但是为什么这么高效呢?
```
1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4、使用多路I/O复用模型，非阻塞IO；

5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；
```
请问Redis的数据类型有哪些，底层怎么实现?
```

```
请问Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash又是怎么实现的?
请你来说一下Redis和memd的区别
请问Redis怎么实现的定期删除功能
请你说一说Redis对应的命令和数据类型...

```
Redis

1、Nosql 非关系型数据库，key-value键值对存贮。

2、内存型数据库，支持持久化，可将数据保存在硬盘上。

3、单线程处理请求，但采用io多路复用技术。

4、读写性能好，支持集群。

 

Redis数据类型

1、String 类型：最基础的数据类型，简单的key-value键值对，value可以是任何数据，不限制类型，但大小最多不能超过512M。

2、list 类型：列表类型，类似一个队列，左侧为表头，右侧为表尾，左右两侧都可以插入数据；底层实现为链表。

3、set 类型：无序集合类型，key-values 集合，values内部的元素不重复。

4、zset 类型：有序集合类型，数据结构类似于java中的Map<String，List<Object>>，key-values结构，values内部元素有序。

5、hash 类型：hash表结构，类似于java中的Map<String,Map<String,Object>>。

 

Redis持久化方式

1、RDB持久化：快照snapshot持久化方式，把当前内存中的数据集快照写入硬盘，恢复数据时直接读取硬盘上的快照文件。

2、AOF持久化：通过记录redis服务器所执行的写命令日志进行持久化，恢复数据是，执行保存的写命令进行数据恢复。

 

Redis过期删除策略

1、redis存入数据时可以设置过期时间，如果不设置，则永不过期；

2、redis到期删除策略是定期随机抽样+惰性删除。

 

Redis内存淘汰机制

1、no-enviction：禁止淘汰数据，内存不足则报错。

2、allkeys-random：从内存数据集中随机淘汰数据。

3、allkey-lru：从内存数据集中淘汰最近最少使用数据（最常用）。

4、volatile-random：从设置过过期时间的数据集中随机淘汰数据，未设置过期时间的数据不受影响。

5、volatile-lru：从设置过过期时间的数据集中淘汰最近最少使用数据。

6、volatile-ttl：从设置过过期时间的数据集中淘汰将要过期的数据。

1、Redis的数据结构
Redis 的底层数据结构包含简单的动态字符串（SDS）、链表、字典、压缩列表、整数集合等等；五大数据类型（数据对象）都是由一种或几种数结构构成。

在命令行中可以使用 OBJECT ENCODING key 来查看key的数据结构。

2、简单动态字符串SDS
 redis是使用C语言编写的，但是string数据类型并没有使用C语言的字符串，而是重新编写一个简单的动态字符串（simple dynamic string,SDS）。

复制代码
 1 /*
 2   * 保存字符串对象的结构
 3   */
 4 struct sdshdr {
 5   
 6     // buf 中已占用空间的长度
 7     int len;
 8   
 9     // buf 中剩余可用空间的长度
10     int free;
11  
12     // 数据空间
13     char buf[]
14 };
复制代码
 

使用SDS保存字符串Redis，具体表示如下：



                                              图片来自《Redis设计与实现》 黄健宏著

 

free 表示buf数组中剩余的空间数量
len 记录了buf数组中已存储的字节长度
buf 数组是一个char类型的数据，记录具体存储的字符串，并且以 ‘\0’(空字符) 作为结束标识符
 SDS定义较C语言的字符串几乎相同，就是多出两个属性free，len；那为何不直接使用C语言的字符串呢？

1、获取字符串长度复杂度为O(1)

        由于C语言没有存储字符串长度，每次获取字符串长度多需要进行循环整个字符串计算，时间复杂度为O(N)；而SDS记录了存储的字符串的长度，获取字符串长度时直接获取len的属性值即可，时间复杂度为O(1)；而SDS中设置和更新长度是API中自动完成，无需手动进行操作。

2、杜绝缓冲区溢出

 C语言在进行两个字符串拼接时，一旦没有分配足够的内存空间，就会造成溢出；而SDS在修改字符串时，会先根据len的值，检查内存空间是否足够，如果不足会先分配内存空间，再进行字符串修改，这样就杜绝了缓冲区溢出。

3、减少修改字符串时带来的内存重新分配次数

C语言不记录字符串长度，所以当修改时，会重新分配内存；如果是正常字符串，内存空间不够会产生溢出；如果是缩短字符串，不重重分配会产生泄露。

SDS采用空间预分配和惰性释放空间两种优化策略

空间预分配：对字符串进行增长操作，会分配出多余的未使用空间，这样如果以后的扩展，在一定程度上可以减少内存重新分配的次数。

惰性释放空间：对字符串经过缩短操作，并不会立即释放这些空间，而是使用free来记录这些空间的数量，当进行增长操作时，这些记录的空间就可以被重新利用；SDS提供了响应的API进行手动释放空间，所以不会造成内存浪费。

4、二进制安全

C语言的字符串中不能包含空字符（因为C语言是以空字符判断字符串结尾的），所以不能保存一些二进制文件（有可能包含空字符，如图片）；SDS则是以len来判断字符串结尾，所以SDS结构可以存储图片等，并且都是以二进制方式进行处理。

5、兼容部分C字符串函数

SDS结构中buf保存字符串同样是以空字符结尾，所以可以兼容C语言的部分字符串操作API。

总结：



                                             表来源：《Redis设计与实现》

 

3、链表
Redis使用C语言编写，但并没有内置链表这种数据结构，而是自己构建了链表的实现；构成链表结构的节点为链表节点。

链表用的非常广泛，如列表键、发布与订阅、慢查询、监视器等。

复制代码
1 typedef struct listNode {
2     // 前置节点
3     struct listNode * prev;
4     // 后置节点
5     struct listNode * next;
6     // 节点的值
7     void * value;
8 }listNode;
复制代码
多个listNode可以通过prev和next指针构成双端链表，使用list持有链表

复制代码
 1 typedef struct list {
 2     // 表头节点
 3     listNode * head;
 4     // 表尾节点
 5     listNode * tail;
 6     // 链表所包含的节点数量
 7     unsigned long len;
 8     // 节点值复制函数
 9     void *(*dup)(void *ptr);
10     // 节点值释放函数
11     void (*free)(void *ptr);
12     // 节点值对比函数
13     int (*match)(void *ptr,void *key);
14 } list;
复制代码
head 表头指针
tail 表尾指针
len 链表长度计数器
dup、free、match 多态链表所需的类型特定的函数


Redis链表实现的特性如下：

1、双端

链表节点带有prev和next指针，可以快速获取前置和后置节点，时间复杂度都是O(1)。

2、无环

 头节点prev指针和尾节点next指针都指向null，对链表访问以NULL为终点。

3、带表头指针和表尾指针

可以快速的获取表头节点和表尾节点。

4、有链表长度计数器

可以快速获取链表长度。 

5、多态

链表可以保存各种不同类型的值，通过list的dup，free，match三个属性为节点设计值类型特定的函数。

 

4、字典
字典又称为符号表（symbol table）、关联数组（associative array）或者映射（map）；字典中存储key-value键值对，并且key不重复；

字典在Redis中广泛应用，如Redis数据库就是使用字典作为底层实现的。

Redis使用的C语言没有内置这种结构，所以Redis构建了自己的字典实现。

字典使用哈希表作为底层试下，一个哈希表包含多个哈希节点，每个哈希节点保存一个键值对。

哈希表

复制代码
 1 typedef struct dictht {
 2     // 哈希表数组
 3     dictEntry **table;
 4     // 哈希表大小
 5     unsigned long size;
 6     // 哈希表大小掩码，用于计算索引值
 7     // 总是等于size-1
 8     unsigned long sizemask;
 9     // 该哈希表已有节点的数量
10     unsigned long used;
11 } dictht;
复制代码


图中是一个大小为4的空哈希表

table是一个数组，数组元素是dictEntry结构的指针，每个dictEntry保存一个键值对
size 记录哈希表的大小
sizemask 值总是等于size-1，这个属性和哈希值一起决定一个键应该被方法table数组的哪个索引上
used 记录哈希表目前已有节点的数量
哈希表节点 

复制代码
 1 typedef struct dictEntry {
 2     // 键
 3     void *key;
 4     // 值
 5     union{
 6         void *val;
 7         uint64_tu64;
 8         int64_ts64;
 9     } v;
10     // 指向下个哈希表节点，形成链表
11     struct dictEntry *next;
12 } dictEntry;
复制代码
key属性保存着键值对中的键，v属性保存着键值对中的值
键值对中的值可以使指针val、一个uint64_t整数，或是一个int64_t整数
next是指向另一个哈希表节点的指针，用以解决多个哈希值冲突问题
下图为将两个索引值相同的键连在一起



 

字典结构

复制代码
 1 typedef struct dict {
 2     // 类型特定函数
 3     dictType *type;
 4     // 私有数据
 5     void *privdata;
 6     // 哈希表
 7     dictht ht[2];
 8     // rehash索引
 9     //当rehash不在进行时，值为-1
10     in trehashidx; /* rehashing not in progress if rehashidx == -1 */
11 } dict;
12 
13 typedef struct dictType {
14     // 计算哈希值的函数
15     unsigned int (*hashFunction)(const void *key);
16     // 复制键的函数
17     void *(*keyDup)(void *privdata, const void *key);
18     // 复制值的函数
19     void *(*valDup)(void *privdata, const void *obj);
20     // 对比键的函数
21     int (*keyCompare)(void *privdata, const void *key1, const void *key2);
22     // 销毁键的函数
23     void (*keyDestructor)(void *privdata, void *key);
24     // 销毁值的函数
25     void (*valDestructor)(void *privdata, void *obj);
26 } dictType;
复制代码
type 属性是一个指向dictType结构的指针，每个dictType机构保存了一簇用于操作特定类型键值对的函数，Redis货位用途不同的字典设置不同的类型特定函数。
privdata 属性保存了需要传给那些类型特定函数的可选参数。
ht 属性是一个长度为2的数组，数组中的每个元素都是一个哈希表，一般情况下自字典只使用ht[0]，ht[1]只会在进行rehash时使用.
trehashidx 属性记录了rehash目前的进度，如果没有进行rehash则它的值为-1。
下图为普通状态下的字典结构



当一个新的键值对要添加到字典中去时，会涉及到一系列的操作，如计算索引、解决冲突、扩容等等，下面对这些操作进行描述。

1、哈希算法

添加键值对时，首先要根据键值对的键计算出哈希值和索引值，然后再根据索引值进行放入

1 #使用字典设置的哈希函数，计算键key的哈希值
2 hash = dict->type->hashFunction(key);
3 #使用哈希表的sizemask属性和哈希值，计算出索引值
4 #根据情况不同，ht[x]可以是ht[0]或者ht[1]
5 index = hash & dict->ht[x].sizemask;
2、结局键冲突

当有两个或以上数量的键值被分配到了哈希表数组的同一个索引上时，就发生了键冲突。

Redis的哈希表使用单向链表解决键冲突问题，每个新的键总是添加到单项链表的表头。

3、rehash（扩展或收缩）

哈希表具有负载因子（load factor），其始终需要保持在一个合理的范围之内，当hashI表保存的键值对过多或过少时，就需要对哈希表进行rehash（重新散列）操作，步骤许下

(1) 为字典的ht[1]分配空间，空间大小：如果是扩展操作则为ht[0].used * 2 ，也就是扩展为当前哈希表已使用空间的1倍；如果是收缩，则减小1倍。

(2) 将ht[0]内的数据重新计算哈希值和索引，并放到新分配的ht[1]空间上。

(3) 全部迁移完成后，将ht[1]设置为ht[0]，释放ht[0]并创建一个空白的哈希表为ht[1]，为下次rehash做准备。

4、哈希表的扩展与收缩触发条件

(1) 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等等于1。

(2) 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。

以上条件中任意一条被满足，程序自动开始对哈希表进行扩展；

负载因子算法：负载因子 = 哈希表以保存的节点数量 / 哈希表大小

当负载因子小于0.1时，程序自动进行收缩操作。

5、渐进式rehash

渐进式rehash就是，当ht[1]的键值对向ht[1]迁移的过程中，如果数据量过大，则不能一次性迁移， 否则会对服务器性能造成影响，而是分成多次，渐进式的进行迁移。

在rehash期间，会维持一个索引计数器rehashidx，并把每次的迁移工作分配到了添加、删除、查找、更新操作中，当rehash工作完成后rehashidx会增加1，这样所有的ht[0]的值全部迁移完成后，程序会将rehashidx这是为-1，标识最终的rehash完成。

6、渐进式rehash之情期间的表操作

由于渐进式rehash期间，ht[0]和ht[1]中都有数据，当查找时，会先在ht[0]中进行，没找到继续到ht[1]中找；而添加操作一律会添加到ht[1]中。

 

字典总结： 

Redis字典底层机构实现与java(1.6之前) 中的hashmap非常相像，都是使用单项链表解决键冲突问题。

个人疑问：jdk1.8以上已经是用红黑树解决多个键冲突问题，不知redis的键冲突是否也可以用红黑树？

 

5、跳跃表
跳跃表（skiplist）数据结构特点是每个节点中有多个指向其他节点的指针，从而快速访问节点。

跳跃表结构由跳跃表节点（zskiplistNode）和zskiplist两个结构组成

跳跃表节点

复制代码
 1 typedef struct zskiplistNode {
 2     // 层
 3     struct zskiplistLevel {
 4         // 前进指针
 5         struct zskiplistNode *forward;
 6         // 跨度
 7         unsigned int span;
 8     } level[];
 9     // 后退指针
10     struct zskiplistNode *backward;
11     // 分值
12     double score;
13     // 成员对象
14     robj *obj;
15 } zskiplistNode;
复制代码
层：为一个数组，数组中的每个数据都包含前进指针和跨度。
前进指针：指向表尾方向的其他节点的指针，用于从表头方向到表尾方向快速访问节点。
跨度：记录两个节点之间的距离，跨度越大，两个节点相聚越远，所有指向NULL的前进指针的跨度都为0。
后退指针：用于从表尾节点向表头节点访问，每个节点都有后退指针，并且每次只能后退一个节点。
分值：节点的分值是一个double类型的浮点数，跳跃表中的说有分值按从小到大排列。
成员对象：是一个指向字符串的指针，字符串则保存着一个SDS值。
跳跃表

复制代码
1 typedef struct zskiplist {
2     // 表头节点和表尾节点
3     structz skiplistNode *header, *tail;
4     // 表中节点的数量
5     unsigned long length;
6     // 表中层数最大的节点的层数
7     int level;
8 } zskiplist;
复制代码


header 指向跳跃表的表头节点，tail指向跳跃表的表尾节点，level记录节点中的最大层数（不含表头节点），length跳跃表包含节点数量（不含表头节点）。
跳跃表由很多层构成（L1、L2 ...），每个层都带有两个属性前进指针和跨度。
每个节点都包含成员对象（obj）、分值（score）、后退指针（backward），头结点也包含这些属性但不会被用到
在此处只是介绍跳跃表的结构相关，关于跳跃表的层的形成，对象的插入、删除、查询等操作的原理在此处不做详解，另外会有文章进行说明。

 

6、整数集合
整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数元素，并且元素的个数不多时，Redis就会使用整数集合作为集合键的底层实现。

整数集合可以保存int16_t、int32_t、int64_t的整数值，并且不会出现重复元素

复制代码
1 typedef struct intset {
2     // 编码方式
3     uint32_t encoding;
4     // 集合包含的元素数量
5     uint32_t length;
6     // 保存元素的数组
7     int8_t contents[];
8 } intset;
复制代码
contents数组存储的是集合中的每个元素，他的类型是int8_t，但存储数据的实际类型取决于编码方式encoding
encoding编码方式有三种INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64分别对应的是int16_t、int32_t、int64_t类型
length记录整数集合的元素数量，即contents数组的长度
整数集合的升级操作

整数集合中原来保存的是小类型（如：int16_t）的整数，当插入比其类型大（如：int_64_t）的整数时，会把整合集合里的元素的数据类型都转换成大的类型，这个过程称为升级

升级整数集合并添加新元素步骤如下：

（1）根据新元素的类型，扩展整数集合的底层数据的空间大小，并为新元素分配空间。

（2）将现有的所有元素的类型转换成与新元素相同的类型，保持原有数据有序性不变的情况下，把转换后的元素放在正确的位置上。

（3）将新元素添加到数组里。

新元素引发升级，所以新元素要么比所有元素都大，要么比所有元素都小。

当小于所有元素时，新元素放在底层数组的最开头
当大于所有元素时，新元素放在底层数据的最末尾
升级操作的好处

提升整数的灵活性，可以任意的向集合中放入3中不同类型的整数，而不用担心类型错误。
节约内存，整数集合中只有大类型出现的时候才会进行升级操作。
整数集合不支持降级操作

 

7、压缩列表
压缩列表（ziplist）是Redis为了节约内存而开发，是一系列特殊编码的连续内存块组成的顺序型数据结构。

一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。

下图为压缩列表的结构





每个压缩列表含有若干个节点，而每个节点都由三部分构成，previous_entry_length、encoding、content，如图：

 

previous_entry_length 存储的是前一个节点的长度，由于压缩列表内存块连续，使用此属性值可以计算前一个节点的地址，压缩列表就是使用这一原理进行遍历。
previous_entry_length 如果前一节点长度小于254字节，那么previous_entry_length属性本身长度为1字节，存储的指就是前一节点的长度；如果大于254个字节，那么previous_entry_length属性本身长度为5个字节，前一个字节为0xFE(十进制254)，之后四个字节存储前一节点的长度。
encoding 记录本节点的content属性所保存数据的类型及长度，其本身长度为一字节、两字节或五字节，值得最高位为00、01或10的是字节数组的编码，最高位以11开头的是整数编码。
content 保存节点的值，可以是一个字节数组或者整数。
连锁更新

当对压缩列表进行添加节点或删除节点时有可能会引发连锁更新，由于每个节点的 previous_entry_length 存在两种长度1字节或5字节，当所有节点previous_entry_length都为1个字节时，有新节点的长度大于254个字节，那么新的节点的后一个节点的previous_entry_length原来为1个字节，无法保存新节点的长度，这是就需要进行空间扩展previous_entry_length属性由原来的1个字节增加4个字节变为5个字节，如果增加后原节点的长度超过了254个字节则后续节点也要空间扩展，以此类推，最极端的情况是一直扩展到最后一个节点完成；这种现象称为连锁更新。在日常应用中全部连锁更新的情况属于非常极端的，不常出现。

 

8、总结
Redis的底层数据结构共有六种，简单动态字符串（SDS）、链表、字典、跳跃表、整数集合、压缩列表。

Redis中的五大数据类型的底层就是由他们中的一种或几种实现，数据的存储结构最终也会落到他们上。

可是在redis命令下使用 OBJECT ENCODING 命令查看键值对象的编码方式，也就是是以哪种结构进行的底层编码。

 1、简介
Redis的五大数据类型也称五大数据对象；前面介绍过6大数据结构，Redis并没有直接使用这些结构来实现键值对数据库，而是使用这些结构构建了一个对象系统redisObject；这个对象系统包含了五大数据对象，字符串对象（string）、列表对象（list）、哈希对象（hash）、集合（set）对象和有序集合对象（zset）；而这五大对象的底层数据编码可以用命令OBJECT ENCODING来进行查看。

redisObject结构

复制代码
1 typedef struct redisObject {
2     // 类型
3     unsigned type:4;
4     // 编码
5     unsigned encoding:4;
6     // 指向底层实现数据结构的指针
7     void *ptr;
8     // ...
9 } robj;
复制代码
redis是以键值对存储数据的，所以对象又分为键对象和值对象，即存储一个key-value键值对会创建两个对象，键对象和值对象。

键对象总是一个字符串对象，而值对象可以是五大对象中的任意一种。

type属性存储的是对象的类型，也就是我们说的 string、list、hash、set、zset中的一种，可以使用命令 TYPE key 来查看。
encoding属性记录了队形所使用的编码，即这个对象底层使用哪种数据结构实现。


表中列出了底层编码常量及对应的OBJECT ENCODING 命令的输出，前三项都是字符串结构

我们在存入key-value键值对时并不会指定对象的encoding，而是Redis会根据不统的使用场景来为一个对象设置不同的编码，可以达到节约内存、加快访问速度等目的。

 

2、字符串对象(string)
字符串对象底层数据结构实现为简单动态字符串（SDS）和直接存储，但其编码方式可以是int、raw或者embstr，区别在于内存结构的不同。

（1）int编码

字符串保存的是整数值，并且这个正式可以用long类型来表示，那么其就会直接保存在redisObject的ptr属性里，并将编码设置为int，如图：

 

（2）raw编码

 字符串保存的大于32字节的字符串值，则使用简单动态字符串（SDS）结构，并将编码设置为raw，此时内存结构与SDS结构一致，内存分配次数为两次，创建redisObject对象和sdshdr结构，如图：



（3）embstr编码

 字符串保存的小于等于32字节的字符串值，使用的也是简单的动态字符串（SDS结构），但是内存结构做了优化，用于保存顿消的字符串；内存分配也只需要一次就可完成，分配一块连续的空间即可，如图：

 

 字符串对象总结：

在Redis中，存储long、double类型的浮点数是先转换为字符串再进行存储的。
raw与embstr编码效果是相同的，不同在于内存分配与释放，raw两次，embstr一次。
embstr内存块连续，能更好的利用缓存在来的优势
int编码和embstr编码如果做追加字符串等操作，满足条件下会被转换为raw编码；embstr编码的对象是只读的，一旦修改会先转码到raw。
3、列表对象(list)
列表对象的编码可以是ziplist和linkedlist之一。

（1） ziplist编码

ziplist编码的哈希随想底层实现是压缩列表，每个压缩里列表节点保存了一个列表元素。



（2）linkedlist编码

linkedlist编码底层采用双端链表实现，每个双端链表节点都保存了一个字符串对象，在每个字符串对象内保存了一个列表元素。



列表对象编码转换：

列表对象使用ziplist编码需要满足两个条件：一是所有字符串长度都小于64字节，二是元素数量小于512，不满足任意一个都会使用linkedlist编码。
两个条件的数字可以在Redis的配置文件中修改，list-max-ziplist-value选项和list-max-ziplist-entries选项。
图中StringObject就是上一节讲到的字符串对象，字符串对象是唯一个在五大对象中作为嵌套对象使用的。
 

4、哈希对象(hash)
哈希对象的编码可以是ziplist和hashtable之一。

（1）ziplist编码

ziplist编码的哈希对象底层实现是压缩列表，在ziplist编码的哈希对象中，key-value键值对是以紧密相连的方式放入压缩链表的，先把key放入表尾，再放入value；键值对总是向表尾添加。



（2）hashtable编码

hashtable编码的哈希对象底层实现是字典，哈希对象中的每个key-value对都使用一个字典键值对来保存。

字典键值对即是，字典的键和值都是字符串对象，字典的键保存key-value的key，字典的值保存key-value的value。



哈希对象编码转换：

哈希对象使用ziplist编码需要满足两个条件：一是所有键值对的键和值的字符串长度都小于64字节；二是键值对数量小于512个；不满足任意一个都使用hashtable编码。
以上两个条件可以在Reids配置文件中修改hash-max-ziplist-value选项和hash-max-ziplist-entries选项。
 

5、集合对象(set)
集合对象的编码可以是intset和hashtable之一。

（1）intset编码

intset编码的集合对象底层实现是整数集合，所有元素都保存在整数集合中。



（2）hashtable编码

hashtable编码的集合对象底层实现是字典，字典的每个键都是一个字符串对象，保存一个集合元素，不同的是字典的值都是NULL；可以参考java中的hashset结构。



集合对象编码转换：

集合对象使用intset编码需要满足两个条件：一是所有元素都是整数值；二是元素个数小于等于512个；不满足任意一条都将使用hashtable编码。
以上第二个条件可以在Redis配置文件中修改et-max-intset-entries选项。
 

 6、有序集合对象(zset)
有序集合的编码可以是ziplist和skiplist之一。

（1）ziplist编码 

ziplist编码的有序集合对象底层实现是压缩列表，其结构与哈希对象类似，不同的是两个紧密相连的压缩列表节点，第一个保存元素的成员，第二个保存元素的分值，而且分值小的靠近表头，大的靠近表尾。



（2）skiplist编码

skiplist编码的有序集合对象底层实现是跳跃表和字典两种；

每个跳跃表节点都保存一个集合元素，并按分值从小到大排列；节点的object属性保存了元素的成员，score属性保存分值；

字典的每个键值对保存一个集合元素，字典的键保存元素的成员，字典的值保存分值。



为何skiplist编码要同时使用跳跃表和字典实现？

跳跃表优点是有序，但是查询分值复杂度为O(logn)；字典查询分值复杂度为O(1) ，但是无序，所以结合连个结构的有点进行实现。
虽然采用两个结构但是集合的元素成员和分值是共享的，两种结构通过指针指向同一地址，不会浪费内存。
有序集合编码转换：

有序集合对象使用ziplist编码需要满足两个条件：一是所有元素长度小于64字节；二是元素个数小于128个；不满足任意一条件将使用skiplist编码。
以上两个条件可以在Redis配置文件中修改zset-max-ziplist-entries选项和zset-max-ziplist-value选项。
 

7、总结
在Redis的五大数据对象中，string对象是唯一个可以被其他四种数据对象作为内嵌对象的；

列表（list）、哈希（hash）、集合（set）、有序集合（zset）底层实现都用到了压缩列表结构，并且使用压缩列表结构的条件都是在元素个数比较少、字节长度较短的情况下；

四种数据对象使用压缩列表的优点：

（1）节约内存，减少内存开销，Redis是内存型数据库，所以一定情况下减少内存开销是非常有必要的。

（2）减少内存碎片，压缩列表的内存块是连续的，并分配内存的次数一次即可。

（3）压缩列表的新增、删除、查找操作的平均时间复杂度是O(N)，在N再一定的范围内，这个时间几乎是可以忽略的，并且N的上限值是可以配置的。

（4）四种数据对象都有两种编码结构，灵活性增加。

 
2、RDB持久化
RDB持久化是最直接的持久化方式，直接将内存中的数据保存到RDB文件中，当恢复时也是直接从RDB文件中恢复；

                      

 

RDB文件是经过压缩的二进制文件，这里对文件结构不做详解。
RDB持久化可以手动执行，也可以设置定期执行。
RDB持久化命令有两个SAVE（同步）和BGSAVE（异步），同步持久化过程中，会拒绝客户端的所有请求；异步则是创建子进程执行，不会对客户端产生影响，具体可以看上一章的命令介绍。
自动间隔性保存

因为BGSAVE命令是异步执行，不会阻塞服务器，所以Redis允许用户自行配置SAVE选项，当选项触发时自动执行BGSAVE命令。 

当用户开启了触发自动BGSAVE后，如果不配置save选项，服务器会使用默认设置，如下：



　　（1）在900秒内，对数据库进行了至少1次修改。

（2）在300秒内，对数据库进行了至少10次修改。

（3）在60秒内，对数据库进行了至少10000次修改。

以上三个条件，满足任意一条，就会进行BGSAVE操作

3、AOF持久化
AOF持久化与RDB不同，AOF持久化是通过记录服务器所执行的命令来保存数据的。



被写入AOF文件的所有命令都是以Redis请求协议格式保存的。
数据的还原，就是通过读取AOF文件的这些命令进行的。
执行的命名并不是直接写入AOF文件的，而是先写入缓冲区，没执行一条命令就会追加到缓冲区的末尾，当一条命令执行完成后，返回数据前，会将缓冲区的数据写入到AOF文件中。
AOF文件的载入与还原

AOF持久化的数据还原过程就是读取AOF中命令重新执行命令的过程。

（1）Redis会创建一个伪客户端，伪客户端与真实的客户端执行命令的效果是一样的，只是不带网络连接。

（2）从AOF文件分析并读取一条命令。

（3）伪客户端执行这条命令。

（4）重复2和3过程，知道AOF文件中的所有命令处理完成。

AOF文件重写

AOF文件的持久化是记录被执行对的命令，这样随着时间越来越长，AOF文件中的内容会越来越多，体积也会越来越大，文件越大恢复数据的时间也越多。

在命令执行的过程中有些键值对被删除了，有些被修改了，而这些过程命令是完全没有必要再执行一遍的，所以Redis提供了AOF文件的重写功能对AOF进行重建，使用重建后的文件要比元AOF文件体积小很多。

AOF文件重写，并不需要对原AOF文件进行任何访问改动，他是通过对数据库内的数据读取来操作的，即查看数据库内有什么数据，然后根据数据类型进行创建这些数据的写入命令。
AOF文件重写过程中，创建写入命令时会先检查元素数量，如果数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD=64常量的值，就会分成多条命令，
AOF文件重写是有子进程进行的，并不影响主进程处理命令；子进程而不是线程，因为进程带有数据副本，不锁数据的情况下，能保证安全。
AOF文件子进程重写过程中，主进程仍然在处理数据，这样造成了子进程和主进程的数据不一致，子进程数据少了一部分，这种情况下Redis会创建一个AOF重写缓冲区；这样少的那部分命令会写到AOF重写缓冲区中，重写完成后，再把缓冲区这些命令写进新的AOF文件中，然后用新的AOF文件替换就得AOF文件。
4、总结
Redis初始化会创建一批数据库，每个数据库的内部数据结构都是字典，key-value的最终存储也会落到字典上。
AOF持久化比RDB持久化频率更高、速度更快；当有AOF持久化时，RDB持久化命令不会再执行；但当RDB持久化命令执行时，AOF命令会等待其执行完成后再执行，而其他RDB命令不会执行。
AOF文件重写过程不会影响旧的AOF文件，即便AOF重写过程失败，也不会干扰原来的AOF恢复数据，只有在成功之后才会替换原来的文件。
 

```
redies集群
```
Redis集群详解
Redis有三种集群模式，分别是：

* 主从模式

* Sentinel模式

* Cluster模式
1
2
3
4
5
三种集群模式各有特点，关于Redis介绍可以参考这里：NoSQL（二)——Redis

Redis官网：https://redis.io/ ，最新版本5.0.4

主从模式
主从模式介绍
主从模式是三种模式中最简单的，在主从复制中，数据库分为两类：主数据库(master)和从数据库(slave)。

其中主从复制有如下特点：

* 主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库

* 从数据库一般都是只读的，并且接收主数据库同步过来的数据

* 一个master可以拥有多个slave，但是一个slave只能对应一个master

* slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来

* master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务

* master挂了以后，不会在slave节点中重新选一个master
1
2
3
4
5
6
7
8
9
10
11
工作机制：

当slave启动后，主动向master发送SYNC命令。master接收到SYNC命令后在后台保存快照（RDB持久化）和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令。

复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。

安全设置：

当master节点设置密码后，

客户端访问master需要密码

启动slave需要密码，在配置文件中配置即可

客户端访问slave不需要密码
1
2
3
4
5
缺点：

从上面可以看出，master节点在主从模式中唯一，若master挂掉，则redis无法对外提供写服务。

主从模式搭建
环境准备：
master节点                  192.168.30.128

slave节点                   192.168.30.129

slave节点                   192.168.30.130
1
2
3
4
5
全部下载安装：
# cd /software

# wget http://download.redis.io/releases/redis-5.0.4.tar.gz

# tar zxf redis-5.0.4.tar.gz && mv redis-5.0.4/ /usr/local/redis

# cd /usr/local/redis && make && make install

# echo $?
0
1
2
3
4
5
6
7
8
9
10
全部配置成服务：
服务文件

# vim /usr/lib/systemd/system/redis.service

[Unit]
Description=Redis persistent key-value database
After=network.target
After=network-online.target
Wants=network-online.target

[Service]
ExecStart=/usr/local/bin/redis-server /usr/local/redis/redis.conf --supervised systemd
ExecStop=/usr/libexec/redis-shutdown
Type=notify
User=redis
Group=redis
RuntimeDirectory=redis
RuntimeDirectoryMode=0755

[Install]
WantedBy=multi-user.target
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
shutdown脚本

# vim /usr/libexec/redis-shutdown

#!/bin/bash
#
# Wrapper to close properly redis and sentinel
test x"$REDIS_DEBUG" != x && set -x

REDIS_CLI=/usr/local/bin/redis-cli

# Retrieve service name
SERVICE_NAME="$1"
if [ -z "$SERVICE_NAME" ]; then
   SERVICE_NAME=redis
fi

# Get the proper config file based on service name
CONFIG_FILE="/usr/local/redis/$SERVICE_NAME.conf"

# Use awk to retrieve host, port from config file
HOST=`awk '/^[[:blank:]]*bind/ { print $2 }' $CONFIG_FILE | tail -n1`
PORT=`awk '/^[[:blank:]]*port/ { print $2 }' $CONFIG_FILE | tail -n1`
PASS=`awk '/^[[:blank:]]*requirepass/ { print $2 }' $CONFIG_FILE | tail -n1`
SOCK=`awk '/^[[:blank:]]*unixsocket\s/ { print $2 }' $CONFIG_FILE | tail -n1`

# Just in case, use default host, port
HOST=${HOST:-127.0.0.1}
if [ "$SERVICE_NAME" = redis ]; then
    PORT=${PORT:-6379}
else
    PORT=${PORT:-26739}
fi

# Setup additional parameters
# e.g password-protected redis instances
[ -z "$PASS"  ] || ADDITIONAL_PARAMS="-a $PASS"

# shutdown the service properly
if [ -e "$SOCK" ] ; then
        $REDIS_CLI -s $SOCK $ADDITIONAL_PARAMS shutdown
else
        $REDIS_CLI -h $HOST -p $PORT $ADDITIONAL_PARAMS shutdown
fi
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
# chmod +x /usr/libexec/redis-shutdown

# useradd -s /sbin/nologin redis

# chown -R redis:redis /usr/local/redis

# chown -R reids:redis /data/redis

# yum install -y bash-completion && source /etc/profile                 #命令补全

# systemctl daemon-reload

# systemctl enable redis
1
2
3
4
5
6
7
8
9
10
11
12
13
修改配置：
192.168.30.128

# mkdir -p /data/redis

# vim /usr/local/redis/redis.conf

bind 192.168.30.128               #监听ip，多个ip用空格分隔
daemonize yes               #允许后台启动
logfile "/usr/local/redis/redis.log"                #日志路径
dir /data/redis                 #数据库备份文件存放目录
masterauth 123456               #slave连接master密码，master可省略
requirepass 123456              #设置master连接密码，slave可省略

appendonly yes                  #在/data/redis/目录生成appendonly.aof文件，将每一次写操作请求都追加到appendonly.aof 文件中

# echo 'vm.overcommit_memory=1' >> /etc/sysctl.conf

# sysctl -p
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
192.168.30.129

# mkdir -p /data/redis

# vim /usr/local/redis/redis.conf

bind 192.168.30.129
daemonize yes
logfile "/usr/local/redis/redis.log"
dir /data/redis
replicaof 192.168.30.128 6379
masterauth 123456
requirepass 123456
appendonly yes

# echo 'vm.overcommit_memory=1' >> /etc/sysctl.conf

# sysctl -p
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
192.168.30.130

# mkdir -p /data/redis

# vim /usr/local/redis/redis.conf

bind 192.168.30.130
daemonize yes
logfile "/usr/local/redis/redis.log"
dir /data/redis
replicaof 192.168.30.128 6379
masterauth 123456
requirepass 123456
appendonly yes

# echo 'vm.overcommit_memory=1' >> /etc/sysctl.conf

# sysctl -p
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
全部启动redis：
# systemctl start redis
1
查看集群状态：
# redis-cli -h 192.168.30.128 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.

192.168.30.128:6379> info replication
# Replication
role:master
connected_slaves:2
slave0:ip=192.168.30.129,port=6379,state=online,offset=168,lag=1
slave1:ip=192.168.30.130,port=6379,state=online,offset=168,lag=1
master_replid:fb4941e02d5032ad74c6e2383211fc58963dbe90
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:168
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:168
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
# redis-cli -h 192.168.30.129 -a 123456 info replication

Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
# Replication
role:slave
master_host:192.168.30.128
master_port:6379
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_repl_offset:196
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:fb4941e02d5032ad74c6e2383211fc58963dbe90
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:196
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:196
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
数据演示：
192.168.30.128:6379> keys *
(empty list or set)

192.168.30.128:6379> set key1 100
OK

192.168.30.128:6379> set key2 lzx
OK

192.168.30.128:6379> keys *
1) "key1"
2) "key2"
1
2
3
4
5
6
7
8
9
10
11
12
# redis-cli -h 192.168.30.129 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.

192.168.30.129:6379> keys *
1) "key2"
2) "key1"

192.168.30.129:6379> CONFIG GET dir
1) "dir"
2) "/data/redis"

192.168.30.129:6379> CONFIG GET dbfilename
1) "dbfilename"
2) "dump.rdb"

192.168.30.129:6379> get key1
"100"

192.168.30.129:6379> get key2
"lzx"

192.168.30.129:6379> set key3 aaa
(error) READONLY You can't write against a read only replica.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
# redis-cli -h 192.168.30.130 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.

192.168.30.130:6379> keys *
1) "key2"
2) "key1"

192.168.30.130:6379> CONFIG GET dir
1) "dir"
2) "/data/redis"

192.168.30.130:6379> CONFIG GET dbfilename
1) "dbfilename"
2) "dump.rdb"

192.168.30.130:6379> get key1
"100"

192.168.30.130:6379> get key2
"lzx"

192.168.30.130:6379> set key3 aaa
(error) READONLY You can't write against a read only replica.
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
可以看到，在master节点写入的数据，很快就同步到slave节点上，而且在slave节点上无法写入数据。

Sentinel模式
Sentinel模式介绍
主从模式的弊端就是不具备高可用性，当master挂掉以后，Redis将不能再对外提供写入操作，因此sentinel应运而生。

sentinel中文含义为哨兵，顾名思义，它的作用就是监控redis集群的运行状况，特点如下：

* sentinel模式是建立在主从模式的基础上，如果只有一个Redis节点，sentinel就没有任何意义

* 当master挂了以后，sentinel会在slave中选择一个做为master，并修改它们的配置文件，其他slave的配置文件也会被修改，比如slaveof属性会指向新的master

* 当master重新启动后，它将不再是master而是做为slave接收新的master的同步数据

* sentinel因为也是一个进程有挂掉的可能，所以sentinel也会启动多个形成一个sentinel集群

* 多sentinel配置的时候，sentinel之间也会自动监控

* 当主从模式配置密码时，sentinel也会同步将配置信息修改到配置文件中，不需要担心

* 一个sentinel或sentinel集群可以管理多个主从Redis，多个sentinel也可以监控同一个redis

* sentinel最好不要和Redis部署在同一台机器，不然Redis的服务器挂了以后，sentinel也挂了
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
工作机制：

* 每个sentinel以每秒钟一次的频率向它所知的master，slave以及其他sentinel实例发送一个 PING 命令 

* 如果一个实例距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被sentinel标记为主观下线。 

* 如果一个master被标记为主观下线，则正在监视这个master的所有sentinel要以每秒一次的频率确认master的确进入了主观下线状态

* 当有足够数量的sentinel（大于等于配置文件指定的值）在指定的时间范围内确认master的确进入了主观下线状态， 则master会被标记为客观下线 

* 在一般情况下， 每个sentinel会以每 10 秒一次的频率向它已知的所有master，slave发送 INFO 命令 

* 当master被sentinel标记为客观下线时，sentinel向下线的master的所有slave发送 INFO 命令的频率会从 10 秒一次改为 1 秒一次 

* 若没有足够数量的sentinel同意master已经下线，master的客观下线状态就会被移除；
  若master重新向sentinel的 PING 命令返回有效回复，master的主观下线状态就会被移除
1
2
3
4
5
6
7
8
9
10
11
12
13
14
当使用sentinel模式的时候，客户端就不要直接连接Redis，而是连接sentinel的ip和port，由sentinel来提供具体的可提供服务的Redis实现，这样当master节点挂掉以后，sentinel就会感知并将新的master节点提供给使用者。

Sentinel模式搭建
环境准备：
master节点              192.168.30.128          sentinel端口：26379

slave节点               192.168.30.129          sentinel端口：26379

slave节点               192.168.30.130          sentinel端口：26379
1
2
3
4
5
修改配置：
前面已经下载安装了redis，这里省略，直接修改sentinel配置文件。

192.168.30.128

# vim /usr/local/redis/sentinel.conf

daemonize yes
logfile "/usr/local/redis/sentinel.log"
dir "/usr/local/redis/sentinel"                 #sentinel工作目录
sentinel monitor mymaster 192.168.30.128 6379 2                 #判断master失效至少需要2个sentinel同意，建议设置为n/2+1，n为sentinel个数
sentinel auth-pass mymaster 123456
sentinel down-after-milliseconds mymaster 30000                 #判断master主观下线时间，默认30s
1
2
3
4
5
6
7
8
这里需要注意，sentinel auth-pass mymaster 123456需要配置在sentinel monitor mymaster 192.168.30.128 6379 2下面，否则启动报错：

# /usr/local/bin/redis-sentinel /usr/local/redis/sentinel.conf

*** FATAL CONFIG FILE ERROR ***
Reading the configuration file, at line 104
>>> 'sentinel auth-pass mymaster 123456'
No such master with specified name.
1
2
3
4
5
6
全部启动sentinel：
# mkdir /usr/local/redis/sentinel && chown -R redis:redis /usr/local/redis

# /usr/local/bin/redis-sentinel /usr/local/redis/sentinel.conf
1
2
3
任一主机查看日志：
# tail -f /usr/local/redis/sentinel.log

21574:X 09 May 2019 15:32:04.298 # Sentinel ID is 30c417116a8edbab09708037366c4a7471beb770
21574:X 09 May 2019 15:32:04.298 # +monitor master mymaster 192.168.30.128 6379 quorum 2
21574:X 09 May 2019 15:32:04.299 * +slave slave 192.168.30.129:6379 192.168.30.129 6379 @ mymaster 192.168.30.128 6379
21574:X 09 May 2019 15:32:04.300 * +slave slave 192.168.30.130:6379 192.168.30.130 6379 @ mymaster 192.168.30.128 6379
21574:X 09 May 2019 15:32:16.347 * +sentinel sentinel 79b8d61626afd4d059fb5a6a63393e9a1374e78f 192.168.30.129 26379 @ mymaster 192.168.30.128 6379
21574:X 09 May 2019 15:32:31.584 * +sentinel sentinel d7b429dcba792103ef0d80827dd0910bd9284d21 192.168.30.130 26379 @ mymaster 192.168.30.128 6379
1
2
3
4
5
6
7
8
Sentinel模式下的几个事件：

·       +reset-master ：主服务器已被重置。

·       +slave ：一个新的从服务器已经被 Sentinel 识别并关联。

·       +failover-state-reconf-slaves ：故障转移状态切换到了 reconf-slaves 状态。

·       +failover-detected ：另一个 Sentinel 开始了一次故障转移操作，或者一个从服务器转换成了主服务器。

·       +slave-reconf-sent ：领头（leader）的 Sentinel 向实例发送了 [SLAVEOF](/commands/slaveof.html) 命令，为实例设置新的主服务器。

·       +slave-reconf-inprog ：实例正在将自己设置为指定主服务器的从服务器，但相应的同步过程仍未完成。

·       +slave-reconf-done ：从服务器已经成功完成对新主服务器的同步。

·       -dup-sentinel ：对给定主服务器进行监视的一个或多个 Sentinel 已经因为重复出现而被移除 —— 当 Sentinel 实例重启的时候，就会出现这种情况。

·       +sentinel ：一个监视给定主服务器的新 Sentinel 已经被识别并添加。

·       +sdown ：给定的实例现在处于主观下线状态。

·       -sdown ：给定的实例已经不再处于主观下线状态。

·       +odown ：给定的实例现在处于客观下线状态。

·       -odown ：给定的实例已经不再处于客观下线状态。

·       +new-epoch ：当前的纪元（epoch）已经被更新。

·       +try-failover ：一个新的故障迁移操作正在执行中，等待被大多数 Sentinel 选中（waiting to be elected by the majority）。

·       +elected-leader ：赢得指定纪元的选举，可以进行故障迁移操作了。

·       +failover-state-select-slave ：故障转移操作现在处于 select-slave 状态 —— Sentinel 正在寻找可以升级为主服务器的从服务器。

·       no-good-slave ：Sentinel 操作未能找到适合进行升级的从服务器。Sentinel 会在一段时间之后再次尝试寻找合适的从服务器来进行升级，又或者直接放弃执行故障转移操作。

·       selected-slave ：Sentinel 顺利找到适合进行升级的从服务器。

·       failover-state-send-slaveof-noone ：Sentinel 正在将指定的从服务器升级为主服务器，等待升级功能完成。

·       failover-end-for-timeout ：故障转移因为超时而中止，不过最终所有从服务器都会开始复制新的主服务器（slaves will eventually be configured to replicate with the new master anyway）。

·       failover-end ：故障转移操作顺利完成。所有从服务器都开始复制新的主服务器了。

·       +switch-master ：配置变更，主服务器的 IP 和地址已经改变。 这是绝大多数外部用户都关心的信息。

·       +tilt ：进入 tilt 模式。

·       -tilt ：退出 tilt 模式。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
master宕机演示：
192.168.30.128

# systemctl stop redis

# tail -f /usr/local/redis/sentinel.log

22428:X 09 May 2019 15:51:29.287 # +sdown master mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:29.371 # +odown master mymaster 192.168.30.128 6379 #quorum 2/2
22428:X 09 May 2019 15:51:29.371 # +new-epoch 1
22428:X 09 May 2019 15:51:29.371 # +try-failover master mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:29.385 # +vote-for-leader 30c417116a8edbab09708037366c4a7471beb770 1
22428:X 09 May 2019 15:51:29.403 # d7b429dcba792103ef0d80827dd0910bd9284d21 voted for 30c417116a8edbab09708037366c4a7471beb770 1
22428:X 09 May 2019 15:51:29.408 # 79b8d61626afd4d059fb5a6a63393e9a1374e78f voted for 30c417116a8edbab09708037366c4a7471beb770 1
22428:X 09 May 2019 15:51:29.451 # +elected-leader master mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:29.451 # +failover-state-select-slave master mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:29.528 # +selected-slave slave 192.168.30.129:6379 192.168.30.129 6379 @ mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:29.528 * +failover-state-send-slaveof-noone slave 192.168.30.129:6379 192.168.30.129 6379 @ mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:29.594 * +failover-state-wait-promotion slave 192.168.30.129:6379 192.168.30.129 6379 @ mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:30.190 # +promoted-slave slave 192.168.30.129:6379 192.168.30.129 6379 @ mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:30.190 # +failover-state-reconf-slaves master mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:30.258 * +slave-reconf-sent slave 192.168.30.130:6379 192.168.30.130 6379 @ mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:30.511 # -odown master mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:31.233 * +slave-reconf-inprog slave 192.168.30.130:6379 192.168.30.130 6379 @ mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:31.233 * +slave-reconf-done slave 192.168.30.130:6379 192.168.30.130 6379 @ mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:31.297 # +failover-end master mymaster 192.168.30.128 6379
22428:X 09 May 2019 15:51:31.297 # +switch-master mymaster 192.168.30.128 6379 192.168.30.129 6379
22428:X 09 May 2019 15:51:31.298 * +slave slave 192.168.30.130:6379 192.168.30.130 6379 @ mymaster 192.168.30.129 6379
22428:X 09 May 2019 15:51:31.298 * +slave slave 192.168.30.128:6379 192.168.30.128 6379 @ mymaster 192.168.30.129 6379
22428:X 09 May 2019 15:52:31.307 # +sdown slave 192.168.30.128:6379 192.168.30.128 6379 @ mymaster 192.168.30.129 6379
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
从日志中可以看到，master已经从192.168.30.128转移到192.168.30.129上

192.168.30.129上查看集群信息

# /usr/local/bin/redis-cli -h 192.168.30.129 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.

192.168.30.129:6379> info replication
# Replication
role:master
connected_slaves:1
slave0:ip=192.168.30.130,port=6379,state=online,offset=291039,lag=1
master_replid:757aff269236ed2707ba584a86a40716c1c76d74
master_replid2:47a862fc0ff20362be29096ecdcca6d432070ee9
master_repl_offset:291182
second_repl_offset:248123
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:291182

192.168.30.129:6379> set key4 linux
OK
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
当前集群中只有一个slave——192.168.30.130，master是192.168.30.129，且192.168.30.129具有写权限。

192.168.30.130上查看redis的配置文件也可以看到replicaof 192.168.30.129 6379，这是sentinel在选举master是做的修改。

重新把192.168.30.128上进程启动

# systemctl start redis

# tail -f /usr/local/redis/sentinel.log

22428:X 09 May 2019 15:51:31.297 # +switch-master mymaster 192.168.30.128 6379 192.168.30.129 6379
22428:X 09 May 2019 15:51:31.298 * +slave slave 192.168.30.130:6379 192.168.30.130 6379 @ mymaster 192.168.30.129 6379
22428:X 09 May 2019 15:51:31.298 * +slave slave 192.168.30.128:6379 192.168.30.128 6379 @ mymaster 192.168.30.129 6379
22428:X 09 May 2019 15:52:31.307 # +sdown slave 192.168.30.128:6379 192.168.30.128 6379 @ mymaster 192.168.30.129 6379
22428:X 09 May 2019 16:01:24.872 # -sdown slave 192.168.30.128:6379 192.168.30.128 6379 @ mymaster 192.168.30.129 6379
1
2
3
4
5
6
7
8
9
查看集群信息

# /usr/local/bin/redis-cli -h 192.168.30.128 -p 6379 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.

192.168.30.128:6379> info replication
# Replication
role:slave
master_host:192.168.30.129
master_port:6379
master_link_status:up
master_last_io_seconds_ago:0
master_sync_in_progress:0
slave_repl_offset:514774
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:757aff269236ed2707ba584a86a40716c1c76d74
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:514774
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:376528
repl_backlog_histlen:138247

192.168.30.128:6379> get key4
"linux"

192.168.30.128:6379> set key5
(error) ERR wrong number of arguments for 'set' command
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
即使192.168.30.128重新启动redis服务，也是作为slave加入redis集群，192.168.30.129仍然是master。

Cluster模式
Cluster模式介绍
sentinel模式基本可以满足一般生产的需求，具备高可用性。但是当数据量过大到一台服务器存放不下的情况时，主从模式或sentinel模式就不能满足需求了，这个时候需要对存储的数据进行分片，将数据存储到多个Redis实例中。cluster模式的出现就是为了解决单机Redis容量有限的问题，将Redis的数据根据一定的规则分配到多台机器。

cluster可以说是sentinel和主从模式的结合体，通过cluster可以实现主从和master重选功能，所以如果配置两个副本三个分片的话，就需要六个Redis实例。因为Redis的数据是根据一定规则分配到cluster的不同机器的，当数据量过大时，可以新增机器进行扩容。

使用集群，只需要将redis配置文件中的cluster-enable配置打开即可。每个集群中至少需要三个主数据库才能正常运行，新增节点非常方便。

cluster集群特点：

* 多个redis节点网络互联，数据共享

* 所有的节点都是一主一从（也可以是一主多从），其中从不提供服务，仅作为备用

* 不支持同时处理多个key（如MSET/MGET），因为redis需要把key均匀分布在各个节点上，
  并发量很高的情况下同时创建key-value会降低性能并导致不可预测的行为
  
* 支持在线增加、删除节点

* 客户端可以连接任何一个主节点进行读写
1
2
3
4
5
6
7
8
9
10
Cluster模式搭建
环境准备：
三台机器，分别开启两个redis服务（端口）

192.168.30.128              端口：7001,7002

192.168.30.129              端口：7003,7004

192.168.30.130              端口：7005,7006
1
2
3
4
5
6
7
修改配置文件：
192.168.30.128

# mkdir /usr/local/redis/cluster

# cp /usr/local/redis/redis.conf /usr/local/redis/cluster/redis_7001.conf

# cp /usr/local/redis/redis.conf /usr/local/redis/cluster/redis_7002.conf

# chown -R redis:redis /usr/local/redis

# mkdir -p /data/redis/cluster/{redis_7001,redis_7002} && chown -R redis:redis /data/redis
1
2
3
4
5
6
7
8
9
# vim /usr/local/redis/cluster/redis_7001.conf

bind 192.168.30.128
port 7001
daemonize yes
pidfile "/var/run/redis_7001.pid"
logfile "/usr/local/redis/cluster/redis_7001.log"
dir "/data/redis/cluster/redis_7001"
#replicaof 192.168.30.129 6379
masterauth 123456
requirepass 123456
appendonly yes
cluster-enabled yes
cluster-config-file nodes_7001.conf
cluster-node-timeout 15000
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
# vim /usr/local/redis/cluster/redis_7002.conf

bind 192.168.30.128
port 7002
daemonize yes
pidfile "/var/run/redis_7002.pid"
logfile "/usr/local/redis/cluster/redis_7002.log"
dir "/data/redis/cluster/redis_7002"
#replicaof 192.168.30.129 6379
masterauth "123456"
requirepass "123456"
appendonly yes
cluster-enabled yes
cluster-config-file nodes_7002.conf
cluster-node-timeout 15000
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
其它两台机器配置与192.168.30.128一致，此处省略

启动redis服务：
# redis-server /usr/local/redis/cluster/redis_7001.conf

# tail -f /usr/local/redis/cluster/redis_7001.log

# redis-server /usr/local/redis/cluster/redis_7002.conf

# tail -f /usr/local/redis/cluster/redis_7002.log
1
2
3
4
5
6
7
其它两台机器启动与192.168.30.128一致，此处省略

安装ruby并创建集群（低版本）：
如果redis版本比较低，则需要安装ruby。任选一台机器安装ruby即可

# yum -y groupinstall "Development Tools"

# yum install -y gdbm-devel libdb4-devel libffi-devel libyaml libyaml-devel ncurses-devel openssl-devel readline-devel tcl-devel

# mkdir -p ~/rpmbuild/{BUILD,BUILDROOT,RPMS,SOURCES,SPECS,SRPMS}

# wget http://cache.ruby-lang.org/pub/ruby/2.2/ruby-2.2.3.tar.gz -P ~/rpmbuild/SOURCES

# wget http://raw.githubusercontent.com/tjinjin/automate-ruby-rpm/master/ruby22x.spec -P ~/rpmbuild/SPECS

# rpmbuild -bb ~/rpmbuild/SPECS/ruby22x.spec

# rpm -ivh ~/rpmbuild/RPMS/x86_64/ruby-2.2.3-1.el7.x86_64.rpm

# gem install redis                 #目的是安装这个，用于配置集群
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
# cp /usr/local/redis/src/redis-trib.rb /usr/bin/

# redis-trib.rb create --replicas 1 192.168.30.128:7001 192.168.30.128:7002 192.168.30.129:7003 192.168.30.129:7004 192.168.30.130:7005 192.168.30.130:7006
1
2
3
创建集群：
我这里是redis5.0.4，所以不需要安装ruby，直接创建集群即可

# redis-cli -a 123456 --cluster create 192.168.30.128:7001 192.168.30.128:7002 192.168.30.129:7003 192.168.30.129:7004 192.168.30.130:7005 192.168.30.130:7006 --cluster-replicas 1

Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
>>> Performing hash slots allocation on 6 nodes...
Master[0] -> Slots 0 - 5460
Master[1] -> Slots 5461 - 10922
Master[2] -> Slots 10923 - 16383
Adding replica 192.168.30.129:7004 to 192.168.30.128:7001
Adding replica 192.168.30.130:7006 to 192.168.30.129:7003
Adding replica 192.168.30.128:7002 to 192.168.30.130:7005
M: 80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001
   slots:[0-5460] (5461 slots) master
S: b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002
   replicates 6788453ee9a8d7f72b1d45a9093838efd0e501f1
M: 4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003
   slots:[5461-10922] (5462 slots) master
S: b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004
   replicates 80c80a3f3e33872c047a8328ad579b9bea001ad8
M: 6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005
   slots:[10923-16383] (5461 slots) master
S: 277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006
   replicates 4d74ec66e898bf09006dac86d4928f9fad81f373
Can I set the above configuration? (type 'yes' to accept): yes                  #输入yes，接受上面配置
>>> Nodes configuration updated
>>> Assign a different config epoch to each node
>>> Sending CLUSTER MEET messages to join the cluster
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
可以看到，

192.168.30.128:7001是master，它的slave是192.168.30.129:7004；

192.168.30.129:7003是master，它的slave是192.168.30.130:7006；

192.168.30.130:7005是master，它的slave是192.168.30.128:7002
1
2
3
4
5
自动生成nodes.conf文件：

# ls /data/redis/cluster/redis_7001/
appendonly.aof  dump.rdb  nodes-7001.conf

# vim /data/redis/cluster/redis_7001/nodes-7001.conf 

6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557454406312 5 connected 10923-16383
277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557454407000 6 connected
b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave 6788453ee9a8d7f72b1d45a9093838efd0e501f1 0 1557454408371 5 connected
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 myself,master - 0 1557454406000 1 connected 0-5460
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 slave 80c80a3f3e33872c047a8328ad579b9bea001ad8 0 1557454407366 4 connected
4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 master - 0 1557454407000 3 connected 5461-10922
vars currentEpoch 6 lastVoteEpoch 0
1
2
3
4
5
6
7
8
9
10
11
12
集群操作
登录集群：
# redis-cli -c -h 192.168.30.128 -p 7001 -a 123456                  # -c，使用集群方式登录
1
查看集群信息：
192.168.30.128:7001> CLUSTER INFO                   #集群状态

cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_ping_sent:580
cluster_stats_messages_pong_sent:551
cluster_stats_messages_sent:1131
cluster_stats_messages_ping_received:546
cluster_stats_messages_pong_received:580
cluster_stats_messages_meet_received:5
cluster_stats_messages_received:1131
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
列出节点信息：
192.168.30.128:7001> CLUSTER NODES                  #列出节点信息

6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557455176000 5 connected 10923-16383
277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557455174000 6 connected
b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave 6788453ee9a8d7f72b1d45a9093838efd0e501f1 0 1557455175000 5 connected
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 myself,master - 0 1557455175000 1 connected 0-5460
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 slave 80c80a3f3e33872c047a8328ad579b9bea001ad8 0 1557455174989 4 connected
4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 master - 0 1557455175995 3 connected 5461-10922
1
2
3
4
5
6
7
8
这里与nodes.conf文件内容相同

写入数据：
192.168.30.128:7001> set key111 aaa
-> Redirected to slot [13680] located at 192.168.30.130:7005                #说明数据到了192.168.30.130:7005上
OK

192.168.30.130:7005> set key222 bbb
-> Redirected to slot [2320] located at 192.168.30.128:7001                 #说明数据到了192.168.30.128:7001上
OK

192.168.30.128:7001> set key333 ccc
-> Redirected to slot [7472] located at 192.168.30.129:7003                 #说明数据到了192.168.30.129:7003上
OK

192.168.30.129:7003> get key111
-> Redirected to slot [13680] located at 192.168.30.130:7005
"aaa"

192.168.30.130:7005> get key333
-> Redirected to slot [7472] located at 192.168.30.129:7003
"ccc"

192.168.30.129:7003> 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
可以看出redis cluster集群是去中心化的，每个节点都是平等的，连接哪个节点都可以获取和设置数据。

当然，平等指的是master节点，因为slave节点根本不提供服务，只是作为对应master节点的一个备份。

增加节点：
192.168.30.129上增加一节点：

# cp /usr/local/redis/cluster/redis_7003.conf /usr/local/redis/cluster/redis_7007.conf

# vim /usr/local/redis/cluster/redis_7007.conf

bind 192.168.30.129
port 7007
daemonize yes
pidfile "/var/run/redis_7007.pid"
logfile "/usr/local/redis/cluster/redis_7007.log"
dir "/data/redis/cluster/redis_7007"
#replicaof 192.168.30.129 6379
masterauth "123456"
requirepass "123456"
appendonly yes
cluster-enabled yes
cluster-config-file nodes_7007.conf
cluster-node-timeout 15000

# mkdir /data/redis/cluster/redis_7007

# chown -R redis:redis /usr/local/redis && chown -R redis:redis /data/redis

# redis-server /usr/local/redis/cluster/redis_7007.conf 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
192.168.30.130上增加一节点：

# cp /usr/local/redis/cluster/redis_7005.conf /usr/local/redis/cluster/redis_7008.conf

# vim /usr/local/redis/cluster/redis_7007.conf

bind 192.168.30.130
port 7008
daemonize yes
pidfile "/var/run/redis_7008.pid"
logfile "/usr/local/redis/cluster/redis_7008.log"
dir "/data/redis/cluster/redis_7008"
#replicaof 192.168.30.130 6379
masterauth "123456"
requirepass "123456"
appendonly yes
cluster-enabled yes
cluster-config-file nodes_7008.conf
cluster-node-timeout 15000

# mkdir /data/redis/cluster/redis_7008

# chown -R redis:redis /usr/local/redis && chown -R redis:redis /data/redis

# redis-server /usr/local/redis/cluster/redis_7008.conf 
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
集群中增加节点：

192.168.30.129:7003> CLUSTER MEET 192.168.30.129 7007
OK

192.168.30.129:7003> CLUSTER NODES

4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 myself,master - 0 1557457361000 3 connected 5461-10922
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 master - 0 1557457364746 1 connected 0-5460
277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557457362000 6 connected
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 slave 80c80a3f3e33872c047a8328ad579b9bea001ad8 0 1557457363000 4 connected
b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave 6788453ee9a8d7f72b1d45a9093838efd0e501f1 0 1557457362000 5 connected
e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 192.168.30.129:7007@17007 master - 0 1557457362729 0 connected
6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557457363739 5 connected 10923-16383
1
2
3
4
5
6
7
8
9
10
11
12
192.168.30.129:7003> CLUSTER MEET 192.168.30.130 7008
OK

192.168.30.129:7003> CLUSTER NODES

4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 myself,master - 0 1557457489000 3 connected 5461-10922
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 master - 0 1557457489000 1 connected 0-5460
277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557457489000 6 connected
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 slave 80c80a3f3e33872c047a8328ad579b9bea001ad8 0 1557457488000 4 connected
b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave 6788453ee9a8d7f72b1d45a9093838efd0e501f1 0 1557457489472 5 connected
1a1c7f02fce87530bd5abdfc98df1cffce4f1767 192.168.30.130:7008@17008 master - 0 1557457489259 0 connected
e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 192.168.30.129:7007@17007 master - 0 1557457489000 0 connected
6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557457490475 5 connected 10923-16383
1
2
3
4
5
6
7
8
9
10
11
12
13
可以看到，新增的节点都是以master身份加入集群的

更换节点身份：
将新增的192.168.30.130:7008节点身份改为192.168.30.129:7007的slave

# redis-cli -c -h 192.168.30.130 -p 7008 -a 123456 cluster replicate e51ab166bc0f33026887bcf8eba0dff3d5b0bf14
1
cluster replicate后面跟node_id，更改对应节点身份。也可以登入集群更改

# redis-cli -c -h 192.168.30.130 -p 7008 -a 123456

192.168.30.130:7008> CLUSTER REPLICATE e51ab166bc0f33026887bcf8eba0dff3d5b0bf14
OK

192.168.30.130:7008> CLUSTER NODES

277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557458316881 3 connected
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 master - 0 1557458314864 1 connected 0-5460
4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 master - 0 1557458316000 3 connected 5461-10922
6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557458315872 5 connected 10923-16383
b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave 6788453ee9a8d7f72b1d45a9093838efd0e501f1 0 1557458317890 5 connected
1a1c7f02fce87530bd5abdfc98df1cffce4f1767 192.168.30.130:7008@17008 myself,slave e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 0 1557458315000 7 connected
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 slave 80c80a3f3e33872c047a8328ad579b9bea001ad8 0 1557458315000 1 connected
e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 192.168.30.129:7007@17007 master - 0 1557458314000 0 connected
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
查看相应的nodes.conf文件，可以发现有更改，它记录当前集群的节点信息

# cat /data/redis/cluster/redis_7001/nodes-7001.conf

1a1c7f02fce87530bd5abdfc98df1cffce4f1767 192.168.30.130:7008@17008 slave e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 0 1557458236169 7 connected
6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557458235000 5 connected 10923-16383
277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557458234103 6 connected
b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave 6788453ee9a8d7f72b1d45a9093838efd0e501f1 0 1557458235129 5 connected
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 myself,master - 0 1557458234000 1 connected 0-5460
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 slave 80c80a3f3e33872c047a8328ad579b9bea001ad8 0 1557458236000 4 connected
e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 192.168.30.129:7007@17007 master - 0 1557458236000 0 connected
4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 master - 0 1557458233089 3 connected 5461-10922
vars currentEpoch 7 lastVoteEpoch 0
1
2
3
4
5
6
7
8
9
10
11
删除节点：
192.168.30.130:7008> CLUSTER FORGET 1a1c7f02fce87530bd5abdfc98df1cffce4f1767
(error) ERR I tried hard but I can't forget myself...               #无法删除登录节点

192.168.30.130:7008> CLUSTER FORGET e51ab166bc0f33026887bcf8eba0dff3d5b0bf14
(error) ERR Can't forget my master!                 #不能删除自己的master节点

192.168.30.130:7008> CLUSTER FORGET 6788453ee9a8d7f72b1d45a9093838efd0e501f1
OK              #可以删除其它的master节点

192.168.30.130:7008> CLUSTER NODES

277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557458887328 3 connected
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 master - 0 1557458887000 1 connected 0-5460
4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 master - 0 1557458886000 3 connected 5461-10922
b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave - 0 1557458888351 5 connected
1a1c7f02fce87530bd5abdfc98df1cffce4f1767 192.168.30.130:7008@17008 myself,slave e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 0 1557458885000 7 connected
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 slave 80c80a3f3e33872c047a8328ad579b9bea001ad8 0 1557458883289 1 connected
e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 192.168.30.129:7007@17007 master - 0 1557458885310 0 connected

192.168.30.130:7008> CLUSTER FORGET b4d3eb411a7355d4767c6c23b4df69fa183ef8bc
OK              #可以删除其它的slave节点

192.168.30.130:7008> CLUSTER NODES

277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557459031397 3 connected
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 master - 0 1557459032407 1 connected 0-5460
4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 master - 0 1557459035434 3 connected 5461-10922
6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557459034000 5 connected 10923-16383
1a1c7f02fce87530bd5abdfc98df1cffce4f1767 192.168.30.130:7008@17008 myself,slave e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 0 1557459032000 7 connected
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 slave 80c80a3f3e33872c047a8328ad579b9bea001ad8 0 1557459034000 1 connected
e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 192.168.30.129:7007@17007 master - 0 1557459034427 0 connected
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
保存配置：
192.168.30.130:7008> CLUSTER SAVECONFIG                 #将节点配置信息保存到硬盘
OK
 
# cat /data/redis/cluster/redis_7001/nodes-7001.conf

1a1c7f02fce87530bd5abdfc98df1cffce4f1767 192.168.30.130:7008@17008 slave e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 0 1557458236169 7 connected
6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557458235000 5 connected 10923-16383
277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557458234103 6 connected
b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave 6788453ee9a8d7f72b1d45a9093838efd0e501f1 0 1557458235129 5 connected
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 myself,master - 0 1557458234000 1 connected 0-5460
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 slave 80c80a3f3e33872c047a8328ad579b9bea001ad8 0 1557458236000 4 connected
e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 192.168.30.129:7007@17007 master - 0 1557458236000 0 connected
4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 master - 0 1557458233089 3 connected 5461-10922
vars currentEpoch 7 lastVoteEpoch 0

# redis-cli -c -h 192.168.30.130 -p 7008 -a 123456
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.

192.168.30.130:7008> CLUSTER NODES
277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557459500741 3 connected
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 master - 0 1557459500000 1 connected 0-5460
4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 master - 0 1557459501000 3 connected 5461-10922
6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557459500000 5 connected 10923-16383
b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave 6788453ee9a8d7f72b1d45a9093838efd0e501f1 0 1557459499737 5 connected
1a1c7f02fce87530bd5abdfc98df1cffce4f1767 192.168.30.130:7008@17008 myself,slave e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 0 1557459499000 7 connected
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 slave 80c80a3f3e33872c047a8328ad579b9bea001ad8 0 1557459501750 1 connected
e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 192.168.30.129:7007@17007 master - 0 1557459498000 0 connected
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
可以看到，之前删除的节点又恢复了，这是因为对应的配置文件没有删除，执行CLUSTER SAVECONFIG恢复。

模拟master节点挂掉：
192.168.30.128

# netstat -lntp |grep 7001
tcp        0      0 192.168.30.128:17001    0.0.0.0:*               LISTEN      6701/redis-server 1 
tcp        0      0 192.168.30.128:7001     0.0.0.0:*               LISTEN      6701/redis-server 1 

# kill 6701
1
2
3
4
5
192.168.30.130:7008> CLUSTER NODES

277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557461178000 3 connected
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 master,fail - 1557460950483 1557460947145 1 disconnected
4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 master - 0 1557461174922 3 connected 5461-10922
6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557461181003 5 connected 10923-16383
b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave 6788453ee9a8d7f72b1d45a9093838efd0e501f1 0 1557461179993 5 connected
1a1c7f02fce87530bd5abdfc98df1cffce4f1767 192.168.30.130:7008@17008 myself,slave e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 0 1557461176000 7 connected
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 master - 0 1557461178981 8 connected 0-5460
e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 192.168.30.129:7007@17007 master - 0 1557461179000 0 connected
1
2
3
4
5
6
7
8
9
10
对应7001的一行可以看到，master fail，状态为disconnected；而对应7004的一行，slave已经变成master。

重新启动7001节点：
# redis-server /usr/local/redis/cluster/redis_7001.conf

192.168.30.130:7008> CLUSTER NODES

277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.30.130:7006@17006 slave 4d74ec66e898bf09006dac86d4928f9fad81f373 0 1557461307000 3 connected
80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.30.128:7001@17001 slave b6331cbc986794237c83ed2d5c30777c1551546e 0 1557461305441 8 connected
4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.30.129:7003@17003 master - 0 1557461307962 3 connected 5461-10922
6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.30.130:7005@17005 master - 0 1557461304935 5 connected 10923-16383
b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.30.128:7002@17002 slave 6788453ee9a8d7f72b1d45a9093838efd0e501f1 0 1557461306000 5 connected
1a1c7f02fce87530bd5abdfc98df1cffce4f1767 192.168.30.130:7008@17008 myself,slave e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 0 1557461305000 7 connected
b6331cbc986794237c83ed2d5c30777c1551546e 192.168.30.129:7004@17004 master - 0 1557461308972 8 connected 0-5460
e51ab166bc0f33026887bcf8eba0dff3d5b0bf14 192.168.30.129:7007@17007 master - 0 1557461307000 0 connected
1
2
3
4
5
6
7
8
9
10
11
12
可以看到，7001节点启动后为slave节点，并且是7004的slave节点。即master节点如果挂掉，它的slave节点变为新master节点继续对外提供服务，而原来的master节点如果重启，则变为新master节点的slave节点。

另外，如果这里是拿7007节点做测试的话，会发现7008节点并不会切换，这是因为7007节点上根本没数据。集群数据被分为三份，采用哈希槽 (hash slot)的方式来分配16384个slot的话，它们三个节点分别承担的slot 区间是：

节点7004覆盖0－5460
节点7003覆盖5461－10922
节点7005覆盖10923－16383
1
2
3
更多参考：

Redis集群常用命令


点赞
68

评论
54

分享

收藏
343

手机看

打赏

关注
咖啡男孩之SRE之路
 3万+

三张图秒懂Redis集群设计原理 
Redis集群设计包括2部分：哈希Slot和节点主从，本篇博文通过3张图来搞明白Redis的集群设计。想扩展并发读就添加Slaver，想扩展并发写就添加Master，想扩容也就是添加Master，任何一个Slaver或者几个Master挂了都不会是灾难性的故障。..
```


 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？
 ```
    set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！
 ```
45.Redis做异步队列一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
```
    缺点：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。

```
能不能生产一次消费多次呢？
```
    使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

```

51.多节点 Redis 分布式锁：
```
    Redlock 算法获取当前时间（start）。依次向 N 个 Redis节点请求锁。请求锁的方式与从单节点 Redis获取锁的方式一致。
    为了保证在某个 Redis节点不可用时该算法能够继续运行，获取锁的操作都需要设置超时时间，需要保证该超时时间远小于锁的有效时间。
    这样才能保证客户端在向某个 Redis节点获取锁失败之后，可以立刻尝试下一个节点。计算获取锁的过程总共消耗多长时间（consumeTime = end - start）。
    如果客户端从大多数 Redis节点（>= N/2 + 1) 成功获取锁，并且获取锁总时长没有超过锁的有效时间，这种情况下，客户端会认为获取锁成功，否则，获取锁失败。
    如果最终获取锁成功，锁的有效时间应该重新设置为锁最初的有效时间减去 consumeTime。如果最终获取锁失败，客户端应该立刻向所有 Redis节点发起释放锁的请求。
```

52.Redis 中设置过期时间主要通过以下四种方式
```
    expire key seconds：设置 key 在 n 秒后过期；
    pexpire key milliseconds：设置 key 在 n 毫秒后过期；
    expireat key timestamp：设置 key 在某个时间戳（精确到秒）之后过期；
    pexpireat key millisecondsTimestamp：设置 key 在某个时间戳（精确到毫秒）之后过期；
```
53.Reids三种不同删除策略定时删除：
```
    在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作惰性删除：
    放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键定期删除：
    每隔一点时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。
```

54.定时删除
```
优点：对内存友好，定时删除策略可以保证过期键会尽可能快地被删除，并释放国期间所占用的内存
缺点：对cpu时间不友好，在过期键比较多时，删除任务会占用很大一部分cpu时间，在内存不紧张但cpu时间紧张的情况下，
      将cpu时间用在删除和当前任务无关的过期键上，影响服务器的响应时间和吞吐量

定期删除由于定时删除会占用太多cpu时间，影响服务器的响应时间和吞吐量以及惰性删除浪费太多内存，有内存泄露的危险，所以出现一种整合和折中这两种策略的定期删除策略。
定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。定时删除策略有效地减少了因为过期键带来的内存浪费。
```
56.惰性删除
```
优点：对cpu时间友好，在每次从键空间获取键时进行过期键检查并是否删除，删除目标也仅限当前处理的键，这个策略不会在其他无关的删除任务上花费任何cpu时间。
缺点：对内存不友好，过期键过期也可能不会被删除，导致所占的内存也不会释放。甚至可能会出现内存泄露的现象，当存在很多过期键，而这些过期键又没有被访问到，
        这会可能导致它们会一直保存在内存中，造成内存泄露。
```


58.Redis常见的几种缓存策略
```
Cache-AsideRead-ThroughWrite-ThroughWrite-Behind

```
59.Redis Module 实现布隆过滤器Redis module 
```
是Redis 4.0 以后支持的新的特性，这里很多国外牛逼的大学和机构提供了很多牛逼的Module 只要编译引入到Redis 中就能轻松的实现我们某些需求的功能。
在Redis 官方Module 中有一些我们常见的一些模块，我们在这里就做一个简单的使用。
neural-redis 主要是神经网络的机器学，集成到redis 可以做一些机器训练感兴趣的可以尝试
RedisSearch 主要支持一些富文本的的搜索
RedisBloom 支持分布式环境下的Bloom 过滤器
```

60.Redis 到底是怎么实现“附近的人”使用方式GEOADD key longitude latitude member [longitude latitude member ...]
```
将给定的位置对象（纬度、经度、名字）添加到指定的key。
其中，key为集合名称，member为该经纬度所对应的对象。
在实际运用中，当所需存储的对象数量过多时，可通过设置多key(如一个省一个key)的方式对对象集合变相做sharding，避免单集合数量过多。
成功插入后的返回值：(integer) N其中N为成功插入的个数。
```








hash表的实现，包括STL中的哈希桶长度常数。
```
hash表的实现主要涉及两个问题：散列函数和碰撞处理。
    1）hash function （散列函数）。最常见的散列函数：f(x) = x % TableSize 
    .2）碰撞问题（不同元素的散列值相同）。解决碰撞问题的方法有许多种，包括线性探测、二次探测、开链等做法。
        SGL版本使用开链法，使用一个链表保持相同散列值的元素。虽然开链法并不要求表格大小必须为质数，但SGI STL仍然以质数来设计表格大小，并且将28个质数（逐渐呈现大约两倍的关系）计算好，以备随时访问，同时提供一个函数，用来查询在这28个质数之中，“最接近某数并大于某数”的质数。
```


9、hash表如何rehash，怎么处理其中保存的资源
```
    先想想为什么需要rehash:因为，当loadFactor（负载因子）<=1时，hash表查找的期望复杂度为O(1). 因此，每次往hash表中添加元素时，我们必须保证是在loadFactor <1的情况下，才能够添加。模仿C++的vector扩容方式，Hash表中每次发现loadFactor==1时，就开辟一个原来桶数组的两倍空间（称为新桶数组），然后把原来的桶数组中元素全部转移过来到新的桶数组中。注意这里转移是需要元素一个个重新哈希到新桶中的。
10、Redis的rehash怎么做的，为什么要渐进rehash，渐进rehash怎么实现的为了避免rehash对服务器造成影响，服务器不是一次将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1].
```


Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：
```
文件事件（服务器对套接字操作的抽象）和时间事件（服务器对定时操作的抽象）。Redis的定时机制就是借助时间事件实现的。一个时间事件主要由以下三个属性组成：id：时间事件标识号；when：记录时间事件的到达时间；timeProc：时间事件处理器，当时间事件到达时，服务器就会调用相应的处理器来处理时间。一个时间事件根据时间事件处理器的返回值来判断是定时事件还是周期性事件。
```



Reactor模型：
```
    1）Handle：即操作系统中的句柄，是对资源在操作系统层面上的一种抽象，它可以是打开的文件、一个连接(Socket)、Timer等。
        由于Reactor模式一般使用在网络编程中，因而这里一般指Socket Handle，即一个网络连接。
    2）Synchronous Event Demultiplexer（同步事件复用器）：阻塞等待一系列的Handle中的事件到来，如果阻塞等待返回，即表示在返回的Handle中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。
    3）Initiation Dispatcher：用于管理Event Handler，即EventHandler的容器，用以注册、移除EventHandler等；另外，它还作为Reactor模式的入口调用Synchronous Event Demultiplexer的select方法以阻塞等待事件返回，当阻塞等待返回时，根据事件发生的Handle将其分发给对应的Event Handler处理，即回调EventHandler中的handle_event()方法。
    4）Event Handler：定义事件处理方法：handle_event()，以供InitiationDispatcher回调使用。
    5）Concrete Event Handler：事件EventHandler接口，实现特定事件处理逻辑。
```

单核机器上写多线程程序，是否需要考虑加锁，为什么？
线程需要保存哪些上下文，SP、PC、EAX这些寄存器是干嘛用的

质数比合数更容易避免冲撞，也就是说使用质数时，哈希效果更好，原始数据经哈希后分布更均匀。
redis的主从复制怎么做的

Redis旧版复制功能只有同步和命令传播。新版复制功能加入了部分同步的功能。
```
）命令传播：当主服务器会将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。3）部分同步：（断线后重复制）复制偏移量：通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态。复制积压缓冲区：主服务保存最近的写命令到复制积压缓冲区，是一个先进先出队列服务器运行ID：从服务器记录上次同步的主服务器的Id。
```



### 扩展问题
如何把一个文件快速下发到100w个服务器

gossip算法？Gossip有众多的别名“闲话算法”、“疫情传播算法”、“病毒感染算法”、“谣言传播算法”。
如何判断一个图是否连同？

DFS、BFS、并查集

3. 如何实现一个引用计数指针，以及其中要注意的点？
```
这也是一个比较有内容的问题。大致说了一下方案，面试官又追问了诸如入侵性与非入侵性设计的区别、优劣，以及析构对象时多动态库架构情况下本地堆问题，
还有引用计数的多线程安全问题，有锁怎么实现，无锁怎么实现。

```
5. 为什么stl中的内存分配器要设计为一个模板参数而不是一个构造函数参数？这个就属于瞎聊了，各抒己见呗。最后扯到类型系统如何帮助程序员排错之类的问题。


